[{"ambient_color":[0.0,0.0,0.0],"background_color":[0.25000000067158873,0.25000000067158873,0.25000000067158873],"type":"SCENE","active_camera":"Camera","background_probe":{"parallax_volume":"","same_layers":false,"clip_end":1000,"clip_start":1,"compute_sh":false,"size":512,"sh_quality":64,"type":"CUBEMAP","object":"","reflection_plane":"","parallax_type":"NONE","auto_refresh":false,"double_refresh":false},"frame_end":250,"sequencer_strips":[],"fps":24,"debug_physics":false,"markers":[],"world_material":{"fragment":"varying vec3 view_position0;\nuniform sampler2D image1;\nvoid main(){\n    vec3 vec3_a;\n    vec4 color4_b;\n    vec4 color4_c;\n    vec4 color4_d;\n    vec4 vec4_e;\n    background_transform_to_world(view_position0, vec3_a);\n    node_tex_environment_equirectangular(vec3_a, image1, color4_b);\n    srgb_to_linearrgb(color4_b,color4_c);\n    node_background(color4_c, (1.0), vec3(0.0), color4_d);\n    linearrgb_to_srgb(color4_d, vec4_e);\n    gl_FragColor = vec4_e;\n}","varyings":[{"datatype":"vec3","varname":"view_position0","type":"VIEW_POSITION"}],"uniforms":[{"datatype":"mat3","varname":"view_imat3","type":"VIEW_IMAT3"},{"image":"PANO_20170709_153604.jpg","datatype":"sampler2D","varname":"image1","type":"IMAGE"}],"fixed_z":1,"material_type":"BLENDER_CYCLES_PBR","name":"Scene_world_background","type":"MATERIAL"},"stereo_eye_separation":0.10000000149011612,"frame_start":1,"name":"Scene","stereo":false,"gravity":[0,0,-9.800000190734863]},{"collision_bounds_type":"BOX","phy_type":"STATIC","collision_mask":255,"clip_start":1.0007989406585693,"frustum_size":10.0,"linear_factor":[1,1,1],"collision_margin":0.05999999865889549,"shadow_bias":1.0,"name":"Lamp","bleed_bias":0.0,"scale":[1.0,1.0,1.0],"collision_group":1,"anisotropic_friction":false,"energy":0.07699999809265137,"type":"LAMP","animation_strips":[],"shadow":true,"friction":0.5,"size_x":0.10000000149011612,"mass":1.0,"pos":[-0.8829593658447266,-2.4341611862182617,3.014954090118408],"parent_bone":"","parent":null,"clip_end":30.00200080871582,"falloff_distance":29.999982833862305,"scene":"Scene","is_ghost":false,"rot":[0,-0.4010252058506012,-0.5401400923728943,0.632258951663971],"dupli_group":null,"rot_mode":"XYZ","form_factor":0.4000000059604645,"radius":1.0,"color":[1.0,1.0,1.0],"tex_size":2880,"actions":[],"properties":{},"friction_coefficients":[1.0,1.0,1.0],"lamp_type":"SUN","position":[-0.8829593658447266,-2.4341611862182617,3.014954090118408],"matrix_parent_inverse":[1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0],"offset_scale":[1,1,1],"collision_compound":false,"size_y":0.10000000149011612,"dimensions":[0.0,0.0,0.0],"no_sleeping":false,"angular_factor":[1,1,1],"visible":true,"elasticity":0},{"collision_bounds_type":"BOX","actions":[],"collision_mask":255,"clip_end":100.0,"clip_start":0.10000000149011612,"scene":"Scene","phy_type":"STATIC","is_ghost":false,"rot":[0,1.4656120538711548,0.020918920636177063,-0.3307180404663086],"ortho_scale":7.314285755157471,"linear_factor":[1,1,1],"sensor_fit":"AUTO","dupli_group":null,"rot_mode":"XYZ","anisotropic_friction":false,"parent_bone":"","angular_factor":[1,1,1],"collision_margin":0.05999999865889549,"form_factor":0.4000000059604645,"friction_coefficients":[1.0,1.0,1.0],"color":[0.0,0.0,0.0,0.0],"scale":[0.9999999403953552,1.0,0.9999999403953552],"collision_group":1,"pos":[-1.4152885675430298,-3.9900918006896973,1.6417490243911743],"radius":1.0,"elasticity":0,"type":"CAMERA","matrix_parent_inverse":[1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0],"offset_scale":[1,1,1],"collision_compound":false,"position":[-1.4152885675430298,-3.9900918006896973,1.6417490243911743],"animation_strips":[],"angle":0.8575560450553894,"friction":0.5,"dimensions":[0.0,0.0,0.0],"no_sleeping":false,"mass":1.0,"properties":{},"name":"Camera","visible":true,"parent":null,"cam_type":"PERSP"},{"collision_bounds_type":"CONVEX_HULL","phy_type":"RIGID_BODY","collision_mask":255,"materials":["pbr"],"bbox":[-1.1936510801315308,-0.6069531440734863,-0.6922615766525269,1.1936510801315308,0.33453357219696045,1.8220428228378296],"linear_factor":[1,1,1],"collision_margin":0.03999999910593033,"name":"roorh","passes":[0],"scale":[1.0,1.0,1.0],"elements":[["normal"],["tangent"],["uv","UVMap"]],"collision_group":1,"anisotropic_friction":false,"uv_multiplier":1.0,"mesh_name":"roorh","type":"MESH","animation_strips":[{"blend_in":0,"blend_out":0,"type":"CLIP","reversed":false,"action_frame_start":0.0,"frame_end":100.0,"repeat":1,"blend_type":"REPLACE","extrapolation":"HOLD","action":"simple_action","frame_start":0.0,"action_frame_end":100.0,"scale":1}],"stride":28,"friction":0.5,"zindex":1,"mass":1.0,"pos":[0.0,0.0,0.0],"parent_bone":"","parent":null,"scene":"Scene","is_ghost":false,"rot":[0,0.0,0.0,-0.9746530055999756],"dupli_group":null,"center":[0.0,-0.13620978593826294,0.5648906230926514],"rot_mode":"XYZ","hash":"2eb603f83ec7fbba09929556eb0f20e945f5070e","form_factor":0.4000000059604645,"tris_count":7558.0,"radius":1.0,"color":[1.0,1.0,1.0,1.0],"actions":[],"lod_levels":[],"avg_poly_area":0.00118433079830653,"properties":{},"friction_coefficients":[1.0,1.0,1.0],"position":[0.0,0.0,0.0],"matrix_parent_inverse":[1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0],"offset_scale":[1,1,1],"collision_compound":false,"all_f":false,"offsets":[0,0,37086,22674],"dimensions":[1.1936510801315308,0.9414867162704468,2.5143043994903564],"no_sleeping":false,"angular_factor":[1,1,1],"visible":true,"elasticity":0.0,"shape_multiplier":1.0},{"code":"#extension GL_OES_standard_derivatives : enable\n#ifdef GL_ES\n#extension GL_EXT_shader_texture_lod : enable\nprecision highp float;\nprecision highp int;\n#ifndef GL_EXT_shader_texture_lod\nvec4 texture2DLodEXT(sampler2D t, vec2 c, float level){\n    return texture2D(t, c, 1.0+level);}\nvec4 textureCubeLodEXT(samplerCube t, vec3 c, float level){\n    return textureCube(t, c, 2.0+level);}\n#endif\n#endif\n#define CORRECTION_NONE\nuniform mat3 view_imat3;\nuniform mat4 projection_matrix;\nuniform mat4 projection_matrix_inverse;\n/* Converters */\n\nfloat convert_rgba_to_float(vec4 color)\n{\n#ifdef USE_NEW_SHADING\n\treturn color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;\n#else\n\treturn (color.r + color.g + color.b) / 3.0;\n#endif\n}\n\nvoid convert_vec3_to_vec4(vec3 invec, float val, out vec4 outvec)\n{\n\toutvec = vec4(invec, val);\n}\n\nfloat exp_blender(float f)\n{\n\treturn pow(2.71828182846, f);\n}\n\nfloat compatible_pow(float x, float y)\n{\n\tif (y == 0.0) /* x^0 -> 1, including 0^0 */\n\t\treturn 1.0;\n\n\t/* glsl pow doesn't accept negative x */\n\tif (x < 0.0) {\n\t\tif (mod(-y, 2.0) == 0.0)\n\t\t\treturn pow(-x, y);\n\t\telse\n\t\t\treturn -pow(-x, y);\n\t}\n\telse if (x == 0.0)\n\t\treturn 0.0;\n\n\treturn pow(x, y);\n}\n\nvoid rgb_to_hsv(vec4 rgb, out vec4 outcol)\n{\n\tfloat cmax, cmin, h, s, v, cdelta;\n\tvec3 c;\n\n\tcmax = max(rgb[0], max(rgb[1], rgb[2]));\n\tcmin = min(rgb[0], min(rgb[1], rgb[2]));\n\tcdelta = cmax - cmin;\n\n\tv = cmax;\n\tif (cmax != 0.0)\n\t\ts = cdelta / cmax;\n\telse {\n\t\ts = 0.0;\n\t\th = 0.0;\n\t}\n\n\tif (s == 0.0) {\n\t\th = 0.0;\n\t}\n\telse {\n\t\tc = (vec3(cmax, cmax, cmax) - rgb.xyz) / cdelta;\n\n\t\tif (rgb.x == cmax) h = c[2] - c[1];\n\t\telse if (rgb.y == cmax) h = 2.0 + c[0] -  c[2];\n\t\telse h = 4.0 + c[1] - c[0];\n\n\t\th /= 6.0;\n\n\t\tif (h < 0.0)\n\t\t\th += 1.0;\n\t}\n\n\toutcol = vec4(h, s, v, rgb.w);\n}\n\nvoid hsv_to_rgb(vec4 hsv, out vec4 outcol)\n{\n\tfloat i, f, p, q, t, h, s, v;\n\tvec3 rgb;\n\n\th = hsv[0];\n\ts = hsv[1];\n\tv = hsv[2];\n\n\tif (s == 0.0) {\n\t\trgb = vec3(v, v, v);\n\t}\n\telse {\n\t\tif (h == 1.0)\n\t\t\th = 0.0;\n\n\t\th *= 6.0;\n\t\ti = floor(h);\n\t\tf = h - i;\n\t\trgb = vec3(f, f, f);\n\t\tp = v * (1.0 - s);\n\t\tq = v * (1.0 - (s * f));\n\t\tt = v * (1.0 - (s * (1.0 - f)));\n\n\t\tif (i == 0.0) rgb = vec3(v, t, p);\n\t\telse if (i == 1.0) rgb = vec3(q, v, p);\n\t\telse if (i == 2.0) rgb = vec3(p, v, t);\n\t\telse if (i == 3.0) rgb = vec3(p, q, v);\n\t\telse if (i == 4.0) rgb = vec3(t, p, v);\n\t\telse rgb = vec3(v, p, q);\n\t}\n\n\toutcol = vec4(rgb, hsv.w);\n}\n\nfloat srgb_to_linearrgb(float c)\n{\n\tif (c < 0.04045)\n\t\treturn (c < 0.0) ? 0.0 : c * (1.0 / 12.92);\n\telse\n\t\treturn pow((c + 0.055) * (1.0 / 1.055), 2.4);\n}\n\nfloat linearrgb_to_srgb(float c)\n{\n\tif (c < 0.0031308)\n\t\treturn (c < 0.0) ? 0.0 : c * 12.92;\n\telse\n\t\treturn 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\n\nvoid srgb_to_linearrgb(vec4 col_from, out vec4 col_to)\n{\n\tcol_to.r = srgb_to_linearrgb(col_from.r);\n\tcol_to.g = srgb_to_linearrgb(col_from.g);\n\tcol_to.b = srgb_to_linearrgb(col_from.b);\n\tcol_to.a = col_from.a;\n}\n\nvoid linearrgb_to_srgb(vec4 col_from, out vec4 col_to)\n{\n\tcol_to.r = linearrgb_to_srgb(col_from.r);\n\tcol_to.g = linearrgb_to_srgb(col_from.g);\n\tcol_to.b = linearrgb_to_srgb(col_from.b);\n\tcol_to.a = col_from.a;\n}\n\nvoid color_to_normal(vec3 color, out vec3 normal)\n{\n\tnormal.x =  2.0 * ((color.r) - 0.5);\n\tnormal.y = -2.0 * ((color.g) - 0.5);\n\tnormal.z =  2.0 * ((color.b) - 0.5);\n}\n\nvoid color_to_normal_new_shading(vec3 color, out vec3 normal)\n{\n\tnormal.x =  2.0 * ((color.r) - 0.5);\n\tnormal.y =  2.0 * ((color.g) - 0.5);\n\tnormal.z =  2.0 * ((color.b) - 0.5);\n}\n\nvoid color_to_blender_normal_new_shading(vec3 color, out vec3 normal)\n{\n\tnormal.x =  2.0 * ((color.r) - 0.5);\n\tnormal.y = -2.0 * ((color.g) - 0.5);\n\tnormal.z = -2.0 * ((color.b) - 0.5);\n}\n\n#define M_PI 3.14159265358979323846\n#define M_PI_2 1.57079632679489661923\n#define M_2PI 6.28318530717958647\n#define M_PI2 9.86960440108935861\n#define M_1_PI 0.31830988618379069\n#define M_1_PI2 0.10132118364233777\n#define M_2_PI 0.63661977236758134\n#define M_1_2PI 0.15915494309189533\n\n/*********** SHADER NODES ***************/\n\nvoid vcol_attribute(vec4 attvcol, out vec4 vcol)\n{\n\tvcol = vec4(attvcol.x, attvcol.y, attvcol.z, 1.0);\n}\n\nvoid uv_attribute(vec2 attuv, out vec3 uv)\n{\n\tuv = vec3(attuv * 2.0 - vec2(1.0, 1.0), 0.0);\n}\n\nvoid geom(\n        vec3 co, vec3 nor, mat4 viewinvmat, vec3 attorco, vec2 attuv, vec4 attvcol,\n        out vec3 global, out vec3 local, out vec3 view, out vec3 orco, out vec3 uv,\n        out vec3 normal, out vec4 vcol, out float vcol_alpha, out float frontback)\n{\n\tlocal = co;\n\tview = (projection_matrix[3][3] == 0.0) ? normalize(local) : vec3(0.0, 0.0, -1.0);\n\tglobal = (viewinvmat * vec4(local, 1.0)).xyz;\n\torco = attorco;\n\tuv_attribute(attuv, uv);\n\tnormal = -normalize(nor);   /* blender render normal is negated */\n\tvcol_attribute(attvcol, vcol);\n\tsrgb_to_linearrgb(vcol, vcol);\n\tvcol_alpha = attvcol.a;\n\tfrontback = (gl_FrontFacing) ? 1.0 : 0.0;\n}\n\nvoid particle_info(\n        vec4 sprops, vec3 loc, vec3 vel, vec3 avel,\n        out float index, out float age, out float life_time, out vec3 location,\n        out float size, out vec3 velocity, out vec3 angular_velocity)\n{\n\tindex = sprops.x;\n\tage = sprops.y;\n\tlife_time = sprops.z;\n\tsize = sprops.w;\n\n\tlocation = loc;\n\tvelocity = vel;\n\tangular_velocity = avel;\n}\n\nvoid vect_normalize(vec3 vin, out vec3 vout)\n{\n\tvout = normalize(vin);\n}\n\nvoid direction_transform_m4v3(vec3 vin, mat4 mat, out vec3 vout)\n{\n\tvout = (mat * vec4(vin, 0.0)).xyz;\n}\n\nvoid point_transform_m4v3(vec3 vin, mat4 mat, out vec3 vout)\n{\n\tvout = (mat * vec4(vin, 1.0)).xyz;\n}\n\nvoid point_texco_remap_square(vec3 vin, out vec3 vout)\n{\n\tvout = vec3(vin - vec3(0.5, 0.5, 0.5)) * 2.0;\n}\n\nvoid point_map_to_sphere(vec3 vin, out vec3 vout)\n{\n\tfloat len = length(vin);\n\tfloat v, u;\n\tif (len > 0.0) {\n\t\tif (vin.x == 0.0 && vin.y == 0.0)\n\t\t\tu = 0.0;\n\t\telse\n\t\t\tu = (1.0 - atan(vin.x, vin.y) / M_PI) / 2.0;\n\n\t\tv = 1.0 - acos(vin.z / len) / M_PI;\n\t}\n\telse\n\t\tv = u = 0.0;\n\n\tvout = vec3(u, v, 0.0);\n}\n\nvoid point_map_to_tube(vec3 vin, out vec3 vout)\n{\n\tfloat u, v;\n\tv = (vin.z + 1.0) * 0.5;\n\tfloat len = sqrt(vin.x * vin.x + vin.y * vin[1]);\n\tif (len > 0.0)\n\t\tu = (1.0 - (atan(vin.x / len, vin.y / len) / M_PI)) * 0.5;\n\telse\n\t\tv = u = 0.0;\n\n\tvout = vec3(u, v, 0.0);\n}\n\nvoid mapping(vec3 vec, mat4 mat, vec3 minvec, vec3 maxvec, float domin, float domax, out vec3 outvec)\n{\n\toutvec = (mat * vec4(vec, 1.0)).xyz;\n\tif (domin == 1.0)\n\t\toutvec = max(outvec, minvec);\n\tif (domax == 1.0)\n\t\toutvec = min(outvec, maxvec);\n}\n\nvoid camera(vec3 co, out vec3 outview, out float outdepth, out float outdist)\n{\n\toutdepth = abs(co.z);\n\toutdist = length(co);\n\toutview = normalize(co*vec3(1.0,1.0,-1.0));\n}\n\nvoid lamp(\n        vec4 col, float energy, vec3 lv, float dist, vec3 shadow, float visifac,\n        out vec4 outcol, out vec3 outlv, out float outdist, out vec4 outshadow, out float outvisifac)\n{\n\toutcol = col * energy;\n\toutlv = lv;\n\toutdist = dist;\n\toutshadow = vec4(shadow, 1.0);\n\toutvisifac = visifac;\n}\n\nvoid math_add(float val1, float val2, out float outval)\n{\n\toutval = val1 + val2;\n}\n\nvoid math_subtract(float val1, float val2, out float outval)\n{\n\toutval = val1 - val2;\n}\n\nvoid math_multiply(float val1, float val2, out float outval)\n{\n\toutval = val1 * val2;\n}\n\nvoid math_divide(float val1, float val2, out float outval)\n{\n\tif (val2 == 0.0)\n\t\toutval = 0.0;\n\telse\n\t\toutval = val1 / val2;\n}\n\nvoid math_sine(float val, out float outval)\n{\n\toutval = sin(val);\n}\n\nvoid math_cosine(float val, out float outval)\n{\n\toutval = cos(val);\n}\n\nvoid math_tangent(float val, out float outval)\n{\n\toutval = tan(val);\n}\n\nvoid math_asin(float val, out float outval)\n{\n\tif (val <= 1.0 && val >= -1.0)\n\t\toutval = asin(val);\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_acos(float val, out float outval)\n{\n\tif (val <= 1.0 && val >= -1.0)\n\t\toutval = acos(val);\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_atan(float val, out float outval)\n{\n\toutval = atan(val);\n}\n\nvoid math_pow(float val1, float val2, out float outval)\n{\n\tif (val1 >= 0.0) {\n\t\toutval = compatible_pow(val1, val2);\n\t}\n\telse {\n\t\tfloat val2_mod_1 = mod(abs(val2), 1.0);\n\n\t\tif (val2_mod_1 > 0.999 || val2_mod_1 < 0.001)\n\t\t\toutval = compatible_pow(val1, floor(val2 + 0.5));\n\t\telse\n\t\t\toutval = 0.0;\n\t}\n}\n\nvoid math_log(float val1, float val2, out float outval)\n{\n\tif (val1 > 0.0  && val2 > 0.0)\n\t\toutval = log2(val1) / log2(val2);\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_max(float val1, float val2, out float outval)\n{\n\toutval = max(val1, val2);\n}\n\nvoid math_min(float val1, float val2, out float outval)\n{\n\toutval = min(val1, val2);\n}\n\nvoid math_round(float val, out float outval)\n{\n\toutval = floor(val + 0.5);\n}\n\nvoid math_less_than(float val1, float val2, out float outval)\n{\n\tif (val1 < val2)\n\t\toutval = 1.0;\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_greater_than(float val1, float val2, out float outval)\n{\n\tif (val1 > val2)\n\t\toutval = 1.0;\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_modulo(float val1, float val2, out float outval)\n{\n\tif (val2 == 0.0)\n\t\toutval = 0.0;\n\telse\n\t\toutval = mod(val1, val2);\n\n\t/* change sign to match C convention, mod in GLSL will take absolute for negative numbers,\n\t * see https://www.opengl.org/sdk/docs/man/html/mod.xhtml */\n\toutval = (val1 > 0.0) ? outval : -outval;\n}\n\nvoid math_abs(float val1, out float outval)\n{\n\toutval = abs(val1);\n}\n\nvoid squeeze(float val, float width, float center, out float outval)\n{\n\toutval = 1.0 / (1.0 + pow(2.71828183, -((val - center) * width)));\n}\n\nvoid vec_math_add(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 + v2;\n\toutval = (abs(outvec[0]) + abs(outvec[1]) + abs(outvec[2])) / 3.0;\n}\n\nvoid vec_math_sub(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 - v2;\n\toutval = (abs(outvec[0]) + abs(outvec[1]) + abs(outvec[2])) / 3.0;\n}\n\nvoid vec_math_average(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 + v2;\n\toutval = length(outvec);\n\toutvec = normalize(outvec);\n}\nvoid vec_math_mix(float strength, vec3 v1, vec3 v2, out vec3 outvec)\n{\n\toutvec = strength * v1 + (1.0 - strength) * v2;\n}\n\nvoid vec_math_dot(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = vec3(0, 0, 0);\n\toutval = dot(v1, v2);\n}\n\nvoid vec_math_cross(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = cross(v1, v2);\n\toutval = length(outvec);\n\toutvec /= outval;\n}\n\nvoid vec_math_normalize(vec3 v, out vec3 outvec, out float outval)\n{\n\toutval = length(v);\n\toutvec = normalize(v);\n}\n\nvoid vec_math_negate(vec3 v, out vec3 outv)\n{\n\toutv = vec3(0.0)-v;\n}\n\nvoid invert_z(vec3 v, out vec3 outv)\n{\n\tv.z = -v.z;\n\toutv = v;\n}\n\nvoid normal(vec3 dir, vec3 nor, out vec3 outnor, out float outdot)\n{\n\toutnor = nor;\n\toutdot = -dot(dir, nor);\n}\n\nvoid normal_new_shading(vec3 dir, vec3 nor, out vec3 outnor, out float outdot)\n{\n\toutnor = normalize(nor);\n\toutdot = dot(normalize(dir), nor);\n}\n\nvoid curves_vec(float fac, vec3 vec, sampler2D curvemap, out vec3 outvec)\n{\n\toutvec.x = texture2D(curvemap, vec2((vec.x + 1.0) * 0.5, 0.0)).x;\n\toutvec.y = texture2D(curvemap, vec2((vec.y + 1.0) * 0.5, 0.0)).y;\n\toutvec.z = texture2D(curvemap, vec2((vec.z + 1.0) * 0.5, 0.0)).z;\n\n\tif (fac != 1.0)\n\t\toutvec = (outvec * fac) + (vec * (1.0 - fac));\n\n}\n\nvoid curves_rgb(float fac, vec4 col, sampler2D curvemap, out vec4 outcol)\n{\n\toutcol.r = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.r, 0.0)).a, 0.0)).r;\n\toutcol.g = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.g, 0.0)).a, 0.0)).g;\n\toutcol.b = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.b, 0.0)).a, 0.0)).b;\n\n\tif (fac != 1.0)\n\t\toutcol = (outcol * fac) + (col * (1.0 - fac));\n\n\toutcol.a = col.a;\n}\n\nvoid set_value(float val, out float outval)\n{\n\toutval = val;\n}\n\nvoid set_rgb(vec3 col, out vec3 outcol)\n{\n\toutcol = col;\n}\n\nvoid set_rgba(vec4 col, out vec4 outcol)\n{\n\toutcol = col;\n}\n\nvoid set_value_zero(out float outval)\n{\n\toutval = 0.0;\n}\n\nvoid set_value_one(out float outval)\n{\n\toutval = 1.0;\n}\n\nvoid set_rgb_zero(out vec3 outval)\n{\n\toutval = vec3(0.0);\n}\n\nvoid set_rgb_one(out vec3 outval)\n{\n\toutval = vec3(1.0);\n}\n\nvoid set_rgba_zero(out vec4 outval)\n{\n\toutval = vec4(0.0);\n}\n\nvoid set_rgba_one(out vec4 outval)\n{\n\toutval = vec4(1.0);\n}\n\nvoid brightness_contrast(vec4 col, float brightness, float contrast, out vec4 outcol)\n{\n\tfloat a = 1.0 + contrast;\n\tfloat b = brightness - contrast * 0.5;\n\n\toutcol.r = max(a * col.r + b, 0.0);\n\toutcol.g = max(a * col.g + b, 0.0);\n\toutcol.b = max(a * col.b + b, 0.0);\n\toutcol.a = col.a;\n}\n\nvoid mix_blend(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_add(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 + col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_mult(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 * col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_screen(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = vec4(1.0) - (vec4(facm) + fac * (vec4(1.0) - col2)) * (vec4(1.0) - col1);\n\toutcol.a = col1.a;\n}\n\nvoid mix_overlay(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tif (outcol.r < 0.5)\n\t\toutcol.r *= facm + 2.0 * fac * col2.r;\n\telse\n\t\toutcol.r = 1.0 - (facm + 2.0 * fac * (1.0 - col2.r)) * (1.0 - outcol.r);\n\n\tif (outcol.g < 0.5)\n\t\toutcol.g *= facm + 2.0 * fac * col2.g;\n\telse\n\t\toutcol.g = 1.0 - (facm + 2.0 * fac * (1.0 - col2.g)) * (1.0 - outcol.g);\n\n\tif (outcol.b < 0.5)\n\t\toutcol.b *= facm + 2.0 * fac * col2.b;\n\telse\n\t\toutcol.b = 1.0 - (facm + 2.0 * fac * (1.0 - col2.b)) * (1.0 - outcol.b);\n}\n\nvoid mix_sub(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 - col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_div(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tif (col2.r != 0.0) outcol.r = facm * outcol.r + fac * outcol.r / col2.r;\n\tif (col2.g != 0.0) outcol.g = facm * outcol.g + fac * outcol.g / col2.g;\n\tif (col2.b != 0.0) outcol.b = facm * outcol.b + fac * outcol.b / col2.b;\n}\n\nvoid mix_diff(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, abs(col1 - col2), fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_dark(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol.rgb = min(col1.rgb, col2.rgb * fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_light(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol.rgb = max(col1.rgb, col2.rgb * fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_dodge(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = col1;\n\n\tif (outcol.r != 0.0) {\n\t\tfloat tmp = 1.0 - fac * col2.r;\n\t\tif (tmp <= 0.0)\n\t\t\toutcol.r = 1.0;\n\t\telse if ((tmp = outcol.r / tmp) > 1.0)\n\t\t\toutcol.r = 1.0;\n\t\telse\n\t\t\toutcol.r = tmp;\n\t}\n\tif (outcol.g != 0.0) {\n\t\tfloat tmp = 1.0 - fac * col2.g;\n\t\tif (tmp <= 0.0)\n\t\t\toutcol.g = 1.0;\n\t\telse if ((tmp = outcol.g / tmp) > 1.0)\n\t\t\toutcol.g = 1.0;\n\t\telse\n\t\t\toutcol.g = tmp;\n\t}\n\tif (outcol.b != 0.0) {\n\t\tfloat tmp = 1.0 - fac * col2.b;\n\t\tif (tmp <= 0.0)\n\t\t\toutcol.b = 1.0;\n\t\telse if ((tmp = outcol.b / tmp) > 1.0)\n\t\t\toutcol.b = 1.0;\n\t\telse\n\t\t\toutcol.b = tmp;\n\t}\n}\n\nvoid mix_burn(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat tmp, facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\ttmp = facm + fac * col2.r;\n\tif (tmp <= 0.0)\n\t\toutcol.r = 0.0;\n\telse if ((tmp = (1.0 - (1.0 - outcol.r) / tmp)) < 0.0)\n\t\toutcol.r = 0.0;\n\telse if (tmp > 1.0)\n\t\toutcol.r = 1.0;\n\telse\n\t\toutcol.r = tmp;\n\n\ttmp = facm + fac * col2.g;\n\tif (tmp <= 0.0)\n\t\toutcol.g = 0.0;\n\telse if ((tmp = (1.0 - (1.0 - outcol.g) / tmp)) < 0.0)\n\t\toutcol.g = 0.0;\n\telse if (tmp > 1.0)\n\t\toutcol.g = 1.0;\n\telse\n\t\toutcol.g = tmp;\n\n\ttmp = facm + fac * col2.b;\n\tif (tmp <= 0.0)\n\t\toutcol.b = 0.0;\n\telse if ((tmp = (1.0 - (1.0 - outcol.b) / tmp)) < 0.0)\n\t\toutcol.b = 0.0;\n\telse if (tmp > 1.0)\n\t\toutcol.b = 1.0;\n\telse\n\t\toutcol.b = tmp;\n}\n\nvoid mix_hue(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2, tmp;\n\trgb_to_hsv(col2, hsv2);\n\n\tif (hsv2.y != 0.0) {\n\t\trgb_to_hsv(outcol, hsv);\n\t\thsv.x = hsv2.x;\n\t\thsv_to_rgb(hsv, tmp);\n\n\t\toutcol = mix(outcol, tmp, fac);\n\t\toutcol.a = col1.a;\n\t}\n}\n\nvoid mix_sat(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2;\n\trgb_to_hsv(outcol, hsv);\n\n\tif (hsv.y != 0.0) {\n\t\trgb_to_hsv(col2, hsv2);\n\n\t\thsv.y = facm * hsv.y + fac * hsv2.y;\n\t\thsv_to_rgb(hsv, outcol);\n\t}\n}\n\nvoid mix_val(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\tvec4 hsv, hsv2;\n\trgb_to_hsv(col1, hsv);\n\trgb_to_hsv(col2, hsv2);\n\n\thsv.z = facm * hsv.z + fac * hsv2.z;\n\thsv_to_rgb(hsv, outcol);\n}\n\nvoid mix_color(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2, tmp;\n\trgb_to_hsv(col2, hsv2);\n\n\tif (hsv2.y != 0.0) {\n\t\trgb_to_hsv(outcol, hsv);\n\t\thsv.x = hsv2.x;\n\t\thsv.y = hsv2.y;\n\t\thsv_to_rgb(hsv, tmp);\n\n\t\toutcol = mix(outcol, tmp, fac);\n\t\toutcol.a = col1.a;\n\t}\n}\n\nvoid mix_soft(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\tvec4 one = vec4(1.0);\n\tvec4 scr = one - (one - col2) * (one - col1);\n\toutcol = facm * col1 + fac * ((one - col1) * col2 * col1 + col1 * scr);\n}\n\nvoid mix_linear(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\n\toutcol = col1 + fac * (2.0 * (col2 - vec4(0.5)));\n}\n\nvoid valtorgb(float fac, sampler2D colormap, out vec4 outcol, out float outalpha)\n{\n\toutcol = texture2D(colormap, vec2(fac, 0.0));\n\toutalpha = outcol.a;\n}\n\nvoid rgbtobw(vec4 color, out float outval)\n{\n#ifdef USE_NEW_SHADING\n\toutval = color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;\n#else\n\toutval = color.r * 0.35 + color.g * 0.45 + color.b * 0.2; /* keep these factors in sync with texture.h:RGBTOBW */\n#endif\n}\n\nvoid invert(float fac, vec4 col, out vec4 outcol)\n{\n\toutcol.xyz = mix(col.xyz, vec3(1.0, 1.0, 1.0) - col.xyz, fac);\n\toutcol.w = col.w;\n}\n\nvoid clamp_vec3(vec3 vec, vec3 min, vec3 max, out vec3 out_vec)\n{\n\tout_vec = clamp(vec, min, max);\n}\n\nvoid clamp_val(float value, float min, float max, out float out_value)\n{\n\tout_value = clamp(value, min, max);\n}\n\nvoid hue_sat(float hue, float sat, float value, float fac, vec4 col, out vec4 outcol)\n{\n\tvec4 hsv;\n\n\trgb_to_hsv(col, hsv);\n\n\thsv[0] += (hue - 0.5);\n\tif (hsv[0] > 1.0) hsv[0] -= 1.0; else if (hsv[0] < 0.0) hsv[0] += 1.0;\n\thsv[1] *= sat;\n\tif (hsv[1] > 1.0) hsv[1] = 1.0; else if (hsv[1] < 0.0) hsv[1] = 0.0;\n\thsv[2] *= value;\n\tif (hsv[2] > 1.0) hsv[2] = 1.0; else if (hsv[2] < 0.0) hsv[2] = 0.0;\n\n\thsv_to_rgb(hsv, outcol);\n\n\toutcol = mix(col, outcol, fac);\n}\n\nvoid separate_rgb(vec4 col, out float r, out float g, out float b)\n{\n\tr = col.r;\n\tg = col.g;\n\tb = col.b;\n}\n\nvoid combine_rgb(float r, float g, float b, out vec4 col)\n{\n\tcol = vec4(r, g, b, 1.0);\n}\n\nvoid separate_xyz(vec3 vec, out float x, out float y, out float z)\n{\n\tx = vec.r;\n\ty = vec.g;\n\tz = vec.b;\n}\n\nvoid combine_xyz(float x, float y, float z, out vec3 vec)\n{\n\tvec = vec3(x, y, z);\n}\n\nvoid separate_hsv(vec4 col, out float h, out float s, out float v)\n{\n\tvec4 hsv;\n\n\trgb_to_hsv(col, hsv);\n\th = hsv[0];\n\ts = hsv[1];\n\tv = hsv[2];\n}\n\nvoid combine_hsv(float h, float s, float v, out vec4 col)\n{\n\thsv_to_rgb(vec4(h, s, v, 1.0), col);\n}\n\nvoid output_node(vec4 rgb, float alpha, out vec4 outrgb)\n{\n\toutrgb = vec4(rgb.rgb, alpha);\n}\n\n/*********** TEXTURES ***************/\n\nvoid texture_flip_blend(vec3 vec, out vec3 outvec)\n{\n\toutvec = vec.yxz;\n}\n\nvoid texture_blend_lin(vec3 vec, out float outval)\n{\n\toutval = (1.0 + vec.x) / 2.0;\n}\n\nvoid texture_blend_quad(vec3 vec, out float outval)\n{\n\toutval = max((1.0 + vec.x) / 2.0, 0.0);\n\toutval *= outval;\n}\n\nvoid texture_wood_sin(vec3 vec, out float value, out vec4 color, out vec3 normal)\n{\n\tfloat a = sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z) * 20.0;\n\tfloat wi = 0.5 + 0.5 * sin(a);\n\n\tvalue = wi;\n\tcolor = vec4(wi, wi, wi, 1.0);\n\tnormal = vec3(0.0, 0.0, 0.0);\n}\n\nvoid texture_image(vec3 vec, sampler2D ima, out float value, out vec4 color, out vec3 normal)\n{\n\tcolor = texture2D(ima, (vec.xy + vec2(1.0, 1.0)) * 0.5);\n\tvalue = color.a;\n\n\tnormal.x = 2.0 * (color.r - 0.5);\n\tnormal.y = 2.0 * (0.5 - color.g);\n\tnormal.z = 2.0 * (color.b - 0.5);\n}\n\n/************* MTEX *****************/\n\nvoid texco_orco(vec3 attorco, out vec3 orco)\n{\n\torco = attorco;\n}\n\nvoid texco_uv(vec2 attuv, out vec3 uv)\n{\n\t/* disabled for now, works together with leaving out mtex_2d_mapping\n\t   uv = vec3(attuv*2.0 - vec2(1.0, 1.0), 0.0); */\n\tuv = vec3(attuv, 0.0);\n}\n\nvoid texco_norm(vec3 normal, out vec3 outnormal)\n{\n\t/* corresponds to shi->orn, which is negated so cancels\n\t   out blender normal negation */\n\toutnormal = normalize(normal);\n}\n\nvoid texco_tangent(vec4 tangent, out vec3 outtangent)\n{\n\touttangent = normalize(tangent.xyz);\n}\n\nvoid texco_global(mat4 viewinvmat, vec3 co, out vec3 global)\n{\n\tglobal = (viewinvmat * vec4(co, 1.0)).xyz;\n}\n\nvoid texco_object(mat4 viewinvmat, mat4 obinvmat, vec3 co, out vec3 object)\n{\n\tobject = (obinvmat * (viewinvmat * vec4(co, 1.0))).xyz;\n}\n\nvoid texco_refl(vec3 vn, vec3 view, out vec3 ref)\n{\n\tref = view - 2.0 * dot(vn, view) * vn;\n}\n\nvoid shade_norm(vec3 normal, out vec3 outnormal)\n{\n\t/* blender render normal is negated */\n\toutnormal = -normalize(normal);\n}\n\nvoid mtex_mirror(vec3 tcol, vec4 refcol, float tin, float colmirfac, out vec4 outrefcol)\n{\n\toutrefcol = mix(refcol, vec4(1.0, tcol), tin * colmirfac);\n}\n\nvoid mtex_rgb_blend(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tincol = fact * texcol + facm * outcol;\n}\n\nvoid mtex_rgb_mul(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tincol = (facm + fact * texcol) * outcol;\n}\n\nvoid mtex_rgb_screen(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tincol = vec3(1.0) - (vec3(facm) + fact * (vec3(1.0) - texcol)) * (vec3(1.0) - outcol);\n}\n\nvoid mtex_rgb_overlay(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tif (outcol.r < 0.5)\n\t\tincol.r = outcol.r * (facm + 2.0 * fact * texcol.r);\n\telse\n\t\tincol.r = 1.0 - (facm + 2.0 * fact * (1.0 - texcol.r)) * (1.0 - outcol.r);\n\n\tif (outcol.g < 0.5)\n\t\tincol.g = outcol.g * (facm + 2.0 * fact * texcol.g);\n\telse\n\t\tincol.g = 1.0 - (facm + 2.0 * fact * (1.0 - texcol.g)) * (1.0 - outcol.g);\n\n\tif (outcol.b < 0.5)\n\t\tincol.b = outcol.b * (facm + 2.0 * fact * texcol.b);\n\telse\n\t\tincol.b = 1.0 - (facm + 2.0 * fact * (1.0 - texcol.b)) * (1.0 - outcol.b);\n}\n\nvoid mtex_rgb_sub(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tincol = -fact * facg * texcol + outcol;\n}\n\nvoid mtex_rgb_add(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tincol = fact * facg * texcol + outcol;\n}\n\nvoid mtex_rgb_div(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tif (texcol.r != 0.0) incol.r = facm * outcol.r + fact * outcol.r / texcol.r;\n\tif (texcol.g != 0.0) incol.g = facm * outcol.g + fact * outcol.g / texcol.g;\n\tif (texcol.b != 0.0) incol.b = facm * outcol.b + fact * outcol.b / texcol.b;\n}\n\nvoid mtex_rgb_diff(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tincol = facm * outcol + fact * abs(texcol - outcol);\n}\n\nvoid mtex_rgb_dark(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm, col;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tincol.r = min(outcol.r, texcol.r) * fact + outcol.r * facm;\n\tincol.g = min(outcol.g, texcol.g) * fact + outcol.g * facm;\n\tincol.b = min(outcol.b, texcol.b) * fact + outcol.b * facm;\n}\n\nvoid mtex_rgb_light(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm, col;\n\n\tfact *= facg;\n\n\tcol = fact * texcol.r;\n\tif (col > outcol.r) incol.r = col; else incol.r = outcol.r;\n\tcol = fact * texcol.g;\n\tif (col > outcol.g) incol.g = col; else incol.g = outcol.g;\n\tcol = fact * texcol.b;\n\tif (col > outcol.b) incol.b = col; else incol.b = outcol.b;\n}\n\nvoid mtex_rgb_hue(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_hue(fact * facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_sat(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_sat(fact * facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_val(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_val(fact * facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_color(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_color(fact * facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_soft(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0 - fact;\n\n\tvec3 one = vec3(1.0);\n\tvec3 scr = one - (one - texcol) * (one - outcol);\n\tincol = facm * outcol + fact * ((one - texcol) * outcol * texcol + outcol * scr);\n}\n\nvoid mtex_rgb_linear(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfact *= facg;\n\n\tif (texcol.r > 0.5)\n\t\tincol.r = outcol.r + fact * (2.0 * (texcol.r - 0.5));\n\telse\n\t\tincol.r = outcol.r + fact * (2.0 * (texcol.r) - 1.0);\n\n\tif (texcol.g > 0.5)\n\t\tincol.g = outcol.g + fact * (2.0 * (texcol.g - 0.5));\n\telse\n\t\tincol.g = outcol.g + fact * (2.0 * (texcol.g) - 1.0);\n\n\tif (texcol.b > 0.5)\n\t\tincol.b = outcol.b + fact * (2.0 * (texcol.b - 0.5));\n\telse\n\t\tincol.b = outcol.b + fact * (2.0 * (texcol.b) - 1.0);\n}\n\nvoid mtex_value_vars(inout float fact, float facg, out float facm)\n{\n\tfact *= abs(facg);\n\tfacm = 1.0 - fact;\n\n\tif (facg < 0.0) {\n\t\tfloat tmp = fact;\n\t\tfact = facm;\n\t\tfacm = tmp;\n\t}\n}\n\nvoid mtex_value_blend(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = fact * texcol + facm * outcol;\n}\n\nvoid mtex_value_mul(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfacm = 1.0 - facg;\n\tincol = (facm + fact * texcol) * outcol;\n}\n\nvoid mtex_value_screen(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfacm = 1.0 - facg;\n\tincol = 1.0 - (facm + fact * (1.0 - texcol)) * (1.0 - outcol);\n}\n\nvoid mtex_value_sub(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfact = -fact;\n\tincol = fact * texcol + outcol;\n}\n\nvoid mtex_value_add(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfact = fact;\n\tincol = fact * texcol + outcol;\n}\n\nvoid mtex_value_div(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tif (texcol != 0.0)\n\t\tincol = facm * outcol + fact * outcol / texcol;\n\telse\n\t\tincol = 0.0;\n}\n\nvoid mtex_value_diff(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = facm * outcol + fact * abs(texcol - outcol);\n}\n\nvoid mtex_value_dark(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = facm * outcol + fact * min(outcol, texcol);\n}\n\nvoid mtex_value_light(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfloat col = fact * texcol;\n\tif (col > outcol) incol = col; else incol = outcol;\n}\n\nvoid mtex_value_clamp_positive(float fac, out float outfac)\n{\n\toutfac = max(fac, 0.0);\n}\n\nvoid mtex_value_clamp(float fac, out float outfac)\n{\n\toutfac = clamp(fac, 0.0, 1.0);\n}\n\nvoid mtex_har_divide(float har, out float outhar)\n{\n\touthar = har / 128.0;\n}\n\nvoid mtex_har_multiply_clamp(float har, out float outhar)\n{\n\thar *= 128.0;\n\n\tif (har < 1.0) outhar = 1.0;\n\telse if (har > 511.0) outhar = 511.0;\n\telse outhar = har;\n}\n\nvoid mtex_alpha_from_col(vec4 col, out float alpha)\n{\n\talpha = col.a;\n}\n\nvoid mtex_alpha_to_col(vec4 col, float alpha, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, alpha);\n}\n\nvoid mtex_alpha_multiply_value(vec4 col, float value, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, col.a * value);\n}\n\nvoid mtex_rgbtoint(vec4 rgb, out float intensity)\n{\n\tintensity = dot(vec3(0.35, 0.45, 0.2), rgb.rgb);\n}\n\nvoid mtex_value_invert(float invalue, out float outvalue)\n{\n\toutvalue = 1.0 - invalue;\n}\n\nvoid mtex_rgb_invert(vec4 inrgb, out vec4 outrgb)\n{\n\toutrgb = vec4(vec3(1.0) - inrgb.rgb, inrgb.a);\n}\n\nvoid mtex_value_stencil(float stencil, float intensity, out float outstencil, out float outintensity)\n{\n\tfloat fact = intensity;\n\toutintensity = intensity * stencil;\n\toutstencil = stencil * fact;\n}\n\nvoid mtex_rgb_stencil(float stencil, vec4 rgb, out float outstencil, out vec4 outrgb)\n{\n\tfloat fact = rgb.a;\n\toutrgb = vec4(rgb.rgb, rgb.a * stencil);\n\toutstencil = stencil * fact;\n}\n\nvoid mtex_mapping_ofs(vec3 texco, vec3 ofs, out vec3 outtexco)\n{\n\touttexco = texco + ofs;\n}\n\nvoid mtex_mapping_size(vec3 texco, vec3 size, out vec3 outtexco)\n{\n\touttexco = size * texco;\n}\n\nvoid mtex_2d_mapping(vec3 vec, out vec3 outvec)\n{\n\toutvec = vec3(vec.xy * 0.5 + vec2(0.5), vec.z);\n}\n\nvec3 mtex_2d_mapping(vec3 vec)\n{\n\treturn vec3(vec.xy * 0.5 + vec2(0.5), vec.z);\n}\n\nvoid mtex_cube_map(vec3 co, samplerCube ima, out float value, out vec4 color)\n{\n\tcolor = textureCube(ima, co);\n\tvalue = 1.0;\n}\n\nvoid mtex_cube_map_refl(\n        samplerCube ima, vec3 vp, vec3 vn, mat4 viewmatrixinverse, mat4 viewmatrix,\n        out float value, out vec4 color)\n{\n\tvec3 viewdirection = vec3(viewmatrixinverse * vec4(vp, 0.0));\n\tvec3 normaldirection = normalize(vec3(vec4(vn, 0.0) * viewmatrix));\n\tvec3 reflecteddirection = reflect(viewdirection, normaldirection);\n\tcolor = textureCube(ima, reflecteddirection);\n\tvalue = 1.0;\n}\n\nvoid mtex_image(vec3 texco, sampler2D ima, out float value, out vec4 color)\n{\n\tcolor = texture2D(ima, texco.xy);\n\tvalue = 1.0;\n}\n\nvoid mtex_normal(vec3 texco, sampler2D ima, out vec3 normal)\n{\n\t// The invert of the red channel is to make\n\t// the normal map compliant with the outside world.\n\t// It needs to be done because in Blender\n\t// the normal used points inward.\n\t// Should this ever change this negate must be removed.\n\tvec4 color = texture2D(ima, texco.xy);\n\tnormal = 2.0 * (vec3(-color.r, color.g, color.b) - vec3(-0.5, 0.5, 0.5));\n}\n\nvoid mtex_bump_normals_init(vec3 vN, out vec3 vNorg, out vec3 vNacc, out float fPrevMagnitude)\n{\n\tvNorg = vN;\n\tvNacc = vN;\n\tfPrevMagnitude = 1.0;\n}\n\n/** helper method to extract the upper left 3x3 matrix from a 4x4 matrix */\nmat3 to_mat3(mat4 m4)\n{\n\tmat3 m3;\n\tm3[0] = m4[0].xyz;\n\tm3[1] = m4[1].xyz;\n\tm3[2] = m4[2].xyz;\n\treturn m3;\n}\n\nvoid mtex_bump_init_objspace(\n        vec3 surf_pos, vec3 surf_norm,\n        mat4 mView, mat4 mViewInv, mat4 mObj, mat4 mObjInv,\n        float fPrevMagnitude_in, vec3 vNacc_in,\n        out float fPrevMagnitude_out, out vec3 vNacc_out,\n        out vec3 vR1, out vec3 vR2, out float fDet)\n{\n\tmat3 obj2view = to_mat3(mat4(1));\n\tmat3 view2obj = to_mat3(mat4(1));\n\n\tvec3 vSigmaS = view2obj * dFdx(surf_pos);\n\tvec3 vSigmaT = view2obj * dFdy(surf_pos);\n\tvec3 vN = normalize(surf_norm * obj2view);\n\n\tvR1 = cross(vSigmaT, vN);\n\tvR2 = cross(vN, vSigmaS);\n\tfDet = dot(vSigmaS, vR1);\n\n\t/* pretransform vNacc (in mtex_bump_apply) using the inverse transposed */\n\tvR1 = vR1 * view2obj;\n\tvR2 = vR2 * view2obj;\n\tvN = vN * view2obj;\n\n\tfloat fMagnitude = abs(fDet) * length(vN);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_init_texturespace(\n        vec3 surf_pos, vec3 surf_norm,\n        float fPrevMagnitude_in, vec3 vNacc_in,\n        out float fPrevMagnitude_out, out vec3 vNacc_out,\n        out vec3 vR1, out vec3 vR2, out float fDet)\n{\n\tvec3 vSigmaS = dFdx(surf_pos);\n\tvec3 vSigmaT = dFdy(surf_pos);\n\tvec3 vN = surf_norm; /* normalized interpolated vertex normal */\n\n\tvR1 = normalize(cross(vSigmaT, vN));\n\tvR2 = normalize(cross(vN, vSigmaS));\n\tfDet = sign(dot(vSigmaS, vR1));\n\n\tfloat fMagnitude = abs(fDet);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_init_viewspace(\n        vec3 surf_pos, vec3 surf_norm,\n        float fPrevMagnitude_in, vec3 vNacc_in,\n        out float fPrevMagnitude_out, out vec3 vNacc_out,\n        out vec3 vR1, out vec3 vR2, out float fDet)\n{\n\tvec3 vSigmaS = dFdx(surf_pos);\n\tvec3 vSigmaT = dFdy(surf_pos);\n\tvec3 vN = surf_norm; /* normalized interpolated vertex normal */\n\n\tvR1 = cross(vSigmaT, vN);\n\tvR2 = cross(vN, vSigmaS);\n\tfDet = dot(vSigmaS, vR1);\n\n\tfloat fMagnitude = abs(fDet);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_tap3(\n        vec3 texco, sampler2D ima, float hScale,\n        out float dBs, out float dBt)\n{\n\tvec2 STll = texco.xy;\n\tvec2 STlr = texco.xy + dFdx(texco.xy);\n\tvec2 STul = texco.xy + dFdy(texco.xy);\n\n\tfloat Hll, Hlr, Hul;\n\trgbtobw(texture2D(ima, STll), Hll);\n\trgbtobw(texture2D(ima, STlr), Hlr);\n\trgbtobw(texture2D(ima, STul), Hul);\n\n\tdBs = hScale * (Hlr - Hll);\n\tdBt = hScale * (Hul - Hll);\n}\n\n#ifdef BUMP_BICUBIC\n\nvoid mtex_bump_bicubic(\n        vec3 texco, sampler2D ima, float hScale,\n        out float dBs, out float dBt )\n{\n\tfloat Hl;\n\tfloat Hr;\n\tfloat Hd;\n\tfloat Hu;\n\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\tvec2 STl = texco.xy - 0.5 * TexDx;\n\tvec2 STr = texco.xy + 0.5 * TexDx;\n\tvec2 STd = texco.xy - 0.5 * TexDy;\n\tvec2 STu = texco.xy + 0.5 * TexDy;\n\n\trgbtobw(texture2D(ima, STl), Hl);\n\trgbtobw(texture2D(ima, STr), Hr);\n\trgbtobw(texture2D(ima, STd), Hd);\n\trgbtobw(texture2D(ima, STu), Hu);\n\n\tvec2 dHdxy = vec2(Hr - Hl, Hu - Hd);\n\tfloat fBlend = clamp(1.0 - textureQueryLOD(ima, texco.xy).x, 0.0, 1.0);\n\tif (fBlend != 0.0) {\n\t\t// the derivative of the bicubic sampling of level 0\n\t\tivec2 vDim;\n\t\tvDim = textureSize(ima, 0);\n\n\t\t// taking the fract part of the texture coordinate is a hardcoded wrap mode.\n\t\t// this is acceptable as textures use wrap mode exclusively in 3D view elsewhere in blender.\n\t\t// this is done so that we can still get a valid texel with uvs outside the 0,1 range\n\t\t// by texelFetch below, as coordinates are clamped when using this function.\n\t\tvec2 fTexLoc = vDim * fract(texco.xy) - vec2(0.5, 0.5);\n\t\tivec2 iTexLoc = ivec2(floor(fTexLoc));\n\t\tvec2 t = clamp(fTexLoc - iTexLoc, 0.0, 1.0);        // sat just to be pedantic\n\n/*******************************************************************************************\n * This block will replace the one below when one channel textures are properly supported. *\n *******************************************************************************************\n\t\tvec4 vSamplesUL = textureGather(ima, (iTexLoc+ivec2(-1,-1) + vec2(0.5,0.5))/vDim);\n\t\tvec4 vSamplesUR = textureGather(ima, (iTexLoc+ivec2(1,-1) + vec2(0.5,0.5))/vDim);\n\t\tvec4 vSamplesLL = textureGather(ima, (iTexLoc+ivec2(-1,1) + vec2(0.5,0.5))/vDim);\n\t\tvec4 vSamplesLR = textureGather(ima, (iTexLoc+ivec2(1,1) + vec2(0.5,0.5))/vDim);\n\n\t\tmat4 H = mat4(vSamplesUL.w, vSamplesUL.x, vSamplesLL.w, vSamplesLL.x,\n\t\t            vSamplesUL.z, vSamplesUL.y, vSamplesLL.z, vSamplesLL.y,\n\t\t            vSamplesUR.w, vSamplesUR.x, vSamplesLR.w, vSamplesLR.x,\n\t\t            vSamplesUR.z, vSamplesUR.y, vSamplesLR.z, vSamplesLR.y);\n */\n\t\tivec2 iTexLocMod = iTexLoc + ivec2(-1, -1);\n\n\t\tmat4 H;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tivec2 iTexTmp = iTexLocMod + ivec2(i, j);\n\n\t\t\t\t// wrap texture coordinates manually for texelFetch to work on uvs oitside the 0,1 range.\n\t\t\t\t// this is guaranteed to work since we take the fractional part of the uv above.\n\t\t\t\tiTexTmp.x = (iTexTmp.x < 0.0) ? iTexTmp.x + vDim.x : ((iTexTmp.x >= vDim.x) ? iTexTmp.x - vDim.x : iTexTmp.x);\n\t\t\t\tiTexTmp.y = (iTexTmp.y < 0.0) ? iTexTmp.y + vDim.y : ((iTexTmp.y >= vDim.y) ? iTexTmp.y - vDim.y : iTexTmp.y);\n\n\t\t\t\trgbtobw(texelFetch(ima, iTexTmp, 0), H[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tfloat x = t.x, y = t.y;\n\t\tfloat x2 = x * x, x3 = x2 * x, y2 = y * y, y3 = y2 * y;\n\n\t\tvec4 X  = vec4(-0.5 * (x3 + x) + x2,    1.5 * x3 - 2.5 * x2 + 1, -1.5 * x3 + 2.0 * x2 + 0.5 * x, 0.5 * (x3 - x2));\n\t\tvec4 Y  = vec4(-0.5 * (y3 + y) + y2,    1.5 * y3 - 2.5 * y2 + 1, -1.5 * y3 + 2.0 * y2 + 0.5 * y, 0.5 * (y3 - y2));\n\t\tvec4 dX = vec4(-1.5 * x2 + 2.0 * x - 0.5, 4.5 * x2 - 5 * x,        -4.5 * x2 + 4.0 * x + 0.5,      1.5 * x2 - x);\n\t\tvec4 dY = vec4(-1.5 * y2 + 2.0 * y - 0.5, 4.5 * y2 - 5 * y,        -4.5 * y2 + 4.0 * y + 0.5,      1.5 * y2 - y);\n\n\t\t// complete derivative in normalized coordinates (mul by vDim)\n\t\tvec2 dHdST = vDim * vec2(dot(Y, H * dX), dot(dY, H * X));\n\n\t\t// transform derivative to screen-space\n\t\tvec2 dHdxy_bicubic = vec2(dHdST.x * TexDx.x + dHdST.y * TexDx.y,\n\t\t                          dHdST.x * TexDy.x + dHdST.y * TexDy.y);\n\n\t\t// blend between the two\n\t\tdHdxy = dHdxy * (1.0 - fBlend) + dHdxy_bicubic * fBlend;\n\t}\n\n\tdBs = hScale * dHdxy.x;\n\tdBt = hScale * dHdxy.y;\n}\n\n#endif\n\nvoid mtex_bump_tap5(\n        vec3 texco, sampler2D ima, float hScale,\n        out float dBs, out float dBt)\n{\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\tvec2 STc = texco.xy;\n\tvec2 STl = texco.xy - 0.5 * TexDx;\n\tvec2 STr = texco.xy + 0.5 * TexDx;\n\tvec2 STd = texco.xy - 0.5 * TexDy;\n\tvec2 STu = texco.xy + 0.5 * TexDy;\n\n\tfloat Hc, Hl, Hr, Hd, Hu;\n\trgbtobw(texture2D(ima, STc), Hc);\n\trgbtobw(texture2D(ima, STl), Hl);\n\trgbtobw(texture2D(ima, STr), Hr);\n\trgbtobw(texture2D(ima, STd), Hd);\n\trgbtobw(texture2D(ima, STu), Hu);\n\n\tdBs = hScale * (Hr - Hl);\n\tdBt = hScale * (Hu - Hd);\n}\n\nvoid mtex_bump_deriv(\n        vec3 texco, sampler2D ima, float ima_x, float ima_y, float hScale,\n        out float dBs, out float dBt)\n{\n\tfloat s = 1.0;      // negate this if flipped texture coordinate\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\t// this variant using a derivative map is described here\n\t// http://mmikkelsen3d.blogspot.com/2011/07/derivative-maps.html\n\tvec2 dim = vec2(ima_x, ima_y);\n\tvec2 dBduv = hScale * dim * (2.0 * texture2D(ima, texco.xy).xy - 1.0);\n\n\tdBs = dBduv.x * TexDx.x + s * dBduv.y * TexDx.y;\n\tdBt = dBduv.x * TexDy.x + s * dBduv.y * TexDy.y;\n}\n\nvoid mtex_bump_apply(\n        float fDet, float dBs, float dBt, vec3 vR1, vec3 vR2, vec3 vNacc_in,\n        out vec3 vNacc_out, out vec3 perturbed_norm)\n{\n\tvec3 vSurfGrad = sign(fDet) * (dBs * vR1 + dBt * vR2);\n\n\tvNacc_out = vNacc_in - vSurfGrad;\n\tperturbed_norm = normalize(vNacc_out);\n}\n\nvoid mtex_bump_apply_texspace(\n        float fDet, float dBs, float dBt, vec3 vR1, vec3 vR2,\n        sampler2D ima, vec3 texco, float ima_x, float ima_y, vec3 vNacc_in,\n        out vec3 vNacc_out, out vec3 perturbed_norm)\n{\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\tvec3 vSurfGrad = sign(fDet) * (\n\t        dBs / length(vec2(ima_x * TexDx.x, ima_y * TexDx.y)) * vR1 +\n\t        dBt / length(vec2(ima_x * TexDy.x, ima_y * TexDy.y)) * vR2);\n\n\tvNacc_out = vNacc_in - vSurfGrad;\n\tperturbed_norm = normalize(vNacc_out);\n}\n\nvoid mtex_negate_texnormal(vec3 normal, out vec3 outnormal)\n{\n\toutnormal = vec3(-normal.x, -normal.y, normal.z);\n}\n\nvoid mtex_nspace_tangent(vec4 tangent, vec3 normal, vec3 texnormal, out vec3 outnormal)\n{\n\tvec3 B = tangent.w * cross(normal, tangent.xyz);\n\n\toutnormal = texnormal.x * tangent.xyz + texnormal.y * B + texnormal.z * normal;\n\toutnormal = normalize(outnormal);\n}\n\nvoid mtex_nspace_world(mat4 viewmat, vec3 texnormal, out vec3 outnormal)\n{\n\toutnormal = normalize((viewmat * vec4(texnormal, 0.0)).xyz);\n}\n\nvoid mtex_nspace_object(vec3 texnormal, out vec3 outnormal)\n{\n\toutnormal = normalize(mat3(1) * texnormal);\n}\n\nvoid mtex_blend_normal(float norfac, vec3 normal, vec3 newnormal, out vec3 outnormal)\n{\n\toutnormal = (1.0 - norfac) * normal + norfac * newnormal;\n\toutnormal = normalize(outnormal);\n}\n\n/******* MATERIAL *********/\n\nvoid lamp_visibility_sun_hemi(vec3 lampvec, out vec3 lv, out float dist, out float visifac)\n{\n\tlv = lampvec;\n\tdist = 1.0;\n\tvisifac = 1.0;\n}\n\nvoid lamp_visibility_other(vec3 co, vec3 lampco, out vec3 lv, out float dist, out float visifac)\n{\n\tlv = co - lampco;\n\tdist = length(lv);\n\tlv = normalize(lv);\n\tvisifac = 1.0;\n}\n\nvoid lamp_falloff_invlinear(float lampdist, float dist, out float visifac)\n{\n\tvisifac = lampdist / (lampdist + dist);\n}\n\nvoid lamp_falloff_invsquare(float lampdist, float dist, out float visifac)\n{\n\tvisifac = lampdist / (lampdist + dist * dist);\n}\n\nvoid lamp_falloff_sliders(float lampdist, float ld1, float ld2, float dist, out float visifac)\n{\n\tfloat lampdistkw = lampdist * lampdist;\n\n\tvisifac = lampdist / (lampdist + ld1 * dist);\n\tvisifac *= lampdistkw / (lampdistkw + ld2 * dist * dist);\n}\n\nvoid lamp_falloff_invcoefficients(float coeff_const, float coeff_lin, float coeff_quad, float dist, out float visifac)\n{\n\tvec3 coeff = vec3(coeff_const, coeff_lin, coeff_quad);\n\tvec3 d_coeff = vec3(1.0, dist, dist * dist);\n\tfloat visifac_r = dot(coeff, d_coeff);\n\tif (visifac_r > 0.0)\n\t\tvisifac = 1.0 / visifac_r;\n\telse\n\t\tvisifac = 0.0;\n}\n\nvoid lamp_falloff_curve(float lampdist, sampler2D curvemap, float dist, out float visifac)\n{\n\tvisifac = texture2D(curvemap, vec2(dist / lampdist, 0.0)).x;\n}\n\nvoid lamp_visibility_sphere(float lampdist, float dist, float visifac, out float outvisifac)\n{\n\tfloat t = lampdist - dist;\n\n\toutvisifac = visifac * max(t, 0.0) / lampdist;\n}\n\nvoid lamp_visibility_spot_square(vec3 lampvec, mat4 lampimat, vec2 scale, vec3 lv, out float inpr)\n{\n\tif (dot(lv, lampvec) > 0.0) {\n\t\tvec3 lvrot = (lampimat * vec4(lv, 0.0)).xyz;\n\t\t/* without clever non-uniform scale, we could do: */\n\t\t// float x = max(abs(lvrot.x / lvrot.z), abs(lvrot.y / lvrot.z));\n\t\tfloat x = max(abs((lvrot.x / scale.x) / lvrot.z), abs((lvrot.y / scale.y) / lvrot.z));\n\n\t\tinpr = 1.0 / sqrt(1.0 + x * x);\n\t}\n\telse\n\t\tinpr = 0.0;\n}\n\nvoid lamp_visibility_spot_circle(vec3 lampvec, mat4 lampimat, vec2 scale, vec3 lv, out float inpr)\n{\n\t/* without clever non-uniform scale, we could do: */\n\t// inpr = dot(lv, lampvec);\n\tif (dot(lv, lampvec) > 0.0) {\n\t\tvec3 lvrot = (lampimat * vec4(lv, 0.0)).xyz;\n\t\tfloat x = abs(lvrot.x / lvrot.z);\n\t\tfloat y = abs(lvrot.y / lvrot.z);\n\n\t\tfloat ellipse = abs((x * x) / (scale.x * scale.x) + (y * y) / (scale.y * scale.y));\n\n\t\tinpr = 1.0 / sqrt(1.0 + ellipse);\n\t}\n\telse\n\t\tinpr = 0.0;\n}\n\nvoid lamp_visibility_spot(float spotsi, float spotbl, float inpr, float visifac, out float outvisifac)\n{\n\tfloat t = spotsi;\n\n\tif (inpr <= t) {\n\t\toutvisifac = 0.0;\n\t}\n\telse {\n\t\tt = inpr - t;\n\n\t\t/* soft area */\n\t\tif (spotbl != 0.0)\n\t\t\tinpr *= smoothstep(0.0, 1.0, t / spotbl);\n\n\t\toutvisifac = visifac * inpr;\n\t}\n}\n\nvoid lamp_visibility_clamp(float visifac, out float outvisifac)\n{\n\toutvisifac = (visifac < 0.001) ? 0.0 : visifac;\n}\n\nvoid world_paper_view(vec3 vec, out vec3 outvec)\n{\n\tvec3 nvec = normalize(vec);\n\toutvec = (projection_matrix[3][3] == 0.0) ? vec3(nvec.x, 0.0, nvec.y) : vec3(0.0, 0.0, -1.0);\n}\n\nvoid world_zen_mapping(vec3 view, float zenup, float zendown, out float zenfac)\n{\n\tif (view.z >= 0.0)\n\t\tzenfac = zenup;\n\telse\n\t\tzenfac = zendown;\n}\n\nvoid world_blend_paper_real(vec3 vec, out float blend)\n{\n\tblend = abs(vec.y);\n}\n\nvoid world_blend_paper(vec3 vec, out float blend)\n{\n\tblend = (vec.y + 1.0) * 0.5;\n}\n\nvoid world_blend_real(vec3 vec, out float blend)\n{\n\tblend = abs(normalize(vec).z);\n}\n\nvoid world_blend(vec3 vec, out float blend)\n{\n\tblend = (normalize(vec).z + 1.0) * 0.5;\n}\n\nvoid shade_view(vec3 co, out vec3 view)\n{\n\t/* handle perspective/orthographic */\n\tview = (projection_matrix[3][3] == 0.0) ? normalize(co) : vec3(0.0, 0.0, -1.0);\n}\n\nvoid shade_tangent_v(vec3 lv, vec3 tang, out vec3 vn)\n{\n\tvec3 c = cross(lv, tang);\n\tvec3 vnor = cross(c, tang);\n\n\tvn = -normalize(vnor);\n}\n\nvoid shade_inp(vec3 vn, vec3 lv, out float inp)\n{\n\tinp = dot(vn, lv);\n}\n\nvoid shade_is_no_diffuse(out float is)\n{\n\tis = 0.0;\n}\n\nvoid shade_is_hemi(float inp, out float is)\n{\n\tis = 0.5 * inp + 0.5;\n}\n\nfloat area_lamp_energy(mat4 area, vec3 co, vec3 vn)\n{\n\tvec3 vec[4], c[4];\n\tfloat rad[4];float fac;\n\n\tvec[0] = normalize(co - area[0].xyz);\n\tvec[1] = normalize(co - area[1].xyz);\n\tvec[2] = normalize(co - area[2].xyz);\n\tvec[3] = normalize(co - area[3].xyz);\n\n\tc[0] = normalize(cross(vec[0], vec[1]));\n\tc[1] = normalize(cross(vec[1], vec[2]));\n\tc[2] = normalize(cross(vec[2], vec[3]));\n\tc[3] = normalize(cross(vec[3], vec[0]));\n\n\trad[0] = acos(dot(vec[0], vec[1]));\n\trad[1] = acos(dot(vec[1], vec[2]));\n\trad[2] = acos(dot(vec[2], vec[3]));\n\trad[3] = acos(dot(vec[3], vec[0]));\n\n\tfac =  rad[0] * dot(vn, c[0]);\n\tfac += rad[1] * dot(vn, c[1]);\n\tfac += rad[2] * dot(vn, c[2]);\n\tfac += rad[3] * dot(vn, c[3]);\n\n\treturn max(fac, 0.0);\n}\n\nvoid shade_inp_area(\n        vec3 position, vec3 lampco, vec3 lampvec, vec3 vn, mat4 area, float areasize, float k,\n        out float inp)\n{\n\tvec3 co = position;\n\tvec3 vec = co - lampco;\n\n\tif (dot(vec, lampvec) < 0.0) {\n\t\tinp = 0.0;\n\t}\n\telse {\n\t\tfloat intens = area_lamp_energy(area, co, vn);\n\n\t\tinp = pow(intens * areasize, k);\n\t}\n}\n\nvoid shade_diffuse_oren_nayer(float nl, vec3 n, vec3 l, vec3 v, float rough, out float is)\n{\n\tvec3 h = normalize(v + l);\n\tfloat nh = max(dot(n, h), 0.0);\n\tfloat nv = max(dot(n, v), 0.0);\n\tfloat realnl = dot(n, l);\n\n\tif (realnl < 0.0) {\n\t\tis = 0.0;\n\t}\n\telse if (nl < 0.0) {\n\t\tis = 0.0;\n\t}\n\telse {\n\t\tfloat vh = max(dot(v, h), 0.0);\n\t\tfloat Lit_A = acos(realnl);\n\t\tfloat View_A = acos(nv);\n\n\t\tvec3 Lit_B = normalize(l - realnl * n);\n\t\tvec3 View_B = normalize(v - nv * n);\n\n\t\tfloat t = max(dot(Lit_B, View_B), 0.0);\n\n\t\tfloat a, b;\n\n\t\tif (Lit_A > View_A) {\n\t\t\ta = Lit_A;\n\t\t\tb = View_A;\n\t\t}\n\t\telse {\n\t\t\ta = View_A;\n\t\t\tb = Lit_A;\n\t\t}\n\n\t\tfloat A = 1.0 - (0.5 * ((rough * rough) / ((rough * rough) + 0.33)));\n\t\tfloat B = 0.45 * ((rough * rough) / ((rough * rough) + 0.09));\n\n\t\tb *= 0.95;\n\t\tis = nl * (A + (B * t * sin(a) * tan(b)));\n\t}\n}\n\nvoid shade_diffuse_toon(vec3 n, vec3 l, vec3 v, float size, float tsmooth, out float is)\n{\n\tfloat rslt = dot(n, l);\n\tfloat ang = acos(rslt);\n\n\tif (ang < size) is = 1.0;\n\telse if (ang > (size + tsmooth) || tsmooth == 0.0) is = 0.0;\n\telse is = 1.0 - ((ang - size) / tsmooth);\n}\n\nvoid shade_diffuse_minnaert(float nl, vec3 n, vec3 v, float darkness, out float is)\n{\n\tif (nl <= 0.0) {\n\t\tis = 0.0;\n\t}\n\telse {\n\t\tfloat nv = max(dot(n, v), 0.0);\n\n\t\tif (darkness <= 1.0)\n\t\t\tis = nl * pow(max(nv * nl, 0.1), darkness - 1.0);\n\t\telse\n\t\t\tis = nl * pow(1.0001 - nv, darkness - 1.0);\n\t}\n}\n\nfloat fresnel_fac(vec3 view, vec3 vn, float grad, float fac)\n{\n\tfloat t1, t2;\n\tfloat ffac;\n\n\tif (fac == 0.0) {\n\t\tffac = 1.0;\n\t}\n\telse {\n\t\tt1 = dot(view, vn);\n\t\tif (t1 > 0.0) t2 = 1.0 + t1;\n\t\telse t2 = 1.0 - t1;\n\n\t\tt2 = grad + (1.0 - grad) * pow(t2, fac);\n\n\t\tif (t2 < 0.0) ffac = 0.0;\n\t\telse if (t2 > 1.0) ffac = 1.0;\n\t\telse ffac = t2;\n\t}\n\n\treturn ffac;\n}\n\nvoid shade_diffuse_fresnel(vec3 vn, vec3 lv, vec3 view, float fac_i, float fac, out float is)\n{\n\tis = fresnel_fac(lv, vn, fac_i, fac);\n}\n\nvoid shade_cubic(float is, out float outis)\n{\n\tif (is > 0.0 && is < 1.0)\n\t\toutis = smoothstep(0.0, 1.0, is);\n\telse\n\t\toutis = is;\n}\n\nvoid shade_visifac(float i, float visifac, float refl, out float outi)\n{\n\t/*if (i > 0.0)*/\n\touti = max(i * visifac * refl, 0.0);\n\t/*else\n\t    outi = i;*/\n}\n\nvoid shade_tangent_v_spec(vec3 tang, out vec3 vn)\n{\n\tvn = tang;\n}\n\nvoid shade_add_to_diffuse(float i, vec3 lampcol, vec3 col, out vec3 outcol)\n{\n\tif (i > 0.0)\n\t\toutcol = i * lampcol * col;\n\telse\n\t\toutcol = vec3(0.0, 0.0, 0.0);\n}\n\nvoid shade_hemi_spec(vec3 vn, vec3 lv, vec3 view, float spec, float hard, float visifac, out float t)\n{\n\tlv += view;\n\tlv = normalize(lv);\n\n\tt = dot(vn, lv);\n\tt = 0.5 * t + 0.5;\n\n\tt = visifac * spec * pow(t, hard);\n}\n\nvoid shade_phong_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat rslt = max(dot(h, n), 0.0);\n\n\tspecfac = pow(rslt, hard);\n}\n\nvoid shade_cooktorr_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)\n{\n\tvec3 h = normalize(v + l);\n\tfloat nh = dot(n, h);\n\n\tif (nh < 0.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse {\n\t\tfloat nv = max(dot(n, v), 0.0);\n\t\tfloat i = pow(nh, hard);\n\n\t\ti = i / (0.1 + nv);\n\t\tspecfac = i;\n\t}\n}\n\nvoid shade_blinn_spec(vec3 n, vec3 l, vec3 v, float refrac, float spec_power, out float specfac)\n{\n\tif (refrac < 1.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse if (spec_power == 0.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse {\n\t\tif (spec_power < 100.0)\n\t\t\tspec_power = sqrt(1.0 / spec_power);\n\t\telse\n\t\t\tspec_power = 10.0 / spec_power;\n\n\t\tvec3 h = normalize(v + l);\n\t\tfloat nh = dot(n, h);\n\t\tif (nh < 0.0) {\n\t\t\tspecfac = 0.0;\n\t\t}\n\t\telse {\n\t\t\tfloat nv = max(dot(n, v), 0.01);\n\t\t\tfloat nl = dot(n, l);\n\t\t\tif (nl <= 0.01) {\n\t\t\t\tspecfac = 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfloat vh = max(dot(v, h), 0.01);\n\n\t\t\t\tfloat a = 1.0;\n\t\t\t\tfloat b = (2.0 * nh * nv) / vh;\n\t\t\t\tfloat c = (2.0 * nh * nl) / vh;\n\n\t\t\t\tfloat g = 0.0;\n\n\t\t\t\tif (a < b && a < c) g = a;\n\t\t\t\telse if (b < a && b < c) g = b;\n\t\t\t\telse if (c < a && c < b) g = c;\n\n\t\t\t\tfloat p = sqrt(((refrac * refrac) + (vh * vh) - 1.0));\n\t\t\t\tfloat f = ((((p - vh) * (p - vh)) / ((p + vh) * (p + vh))) *\n\t\t\t\t           (1.0 + ((((vh * (p + vh)) - 1.0) * ((vh * (p + vh)) - 1.0)) /\n\t\t\t\t                   (((vh * (p - vh)) + 1.0) * ((vh * (p - vh)) + 1.0)))));\n\t\t\t\tfloat ang = acos(nh);\n\n\t\t\t\tspecfac = max(f * g * exp_blender((-(ang * ang) / (2.0 * spec_power * spec_power))), 0.0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid shade_wardiso_spec(vec3 n, vec3 l, vec3 v, float rms, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat nh = max(dot(n, h), 0.001);\n\tfloat nv = max(dot(n, v), 0.001);\n\tfloat nl = max(dot(n, l), 0.001);\n\tfloat angle = tan(acos(nh));\n\tfloat alpha = max(rms, 0.001);\n\n\tspecfac = nl * (1.0 / (4.0 * M_PI * alpha * alpha)) * (exp_blender(-(angle * angle) / (alpha * alpha)) / (sqrt(nv * nl)));\n}\n\nvoid shade_toon_spec(vec3 n, vec3 l, vec3 v, float size, float tsmooth, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat rslt = dot(h, n);\n\tfloat ang = acos(rslt);\n\n\tif (ang < size) rslt = 1.0;\n\telse if (ang >= (size + tsmooth) || tsmooth == 0.0) rslt = 0.0;\n\telse rslt = 1.0 - ((ang - size) / tsmooth);\n\n\tspecfac = rslt;\n}\n\nvoid shade_spec_area_inp(float specfac, float inp, out float outspecfac)\n{\n\toutspecfac = specfac * inp;\n}\n\nvoid shade_spec_t(float shadfac, float spec, float visifac, float specfac, out float t)\n{\n\tt = shadfac * spec * visifac * specfac;\n}\n\nvoid shade_add_spec(float t, vec3 lampcol, vec3 speccol, out vec3 outcol)\n{\n\toutcol = t * lampcol * speccol;\n}\n\nvoid shade_add_mirror(vec3 mir, vec4 refcol, vec3 combined, out vec3 result)\n{\n\tresult = mir * refcol.gba + (vec3(1.0) - mir * refcol.rrr) * combined;\n}\n\nvoid alpha_spec_correction(vec3 spec, float spectra, float alpha, out float outalpha)\n{\n\tif (spectra > 0.0) {\n\t\tfloat t = clamp(max(max(spec.r, spec.g), spec.b) * spectra, 0.0, 1.0);\n\t\toutalpha = (1.0 - t) * alpha + t;\n\t}\n\telse {\n\t\toutalpha = alpha;\n\t}\n}\n\nvoid shade_add(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1 + col2;\n}\n\nvoid shade_madd(vec4 col, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col + col1 * col2;\n}\n\nvoid shade_add_clamped(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1 + max(col2, vec4(0.0, 0.0, 0.0, 0.0));\n}\n\nvoid shade_madd_clamped(vec4 col, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col + max(col1 * col2, vec4(0.0, 0.0, 0.0, 0.0));\n}\n\nvoid shade_maddf(vec4 col, float f, vec4 col1, out vec4 outcol)\n{\n\toutcol = col + f * col1;\n}\n\nvoid shade_mul(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1 * col2;\n}\n\nvoid shade_mul_value(float fac, vec4 col, out vec4 outcol)\n{\n\toutcol = col * fac;\n}\n\nvoid shade_mul_value_v3(float fac, vec3 col, out vec3 outcol)\n{\n\toutcol = col * fac;\n}\n\nvoid shade_obcolor(vec4 col, vec4 obcol, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb * obcol.rgb, col.a);\n}\n\nvoid ramp_rgbtobw(vec3 color, out float outval)\n{\n\toutval = color.r * 0.3 + color.g * 0.58 + color.b * 0.12;\n}\n\nvoid shade_only_shadow(float i, float shadfac, float energy, vec3 shadcol, out vec3 outshadrgb)\n{\n\toutshadrgb = i * energy * (1.0 - shadfac) * (vec3(1.0) - shadcol);\n}\n\nvoid shade_only_shadow_diffuse(vec3 shadrgb, vec3 rgb, vec4 diff, out vec4 outdiff)\n{\n\toutdiff = diff - vec4(rgb * shadrgb, 0.0);\n}\n\nvoid shade_only_shadow_specular(vec3 shadrgb, vec3 specrgb, vec4 spec, out vec4 outspec)\n{\n\toutspec = spec - vec4(specrgb * shadrgb, 0.0);\n}\n\nvoid shade_clamp_positive(vec4 col, out vec4 outcol)\n{\n\toutcol = max(col, vec4(0.0));\n}\n\nvoid test_shadowbuf(\n        vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float inp,\n        out float result)\n{\n\tif (inp <= 0.0) {\n\t\tresult = 0.0;\n\t}\n\telse {\n\t\tvec4 co = shadowpersmat * vec4(rco, 1.0);\n\n\t\t//float bias = (1.5 - inp*inp)*shadowbias;\n\t\tco.z -= shadowbias * co.w;\n\n\t\tif (co.w > 0.0 && co.x > 0.0 && co.x / co.w < 1.0 && co.y > 0.0 && co.y / co.w < 1.0)\n\t\t\tresult = step(co.z,texture2D(shadowmap, co.xy).x);\n\t\telse\n\t\t\tresult = 1.0;\n\t}\n}\n\nvoid test_shadowbuf_vsm(\n        vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float bleedbias, float inp,\n        out float result)\n{\n\tif (inp <= 0.0) {\n\t\tresult = 0.0;\n\t}\n\telse {\n\t\tvec4 co = shadowpersmat * vec4(rco, 1.0);\n\t\tif (co.w > 0.0 && co.x > 0.0 && co.x / co.w < 1.0 && co.y > 0.0 && co.y / co.w < 1.0) {\n\t\t\tvec2 moments = texture2DProj(shadowmap, co).rg;\n\t\t\tfloat dist = co.z / co.w;\n\t\t\tfloat p = 0.0;\n\n\t\t\tif (dist <= moments.x)\n\t\t\t\tp = 1.0;\n\n\t\t\tfloat variance = moments.y - (moments.x * moments.x);\n\t\t\tvariance = max(variance, shadowbias / 10.0);\n\n\t\t\tfloat d = moments.x - dist;\n\t\t\tfloat p_max = variance / (variance + d * d);\n\n\t\t\t// Now reduce light-bleeding by removing the [0, x] tail and linearly rescaling (x, 1]\n\t\t\tp_max = clamp((p_max - bleedbias) / (1.0 - bleedbias), 0.0, 1.0);\n\n\t\t\tresult = max(p, p_max);\n\t\t}\n\t\telse {\n\t\t\tresult = 1.0;\n\t\t}\n\t}\n}\n\nvoid shadows_only(\n        vec3 rco, sampler2D shadowmap, mat4 shadowpersmat,\n        float shadowbias, vec3 shadowcolor, float inp,\n        out vec3 result)\n{\n\tresult = vec3(1.0);\n\n\tif (inp > 0.0) {\n\t\tfloat shadfac;\n\n\t\ttest_shadowbuf(rco, shadowmap, shadowpersmat, shadowbias, inp, shadfac);\n\t\tresult -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);\n\t}\n}\n\nvoid shadows_only_vsm(\n        vec3 rco, sampler2D shadowmap, mat4 shadowpersmat,\n        float shadowbias, float bleedbias, vec3 shadowcolor, float inp,\n        out vec3 result)\n{\n\tresult = vec3(1.0);\n\n\tif (inp > 0.0) {\n\t\tfloat shadfac;\n\n\t\ttest_shadowbuf_vsm(rco, shadowmap, shadowpersmat, shadowbias, bleedbias, inp, shadfac);\n\t\tresult -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);\n\t}\n}\n\nvoid shade_light_texture(vec3 rco, sampler2D cookie, mat4 shadowpersmat, out vec4 result)\n{\n\n\tvec4 co = shadowpersmat * vec4(rco, 1.0);\n\n\tresult = texture2DProj(cookie, co);\n}\n\nvoid shade_exposure_correct(vec3 col, float linfac, float logfac, out vec3 outcol)\n{\n\toutcol = linfac * (1.0 - exp(col * logfac));\n}\n\nvoid shade_mist_factor(\n        vec3 co, float enable, float miststa, float mistdist, float misttype, float misi,\n        out float outfac)\n{\n\tif (enable == 1.0) {\n\t\tfloat fac, zcor;\n\n\t\tzcor = (projection_matrix[3][3] == 0.0) ? length(co) : -co[2];\n\n\t\tfac = clamp((zcor - miststa) / mistdist, 0.0, 1.0);\n\t\tif (misttype == 0.0) fac *= fac;\n\t\telse if (misttype == 1.0) ;\n\t\telse fac = sqrt(fac);\n\n\t\toutfac = 1.0 - (1.0 - fac) * (1.0 - misi);\n\t}\n\telse {\n\t\toutfac = 0.0;\n\t}\n}\n\nvoid shade_world_mix(vec3 hor, vec4 col, out vec4 outcol)\n{\n\tfloat fac = clamp(col.a, 0.0, 1.0);\n\toutcol = vec4(mix(hor, col.rgb, fac), col.a);\n}\n\nvoid shade_alpha_opaque(vec4 col, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, 1.0);\n}\n\nvoid shade_alpha_obcolor(vec4 col, vec4 obcol, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, col.a * obcol.a);\n}\n\n/* ********************** matcap style render ******************** */\n\nvoid material_preview_matcap(vec4 color, sampler2D ima, vec4 N, vec4 mask, out vec4 result)\n{\n\tvec3 normal;\n\tvec2 tex;\n\t\n#ifndef USE_OPENSUBDIV\n\t/* remap to 0.0 - 1.0 range. This is done because OpenGL 2.0 clamps colors\n\t * between shader stages and we want the full range of the normal */\n\tnormal = vec3(2.0, 2.0, 2.0) * vec3(N.x, N.y, N.z) - vec3(1.0, 1.0, 1.0);\n\tif (normal.z < 0.0) {\n\t\tnormal.z = 0.0;\n\t}\n\tnormal = normalize(normal);\n#else\n\tnormal = inpt.v.normal;\n\tmask = vec4(1.0, 1.0, 1.0, 1.0);\n#endif\n\n\ttex.x = 0.5 + 0.49 * normal.x;\n\ttex.y = 0.5 + 0.49 * normal.y;\n\tresult = texture2D(ima, tex) * mask;\n}\n/* ------- Defines -------- */\n\n/* Number of default opengl lights */\n#define NUM_LIGHTS 3\n\n/* SSR Maximum iterations */\n#define MAX_SSR_REFINE_STEPS 8\n\n/* Importance sampling Max iterations */\n#define BSDF_SAMPLES 1024.0\n\n/* Linearly Transformed Cosines  */\n#define LTC_LUT_SIZE 64.0\n\n/* needed for uint type and bitwise operation */\n\n\n/* ------- PBR Uniform --------- */\n\nuniform samplerCube unfprobe;\nuniform sampler2D unfreflect;\nuniform sampler2D unfrefract;\nuniform sampler2D unfltcmat;\nuniform sampler2D unfltcmag;\nuniform sampler2D unfscenebuf;\nuniform sampler2D unfdepthbuf;\nuniform sampler2D unfbackfacebuf;\nuniform sampler2D unfjitter;\nuniform sampler2D unflutsamples;\nuniform float unflodfactor;\n\nuniform vec3 unfsh0;\nuniform vec3 unfsh1;\nuniform vec3 unfsh2;\nuniform vec3 unfsh3;\nuniform vec3 unfsh4;\nuniform vec3 unfsh5;\nuniform vec3 unfsh6;\nuniform vec3 unfsh7;\nuniform vec3 unfsh8;\nuniform vec3 unfprobepos;\nuniform vec3 unfplanarvec;\nuniform vec3 unfssrparam;\nuniform vec4 unfssaoparam;\nuniform vec4 unfclip;\nuniform mat4 unfprobecorrectionmat;\nuniform mat4 unfplanarreflectmat;\nuniform mat4 unfpixelprojmat;\n\n/* ------- Global Variables -------- */\n\nvec3 worldpos, refpos;\nvec3 viewnor, viewi;\nvec3 planarfac, planarvec;\nvec3 I, B, Ht;\nvec2 jitternoise = vec2(0.0);\n\n/* ------- Convenience functions --------- */\n\nvec3 mul(mat3 m, vec3 v) { return m * v; }\nmat3 mul(mat3 m1, mat3 m2) { return m1 * m2; }\n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat distance_squared(vec2 a, vec2 b) { a -= b; return dot(a, a); }\nfloat distance_squared(vec3 a, vec3 b) { a -= b; return dot(a, a); }\n\nfloat hypot(float x, float y) { return sqrt(x*x + y*y); }\n\nfloat inverse_distance(vec3 V) { return max( 1.0 / length(V), 1e-8); }\n\nvec4 bufferFetch(sampler2D buffer, ivec2 texelpos, int lod)\n{\n#if __VERSION__ < 130\n\treturn texture2DLodEXT(buffer, (vec2(texelpos) + 0.5) / (unfclip.zw / pow(2.0, float(lod))), float(lod));\n#else\n\treturn texelFetch(buffer, texelpos, lod);\n#endif\n}\n\n/* --------- Noise Utils Functions --------- */\n\nvoid generated_from_orco(vec3 orco, out vec3 generated)\n{\n\tgenerated = orco * 0.5 + vec3(0.5);\n}\n\nint floor_to_int(float x)\n{\n\treturn int(floor(x));\n}\n\nint quick_floor(float x)\n{\n\treturn int(x) - ((x < 0.0) ? 1 : 0);\n}\n\n#ifdef BIT_OPERATIONS\n#endif\n\nfloat floorfrac(float x, out int i)\n{\n\ti = floor_to_int(x);\n\treturn x - float(i);\n}\n\n/* --------- Geometric Utils Functions --------- */\n\nfloat linear_depth(float z)\n{\n\tif (projection_matrix[3][3] == 0.0) {\n\t\tfloat zn = unfclip.x; // camera z near\n\t\tfloat zf = unfclip.y; // camera z far\n\t\treturn (zn  * zf) / (z * (zn - zf) + zf);\n\t}\n\telse {\n\t\tfloat zf = unfclip.y; // camera z far\n\t\treturn z * 2.0 * zf - zf;\n\t}\n}\n\nfloat backface_depth(ivec2 texelpos, int lod)\n{\n\tfloat depth = linear_depth(bufferFetch(unfbackfacebuf, texelpos, lod).r);\n\n\t/* background case */\n\tif (depth == 1.0)\n\t\treturn -1e16;\n\telse\n\t\treturn -depth;\n}\n\nfloat frontface_depth(ivec2 texelpos, int lod)\n{\n\tfloat depth = linear_depth(bufferFetch(unfdepthbuf, texelpos, lod).r);\n\n\t/* background case */\n\tif (depth == 1.0)\n\t\treturn -1e16;\n\telse\n\t\treturn -depth;\n}\n\nvec3 position_from_depth(vec2 uv, float depth)\n{\n\tvec3 pos;\n\tfloat homcoord = projection_matrix[2][3] * depth + projection_matrix[3][3];\n\tpos.x = projection_matrix_inverse[0][0] * (uv.x * 2.0 - 1.0) * homcoord;\n\tpos.y = projection_matrix_inverse[1][1] * (uv.y * 2.0 - 1.0) * homcoord;\n\tpos.z = depth;\n\treturn pos;\n}\n\nvec2 uv_from_position(vec3 position)\n{\n\tvec4 projvec = projection_matrix * vec4(position, 1.0);\n\treturn (projvec.xy / projvec.w) * 0.5 + 0.5;\n}\n\nvec3 axis_angle_rotation(vec3 point, vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n\tmat3 mat = mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n\t                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n\t                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n\n\treturn mat * point;\n}\n\nvoid viewN_to_shadeN(vec3 N, out vec3 shadeN)\n{\n\tshadeN = normalize(-N);\n}\n\nvoid make_orthonormals(vec3 N, out vec3 T, out vec3 B)\n{\n\tvec3 UpVector = abs(N.z) < 0.99999 ? vec3(0.0,0.0,1.0) : vec3(1.0,0.0,0.0);\n\tT = normalize( cross(UpVector, N) );\n\tB = cross(N, T);\n}\n\nvoid make_orthonormals_tangent(vec3 N, inout vec3 T, out vec3 B)\n{\n\tB = normalize( cross(N, T) );\n\tT = cross(B, N);\n}\n\nvoid default_coordinates(vec3 attr_orco, out vec3 generated)\n{\n\tgenerated = attr_orco * 0.5 + vec3(0.5);\n}\n\nvec3 from_tangent_to_world( vec3 vector, vec3 N, vec3 T, vec3 B)\n{\n\treturn T * vector.x + B * vector.y + N * vector.z;\n}\n\nvec3 from_world_to_tangent( vec3 vector, vec3 N, vec3 T, vec3 B)\n{\n\treturn vec3( dot(T, vector), dot(B, vector), dot(N, vector));\n}\n\nfloat line_plane_intersect_dist(vec3 lineorigin, vec3 linedirection, vec3 planeorigin, vec3 planenormal)\n{\n    return dot(planenormal, planeorigin - lineorigin) / dot(planenormal, linedirection);\n}\n\nvec3 line_plane_intersect(vec3 lineorigin, vec3 linedirection, vec3 planeorigin, vec3 planenormal)\n{\n\tfloat dist = line_plane_intersect_dist(lineorigin, linedirection, planeorigin, planenormal);\n\treturn lineorigin + linedirection * dist;\n}\n\n/* from cycles ray_aligned_disk_intersect */\nfloat line_aligned_plane_intersect_dist(vec3 lineorigin, vec3 linedirection, vec3 planeorigin)\n{\n\t/* aligned plane normal */\n\tvec3 L = planeorigin - lineorigin;\n\tfloat diskdist = length(L);\n\tvec3 planenormal = -normalize(L);\n\treturn -diskdist / dot(planenormal, linedirection);\n}\n\nvec3 line_aligned_plane_intersect(vec3 lineorigin, vec3 linedirection, vec3 planeorigin)\n{\n\tfloat dist = line_aligned_plane_intersect_dist(lineorigin, linedirection, planeorigin);\n\tif (dist < 0.0) {\n\t\t/* if intersection is behind we fake the intersection to be\n\t\t * really far and (hopefully) not inside the radius of interest */\n\t\tdist = 1e16;\n\t}\n\treturn lineorigin + linedirection * dist;\n}\n\nvoid most_representative_point(float l_radius, float l_lenght, vec3 l_Y,\n                               float l_distance, vec3 R, inout vec3 L,\n                               inout float roughness, inout float energy_conservation)\n{\n\tL = l_distance * L;\n\n\t/* Tube Light */\n\tif(l_lenght>0.0){\n\t\troughness = max(3e-3, roughness); /* Artifacts appear with roughness below this threshold */\n\n\t\t// Use Tube Light specular instead of a plane.\n\t\t// Energy conservation\n\t\t// asin(x) is angle to sphere, atan(x) is angle to disk, saturate(x) is free and in the middle\n\t\t//float LineAngle = clamp( l_lenght / l_distance, 0.0, 1.0);\n\n\t\t//energy_conservation *= roughness / clamp(roughness + 0.5 * LineAngle, 0.0, 1.0);\n\n\t\t/* Closest point on line segment to ray */\n\t\tvec3 L01 = l_Y * l_lenght;\n\t\tvec3 L0 = L - 0.5 * L01;\n\t\tvec3 L1 = L + 0.5 * L01;\n\n\t\t/* Shortest distance */\n\t\tfloat a = l_lenght * l_lenght;\n\t\tfloat b = dot(R, L01);\n\t\tfloat t = saturate(dot( L0, b*R - L01 ) / (a - b*b));\n\t\tL = L0 + t * L01;\n\t}\n\n\t/* Sphere Light */\n\tif(l_radius>0.0){\n\t\troughness = max(3e-3, roughness); /* Artifacts appear with roughness below this threshold */\n\n\t\t/* energy preservation */\n\t\tfloat SphereAngle = saturate(l_radius / l_distance);\n\t\tenergy_conservation *= pow(roughness / saturate(roughness + 0.5 * SphereAngle), 2.0);\n\n\t\t/* sphere light */\n\t\t//float dist = line_aligned_plane_intersect_dist(vec3(0.0), R, L);\n\t\tfloat dist = dot(L, R);\n\t\tvec3 closest_point_on_ray = dist * R;\n\t\tvec3 center_to_ray = closest_point_on_ray - L;\n\t\t/* closest point on sphere */\n\t\tL = L + center_to_ray * saturate(l_radius * inverse_distance(center_to_ray));\n\t}\n\n\tL = normalize(L);\n}\n\nvoid most_representative_point_disk(float l_radius, float l_distance, vec3 R, inout vec3 L,\n                                    inout float roughness, inout float energy_conservation)\n{\n\tL = l_distance * L;\n\n\t/* Sphere Light */\n\tif(l_radius>0.0){\n\t\troughness = max(3e-3, roughness); /* Artifacts appear with roughness below this threshold */\n\n\t\t/* energy preservation */\n\t\tfloat SphereAngle = saturate(l_radius / l_distance);\n\t\tenergy_conservation *= pow(roughness / saturate(roughness + 0.5 * SphereAngle), 2.0);\n\n\t\t/* sphere light */\n\t\tvec3 closest_point_on_ray = line_plane_intersect(vec3(0.0), R, L, -normalize(L));\n\t\tvec3 center_to_ray = closest_point_on_ray - L;\n\t\t/* closest point on sphere */\n\t\tL = L + center_to_ray * saturate(l_radius * inverse_distance(center_to_ray));\n\t}\n\n\tL = normalize(L);\n}\n\nvec2 area_light_prepass(mat4 lmat, inout float areasizex, inout float areasizey, vec2 areascale, out vec3 lampx, out vec3 lampy, out vec3 lampz)\n{\n\tlampx = normalize( (lmat * vec4(1.0,0.0,0.0,0.0) ).xyz ); //lamp right axis\n\tlampy = normalize( (lmat * vec4(0.0,1.0,0.0,0.0) ).xyz ); //lamp up axis\n\tlampz = normalize( (lmat * vec4(0.0,0.0,1.0,0.0) ).xyz ); //lamp projection axis\n\n\tareasizex *= areascale.x;\n\tareasizey *= areascale.y;\n\n\treturn vec2(areasizex / 2.0, areasizey / 2.0);\n}\n\n\n/* ------ Linearly Transformed Cosines ------ */\n/* From https://eheitzresearch.wordpress.com/415-2/ */\n\nvoid area_light_points(vec3 lco, vec2 halfsize, vec3 lampx, vec3 lampy, out vec3 points[4])\n{\n\tvec3 ex = lampx * halfsize.x;\n\tvec3 ey = lampy * halfsize.y;\n\n\tpoints[0] = lco - ex + ey;\n\tpoints[1] = lco + ex + ey;\n\tpoints[2] = lco + ex - ey;\n\tpoints[3] = lco - ex - ey;\n}\n\nfloat integrate_edge(vec3 v1, vec3 v2)\n{\n    float cosTheta = dot(v1, v2);\n    cosTheta = clamp(cosTheta, -0.9999, 0.9999);\n\n    float theta = acos(cosTheta);\n    float res = cross(v1, v2).z * theta / sin(theta);\n\n    return res;\n}\n\nint clip_quad_to_horizon(inout vec3 L[5])\n{\n\t/* detect clipping config */\n\tint config = 0;\n\tif (L[0].z > 0.0) config += 1;\n\tif (L[1].z > 0.0) config += 2;\n\tif (L[2].z > 0.0) config += 4;\n\tif (L[3].z > 0.0) config += 8;\n\n\t/* clip */\n\tint n = 0;\n\n\tif (config == 0)\n\t{\n\t\t/* clip all */\n\t}\n\telse if (config == 1) /* V1 clip V2 V3 V4 */\n\t{\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t}\n\telse if (config == 2) /* V2 clip V1 V3 V4 */\n\t{\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t}\n\telse if (config == 3) /* V1 V2 clip V3 V4 */\n\t{\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t}\n\telse if (config == 4) /* V3 clip V1 V2 V4 */\n\t{\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t}\n\telse if (config == 5) /* V1 V3 clip V2 V4) impossible */\n\t{\n\t\tn = 0;\n\t}\n\telse if (config == 6) /* V2 V3 clip V1 V4 */\n\t{\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t}\n\telse if (config == 7) /* V1 V2 V3 clip V4 */\n\t{\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t}\n\telse if (config == 8) /* V4 clip V1 V2 V3 */\n\t{\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t}\n\telse if (config == 9) /* V1 V4 clip V2 V3 */\n\t{\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t}\n\telse if (config == 10) /* V2 V4 clip V1 V3) impossible */\n\t{\n\t\tn = 0;\n\t}\n\telse if (config == 11) /* V1 V2 V4 clip V3 */\n\t{\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t}\n\telse if (config == 12) /* V3 V4 clip V1 V2 */\n\t{\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t}\n\telse if (config == 13) /* V1 V3 V4 clip V2 */\n\t{\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t}\n\telse if (config == 14) /* V2 V3 V4 clip V1 */\n\t{\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t}\n\telse if (config == 15) /* V1 V2 V3 V4 */\n\t{\n\t\tn = 4;\n\t}\n\n\tif (n == 3)\n\t\tL[3] = L[0];\n\tif (n == 4)\n\t\tL[4] = L[0];\n\n\treturn n;\n}\n\nvec2 ltc_coords(float cosTheta, float roughness)\n{\n\tfloat theta = acos(cosTheta);\n\tvec2 coords = vec2(roughness, theta/(0.5*3.14159));\n\n\t/* scale and bias coordinates, for correct filtered lookup */\n\treturn coords * (LTC_LUT_SIZE - 1.0) / LTC_LUT_SIZE + 0.5 / LTC_LUT_SIZE;\n}\n\nmat3 ltc_matrix(vec2 coord)\n{\n\t/* load inverse matrix */\n\tvec4 t = texture2D(unfltcmat, coord);\n\tmat3 Minv = mat3(\n\t\tvec3(  1,   0, t.y),\n\t\tvec3(  0, t.z,   0),\n\t\tvec3(t.w,   0, t.x)\n\t);\n\n\treturn Minv;\n}\n\nfloat ltc_evaluate(vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 points[4])\n{\n\t/* construct orthonormal basis around N */\n\tvec3 T1, T2;\n\tT1 = normalize(V - N*dot(V, N));\n\tT2 = cross(N, T1);\n\n\t/* rotate area light in (T1, T2, R) basis */\n\tMinv = mul(Minv, mat3(T1.x, T2.x, N.x, T1.y, T2.y, N.y, T1.z, T2.z, N.z));\n\n\t/* polygon (allocate 5 vertices for clipping) */\n\tvec3 L[5];\n\tL[0] = mul(Minv, points[0] - P);\n\tL[1] = mul(Minv, points[1] - P);\n\tL[2] = mul(Minv, points[2] - P);\n\tL[3] = mul(Minv, points[3] - P);\n\n\tint n = clip_quad_to_horizon(L);\n\n\tif (n == 0)\n\t\treturn 0.0;\n\n\t/* project onto sphere */\n\tL[0] = normalize(L[0]);\n\tL[1] = normalize(L[1]);\n\tL[2] = normalize(L[2]);\n\tL[3] = normalize(L[3]);\n\tL[4] = normalize(L[4]);\n\n\t/* integrate */\n\tfloat sum = 0.0;\n\n\tsum += integrate_edge(L[0], L[1]);\n\tsum += integrate_edge(L[1], L[2]);\n\tsum += integrate_edge(L[2], L[3]);\n\tif (n >= 4)\n\t\tsum += integrate_edge(L[3], L[4]);\n\tif (n == 5)\n\t\tsum += integrate_edge(L[4], L[0]);\n\n\treturn abs(sum);\n}\n\n/* ------- Fresnel ---------*/\n\nfloat fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta)\n{\n\t/* compute fresnel reflectance without explicitly computing\n\t * the refracted direction */\n\tfloat c = abs(dot(Incoming, Normal));\n\tfloat g = eta * eta - 1.0 + c * c;\n\tfloat result;\n\n\tif(g > 0.0) {\n\t\tg = sqrt(g);\n\t\tfloat A =(g - c)/(g + c);\n\t\tfloat B =(c *(g + c)- 1.0)/(c *(g - c)+ 1.0);\n\t\tresult = 0.5 * A * A *(1.0 + B * B);\n\t}\n\telse {\n\t\tresult = 1.0;  /* TIR (no refracted component) */\n\t}\n\n\treturn result;\n}\n\n\n/* ------- Energy Conversion for lights ------- */\n/* from Sebastien Lagarde\n * course_notes_moving_frostbite_to_pbr.pdf */\n\nfloat sphere_energy(float radius)\n{\n\tradius = max(radius, 1e-8);\n\treturn 0.25 * M_1_PI2 / (radius*radius) /* 1/(4*r*Pi) */\n\t\t* M_PI2 * 10.0;  /* XXX : Empirical, Fit cycles power */\n}\n\nfloat disk_energy(float radius)\n{\n\tradius = max(radius, 1e-8);\n\treturn M_1_PI2 / (radius*radius); /* 1/(r*Pi) */\n}\n\nfloat tube_energy(float radius, float width)\n{\n\tradius = max(radius, 1e-8);\n\treturn 0.5 * M_1_PI2 / (radius * (width + 2.0 * radius)); /* 1/(4*r*Pi) + 1/(2*r*w*Pi) */\n}\n\nfloat rectangle_energy(float width, float height)\n{\n\treturn M_1_PI / (width*height) /* 1/(w*h*Pi) */\n\t\t* 80.0;  /* XXX : Empirical, Fit cycles power */\n}\n\n/* ------- Ambient Occlusion ------- */\n/* from Sebastien Lagarde\n * course_notes_moving_frostbite_to_pbr.pdf */\n\nfloat specular_occlusion(float NV, float AO, float roughness)\n{\n#ifdef USE_SSAO\n\treturn saturate(pow(NV + AO, roughness) - 1.0 + AO);\n#else\n\treturn 1.0;\n#endif\n}\n\n/* ----------- Parallax Correction -------------- */\n\nvoid parallax_correct_ray(inout vec3 L)\n{\n#ifdef CORRECTION_NONE\n\treturn;\n#else\n\tvec3 localray = (unfprobecorrectionmat * vec4(L, 0.0)).xyz;\n\tvec3 localpos = (unfprobecorrectionmat * vec4(worldpos, 1.0)).xyz;\n\n#ifdef CORRECTION_BOX\n\t/* https://seblagarde.wordpress.com/2012/09/29/image-based-lighting-approaches-and-parallax-corrected-cubemap/ */\n\tvec3 firstplane  = (vec3( 1.0) - localpos) / localray;\n\tvec3 secondplane = (vec3(-1.0) - localpos) / localray;\n\tvec3 furthestplane = max(firstplane, secondplane);\n\tfloat dist = min(furthestplane.x, min(furthestplane.y, furthestplane.z));\n#endif\n\n#ifdef CORRECTION_ELLIPSOID\n\t/* ray sphere intersection */\n\tfloat a = dot(localray, localray);\n\tfloat b = dot(localray, localpos);\n\tfloat c = dot(localpos, localpos) - 1;\n\n\tfloat dist = 1e15;\n\tfloat determinant = b * b - a * c;\n\tif (determinant >= 0.0)\n\t\tdist = (sqrt(determinant) - b) / a;\n#endif\n\n\t/* Use Distance in WS directly to recover intersection */\n\tvec3 intersection = worldpos + L * dist;\n\tL = intersection - unfprobepos;\n#endif\n}\n\n/* ----------- Probe sampling wrappers -------------- */\n\nvoid vector_prepass(vec3 viewpos, vec3 worldnor, mat4 invviewmat, mat4 viewmat)\n{\n\tworldpos = (invviewmat * vec4(viewpos, 1.0)).xyz;\n\n\tshade_view(viewpos, viewi);\n\tdirection_transform_m4v3(viewi, invviewmat, I);\n\n#ifdef PLANAR_PROBE\n\t/* View Normals */\n\tdirection_transform_m4v3(worldnor, viewmat, viewnor);\n\n\t/* transposing plane orientation to view space */\n\tdirection_transform_m4v3(unfplanarvec, viewmat, planarvec);\n\n\tplanarfac.x = dot(planarvec, vec3(1.0, 0.0, 0.0));\n\tplanarfac.y = dot(planarvec, vec3(0.0, 1.0, 0.0));\n\tplanarfac.z = -viewpos.z + 1.0;\n\n\tvec4 proj = unfplanarreflectmat * vec4(worldpos, 1.0);\n\trefpos = proj.xyz/proj.w;\n#endif\n}\n\n#if 0\nfloat distance_based_roughness(float dist_intersection_to_shaded, float dist_intersection_to_reflectioncam, float roughness)\n{\n\t/* from Sebastien Lagarde\n\t* course_notes_moving_frostbite_to_pbr.pdf */\n\tfloat newroughness = clamp(roughness * dist_intersection_to_shaded / dist_intersection_to_reflectioncam, 0, roughness);\n\treturn mix(newroughness, roughness, roughness);\n}\n#endif\n\nvec2 get_distorded_refl_uv(sampler2D planarprobe, vec2 Xi)\n{\n\tvec2 distortion = vec2(dot(viewnor, vec3(1.0, 0.0, 0.0)) - planarfac.x,\n\t                       dot(viewnor, vec3(0.0, 1.0, 0.0)) - planarfac.y);\n\tdistortion += Xi;\n\n\t/* modulate intensity by distance to the viewer and by distance to the reflected object */\n\tfloat dist_view_to_shaded = planarfac.z;\n\tfloat dist_intersection_to_reflectioncam = texture2D(planarprobe, refpos.xy + Xi / dist_view_to_shaded).a;\n\tfloat dist_intersection_to_shaded = dist_intersection_to_reflectioncam - dist_view_to_shaded; /* depth in alpha */\n\n\t/* test in case of background */\n\tif (dist_intersection_to_shaded > 0.0) {\n\t\tfloat distortion_scale = abs(dot(viewi * dist_intersection_to_shaded, -planarvec));\n\t\tdistortion *= distortion_scale / (dist_view_to_shaded + 1.0);\n\t}\n\n\treturn refpos.xy + distortion;\n}\n\nvec4 sample_probe_pdf(vec3 cubevec, float pdf)\n{\n\tvec4 sample;\n\n\tfloat lod = unflodfactor - 0.5 * log2(pdf);\n\n\tparallax_correct_ray(cubevec);\n\tsample = textureCubeLodEXT(unfprobe, cubevec, lod);\n\n\tsrgb_to_linearrgb(sample, sample);\n\treturn sample;\n}\n\nvec4 sample_probe_pdf(sampler2D planarprobe, vec3 cubevec, float roughness, float pdf)\n{\n\tvec4 sample;\n\n\tfloat lod = unflodfactor - 0.5 * log2(pdf);\n\n\tparallax_correct_ray(cubevec);\n\tsample = textureCubeLodEXT(unfprobe, cubevec, lod);\n\n#ifdef PLANAR_PROBE\n\tvec4 sample_plane = vec4(0.0);\n\tvec2 co = get_distorded_refl_uv(planarprobe, Ht.xy);\n\tif (co.x > 0.0 && co.x < 1.0 && co.y > 0.0 && co.y < 1.0)\n\t\tsample_plane = texture2DLodEXT(planarprobe, co, lod);\n\telse\n\t\tsample_plane = sample;\n\tsample = mix(sample_plane, sample, clamp(roughness * 2.0 - 0.5, 0.0, 1.0));\n#endif\n\n\tsrgb_to_linearrgb(sample, sample);\n\treturn sample;\n}\n\nvec4 sample_reflect_pdf(vec3 L, float roughness, float pdf)\n{\n\treturn sample_probe_pdf(unfreflect, L, roughness, pdf);\n}\n\nvec4 sample_refract_pdf(vec3 L, float roughness, float pdf)\n{\n\treturn sample_probe_pdf(unfrefract, L, roughness, pdf);\n}\n\nvec4 sample_probe(sampler2D planarprobe, vec3 cubevec)\n{\n\tvec4 sample;\n\n\t/* Cubemap */\n\tparallax_correct_ray(cubevec);\n\tsample = textureCube(unfprobe, cubevec);\n\n#ifdef PLANAR_PROBE\n\t/* Planar */\n\tvec2 co = get_distorded_refl_uv(planarprobe, vec2(0.0));\n\tif (co.x > 0.0 && co.x < 1.0 && co.y > 0.0 && co.y < 1.0)\n\t\tsample = texture2D(planarprobe, co);\n#endif\n\n\tsrgb_to_linearrgb(sample, sample);\n\treturn sample;\n}\n\nvec4 sample_reflect(vec3 L)\n{\n\treturn sample_probe(unfreflect, L);\n}\n\nvec4 sample_refract(vec3 L)\n{\n\treturn sample_probe(unfrefract, L);\n}\n\n/* ------- Sampling Random Ray -------- */\n\nvoid setup_noise(vec2 fragcoord)\n{\n\tconst float NOISE_SIZE = 64.0;\n\tivec2 texel = ivec2(mod(fragcoord.x, NOISE_SIZE), mod(fragcoord.y, NOISE_SIZE));\n#if __VERSION__ < 130\n\tjitternoise = (texture2DLodEXT(unfjitter, (vec2(texel) + 0.5) / 64.0, 0.0).rg-vec2(0.5))*2.0; /* Global variable */\n#else\n\tjitternoise = texelFetch(unfjitter, texel, 0).rg; /* Global variable */\n#endif\n}\n\nvec3 hammersley_3d(float i, float invsamplenbr)\n{\n\tvec3 Xi; /* Theta, cos(Phi), sin(Phi) */\n\n\tXi.x = i * invsamplenbr; /* i/samples */\n\tXi.x = fract(Xi.x + jitternoise.x);\n\n\tint u = int(mod(i + jitternoise.y * 64.0, 64.0));\n\n#if __VERSION__ < 130\n\tXi.yz = (texture2DLodEXT(unflutsamples, vec2((float(u) + 0.5) / 1024.0, 0.0), 0.0).rg-0.5)*2.0; /* Global variable */\n#else\n\tXi.yz = texelFetch(unflutsamples, u, 0).rg; /* Global variable */\n#endif\n\treturn Xi;\n}\n\nvec3 hammersley_3d(float i)\n{\n\treturn hammersley_3d(i, 0.03125);\n}\n\n/* ------- Screen Space Raycasting ---------*/\n\n/* By Morgan McGuire and Michael Mara at Williams College 2014\n * Released as open source under the BSD 2-Clause License\n * http://opensource.org/licenses/BSD-2-Clause\n * http://casual-effects.blogspot.fr/2014/08/screen-space-ray-tracing.html */\nvoid swapIfBigger(inout float a, inout float b)\n{\n\tif (a > b) {\n\t\tfloat temp = a;\n\t\ta = b;\n\t\tb = temp;\n\t}\n}\n\n/* 2D raycast : still have some bug that needs to be sorted out before being usable */\nbool raycast(vec3 ray_origin, vec3 ray_dir, out float hitstep, out vec2 hitpixel, out vec3 hitco)\n{\n\t/* ssr_parameters */\n\tfloat nearz = -unfclip.x; /* Near plane distance (Negative number) */\n\tfloat farz = -unfclip.y; /* Far plane distance (Negative number) */\n\n\t/* Clip ray to a near plane in 3D */\n\tfloat ray_length = 1e16;\n\tif ((ray_origin.z + ray_dir.z * ray_length) > nearz)\n\t\tray_length = (nearz - ray_origin.z) / ray_dir.z;\n\n\tvec3 ray_end = ray_dir * ray_length + ray_origin;\n\n\t/* Project into screen space */\n\tvec4 H0 = unfpixelprojmat * vec4(ray_origin, 1.0);\n\tvec4 H1 = unfpixelprojmat * vec4(ray_end, 1.0);\n\n\t/* There are a lot of divisions by w that can be turned into multiplications\n\t* at some minor precision loss...and we need to interpolate these 1/w values\n\t* anyway. */\n\tfloat k0 = 1.0 / H0.w;\n\tfloat k1 = 1.0 / H1.w;\n\n\t/* Switch the original points to values that interpolate linearly in 2D */\n\tvec3 Q0 = ray_origin * k0;\n\tvec3 Q1 = ray_end * k1;\n\n\t/* Screen-space endpoints */\n\tvec2 P0 = H0.xy * k0;\n\tvec2 P1 = H1.xy * k1;\n\n\t/* [Optional clipping to frustum sides here] */\n\n\t/* Initialize to off screen */\n\thitpixel = vec2(-1.0, -1.0);\n\n\t/* If the line is degenerate, make it cover at least one pixel\n\t * to not have to handle zero-pixel extent as a special case later */\n\tP1 += vec2((distance_squared(P0, P1) < 0.0001) ? 0.01 : 0.0);\n\n\tvec2 delta = P1 - P0;\n\n\t/* Permute so that the primary iteration is in x to reduce large branches later.\n\t * After this, \"x\" is the primary iteration direction and \"y\" is the secondary one\n\t * If it is a more-vertical line, create a permutation that swaps x and y in the output\n\t * and directly swizzle the inputs. */\n\tbool permute = false;\n\tif (abs(delta.x) < abs(delta.y)) {\n\t\tpermute = true;\n\t\tdelta = delta.yx;\n\t\tP1 = P1.yx;\n\t\tP0 = P0.yx;\n\t}\n\n\t/* Track the derivatives */\n\tfloat step_sign = sign(delta.x);\n\tfloat invdx = step_sign / delta.x;\n\tvec2 dP = vec2(step_sign, invdx * delta.y);\n\tvec3 dQ = (Q1 - Q0) * invdx;\n\tfloat dk = (k1 - k0) * invdx;\n\n\t/* Slide each value from the start of the ray to the end */\n\tvec4 pqk = vec4(P0, Q0.z, k0);\n\n\t/* Scale derivatives by the desired pixel stride */\n\tvec4 dPQK = vec4(dP, dQ.z, dk) * 1.0;\n\n\tbool hit = false;\n\n#if 1 /* Linear 2D raymarching */\n\n\t/* We track the ray depth at +/- 1/2 pixel to treat pixels as clip-space solid\n\t * voxels. Because the depth at -1/2 for a given pixel will be the same as at\n\t * +1/2 for the previous iteration, we actually only have to compute one value\n\t * per iteration. */\n\tfloat prev_zmax = ray_origin.z;\n\tfloat zmax, zmin;\n\n\t/* P1.x is never modified after this point, so pre-scale it by\n\t * the step direction for a signed comparison */\n\tfloat end = P1.x * step_sign;\n\n\tfor (hitstep = 0.0; hitstep < unfssrparam.x && !hit; hitstep++)\n\t{\n\t\t/* Ray finished & no hit*/\n\t\tif ((pqk.x * step_sign) > end) break;\n\n\t\t/* step through current cell */\n\t\tpqk += dPQK;\n\n\t\thitpixel = permute ? pqk.yx : pqk.xy;\n\t\tzmin = prev_zmax;\n\t\tzmax = (dPQK.z * 0.5 + pqk.z) / (dPQK.w * 0.5 + pqk.w);\n\t\tprev_zmax = zmax;\n\t\tswapIfBigger(zmin, zmax);\n\n\t\tfloat frontface = frontface_depth(ivec2(hitpixel), 0);\n\n\t\tif (zmax < frontface) {\n\t\t\t/* Below surface */\n#ifdef USE_BACKFACE\n\t\t\tfloat backface = backface_depth(ivec2(hitpixel), 0);\n#else\n\t\t\tfloat backface = frontface - unfssrparam.z;\n#endif\n\t\t\thit = (zmin > backface);\n\t\t}\n\t}\n\n\t/* Hit coordinate in 3D */\n\thitco = (Q0 + dQ * hitstep) / pqk.w;\n\n#else /* Hierarchical raymarching */\n\n\tfloat z, mip, mippow, s;\n\tfloat level = 1.0;\n\tfloat steps = 0.0;\n\tfloat dir = 1.0;\n\tfloat lastdir = 1.0;\n\tfor (hitstep = 0.0; hitstep < unfssrparam.x && level > 0.0; hitstep++) {\n\t\tmip = level - 1.0;\n\t\tmippow = pow(2, mip);\n\n\t\t/* step through current cell */\n\t\t//s = dir * max(1.0, mippow / 2);\n\t\ts = dir * mippow;\n\t\t//s = dir * level;\n\t\tP += dP * s; Q.z += dQ.z * s; k += dk * s; steps += s;\n\n\t\thitpixel = permute ? P.yx : P;\n\t\tz = dQ.z / k;\n\n\t\tfloat frontface = frontface_depth(ivec2(hitpixel / mippow), int(mip));\n\n\t\tif (z < frontface) {\n\t\t\t/* Below surface */\n#ifdef USE_BACKFACE\n\t\t\tfloat backface = backface_depth(ivec2(hitpixel), 0);\n#else\n\t\t\tfloat backface = -1e16; /* Todo find a good thickness */\n#endif\n\t\t\tif (z > backface) {\n\t\t\t\t/* Hit */\n\t\t\t\t/* This will step back the current step */\n\t\t\t\t//s = -1.0 * level;\n\t\t\t\t//P += dP * s; Q.z += dQ.z * s; k += dk * s; steps += s;\n\t\t\t\tdir = -1.0;\n\t\t\t\tlevel--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* Above surface */\n\t\tif (dir != -1.0 && lastdir != -1.0) {\n\t\t\t/* Only step up in mip if the last iteration was positive\n\t\t\t * This way we don't skip potential occluders */\n\t\t\tlevel++;\n\t\t\tlevel = min(level, 5.0);\n\t\t}\n\t\tlastdir = dir;\n\t\tdir = 1.0;\n\t}\n\n\thitstep = 1.0;\n\n\thit = (level == 0.0);\n\n\t/* Hit coordinate in 3D */\n\thitco = (Q0 + dQ * steps) / k;\n#endif\n\n\treturn hit;\n}\n\nfloat ssr_contribution(vec3 ray_origin, float hitstep, bool hit, inout vec3 hitco)\n{\n\t/* ssr_parameters */\n\tfloat maxstep = \tunfssrparam.x; /* Maximum number of iteration when raymarching */\n\tfloat attenuation = unfssrparam.y; /* Attenuation factor for screen edges and ray step fading */\n\n\t/* ray step fade */\n\tfloat stepfade = saturate((1.0 - hitstep / maxstep) * attenuation);\n\n\t/* screen edges fade */\n\tvec4 co = projection_matrix * vec4(hitco, 1.0);\n\tco.xy /= co.w;\n\thitco.xy = co.xy * 0.5 + 0.5;\n\tfloat maxdimension = saturate(max(abs(co.x), abs(co.y)));\n\tfloat screenfade = saturate((0.999999 - maxdimension) * attenuation);\n\n\treturn smoothstep(0.0, 1.0, stepfade * screenfade) * float(hit);\n}\n/* -------- Utils Functions --------- */\n\nvec3 sample_ggx(float nsample, float a2, vec3 N, vec3 T, vec3 B)\n{\n\tvec3 Xi = hammersley_3d(nsample);\n\n\tfloat z = sqrt( (1.0 - Xi.x) / ( 1.0 + a2 * Xi.x - Xi.x ) ); /* cos theta */\n\tfloat r = sqrt( 1.0 - z * z ); /* sin theta */\n\tfloat x = r * Xi.y;\n\tfloat y = r * Xi.z;\n\n\t/* Global variable */\n\tHt = vec3(x, y, z);\n\n\treturn from_tangent_to_world(Ht, N, T, B);\n}\n\nvec3 sample_beckmann(float nsample, float a2, vec3 N, vec3 T, vec3 B)\n{\n\tvec3 Xi = hammersley_3d(nsample);\n\n\tfloat z = sqrt( 1.0 / ( 1.0 - a2 * log(1.0 - Xi.x) ) ); /* cos theta */\n\tfloat r = sqrt( 1.0 - z * z ); /* sin theta */\n\tfloat x = r * Xi.y;\n\tfloat y = r * Xi.z;\n\n\t/* Global variable */\n\tHt = vec3(x, y, z);\n\n\treturn from_tangent_to_world(Ht, N, T, B);\n}\n\nvec3 sample_ashikhmin_shirley(float nsample, float n_x, vec3 N, vec3 T, vec3 B)\n{\n\tvec3 Xi = hammersley_3d(nsample);\n\n\tfloat z = pow( Xi.x, 1.0 / (n_x + 1.0) ); /* cos theta */\n\tfloat r = sqrt( 1.0 - z * z ); /* sin theta */\n\tfloat x = r * Xi.y;\n\tfloat y = r * Xi.z;\n\n\t/* Global variable */\n\tHt = vec3(x, y, z);\n\n\treturn from_tangent_to_world(Ht, N, T, B);\n}\n\nfloat D_ggx_opti(float NH, float a2)\n{\n\tfloat tmp = (NH * a2 - NH) * NH + 1.0;\n\treturn M_PI * tmp*tmp; /* Doing RCP and mul a2 at the end */\n}\n\nfloat D_beckman(float NH, float a2)\n{\n\tfloat NH2 = NH * NH;\n\treturn exp((NH2 - 1.0) / (NH2 * a2)) / (M_PI * a2 * NH2 * NH2);\n}\n\nfloat pdf_ggx_reflect(float NH, float a2)\n{\n\treturn NH * a2 / D_ggx_opti(NH, a2);\n}\n\nfloat pdf_beckmann_reflect(float NH, float a2)\n{\n\treturn NH * D_beckman(NH, a2);\n}\n\nfloat pdf_ashikhmin_shirley_reflect(float NH, float VH, float n_x)\n{\n\tfloat lobe = pow(NH, n_x);\n\tfloat norm = (n_x + 1.0) * 0.125 * M_1_PI;\n\n\treturn norm * lobe / VH;\n}\n\nvoid prepare_glossy(float roughness, out float a, out float a2)\n{\n\t/* Artifacts appear with roughness below this threshold */\n\t/* XXX TODO : find why flooring is necessary */\n\ta  = clamp(roughness, 2e-4, 0.9999999);\n\ta2 = max(1e-8, a*a);\n}\n\nfloat G1_Smith_GGX(float NX, float a2)\n{\n\t/* Using Brian Karis approach and refactoring by NX/NX\n\t * this way the (2*NL)*(2*NV) in G = G1(V) * G1(L) gets canceled by the brdf denominator 4*NL*NV\n\t * Rcp is done on the whole G later\n\t * Note that this is not convenient for the transmition formula */\n\treturn NX + sqrt( NX * (NX - NX * a2) + a2 );\n\t/* return 2 / (1.0 + sqrt(1.0 + a2 * (1.0 - NX*NX) / (NX*NX) ) ); /* Reference function */\n}\n\nfloat G1_Smith_beckmann(float NX, float a2)\n{\n\tfloat tmp = 1.0 / (sqrt(a2 * (1.0 - NX * NX) / (NX * NX)));\n\treturn (tmp < 1.6) ? (3.535 * tmp + 2.181 * tmp * tmp) / (1.0 + 2.276 * tmp + 2.577 * tmp * tmp) : 1.0;\n}\n\n/* -------- BSDF --------- */\n\nfloat bsdf_ggx(vec3 N, vec3 L, vec3 V, float roughness)\n{\n\tfloat a, a2; prepare_glossy(roughness, a, a2);\n\n\tvec3 H = normalize(L + V);\n\tfloat NH = max(dot(N, H), 1e-8);\n\tfloat NL = max(dot(N, L), 1e-8);\n\tfloat NV = max(dot(N, V), 1e-8);\n\n\tfloat G = G1_Smith_GGX(NV, a2) * G1_Smith_GGX(NL, a2); /* Doing RCP at the end */\n\tfloat D = D_ggx_opti(NH, a2);\n\n\t/* Denominator is canceled by G1_Smith */\n\t/* bsdf = D * G / (4.0 * NL * NV); /* Reference function */\n\treturn NL * a2 / (D * G); /* NL to Fit cycles Equation : line. 345 in bsdf_microfacet.h */\n}\n\n/* This one returns the brdf already divided by the pdf */\nfloat bsdf_ggx_pdf(float a2, float NH, float NL, float VH, float G1_V)\n{\n\tfloat G = G1_V * G1_Smith_GGX(NL, a2); /* Doing RCP at the end */\n\n\t/* Denominator is canceled by G1_Smith\n\t * brdf = D * G / (4.0 * NL * NV) [denominator canceled by G]\n\t * pdf = D * NH / (4 * VH) [D canceled later by D in brdf] */\n\treturn 4.0 * VH / (NH * G); /* brdf / pdf */\n}\n\nfloat bsdf_beckmann(vec3 N, vec3 L, vec3 V, float roughness)\n{\n\tfloat a, a2; prepare_glossy(roughness, a, a2);\n\n\tvec3 H = normalize(L + V);\n\tfloat NH = max(dot(N, H), 1e-8);\n\tfloat NL = max(dot(N, L), 1e-8);\n\tfloat NV = max(dot(N, V), 1e-8);\n\n\tfloat G = G1_Smith_beckmann(NV, a2) * G1_Smith_beckmann(NL, a2);\n\tfloat D = D_beckman(NH, a2);\n\n\treturn NL * D * G * 0.25 / (NL * NV);\n}\n\n/* This one returns the brdf already divided by the pdf */\nfloat bsdf_beckmann_pdf(float a2, float NH, float NV, float NL, float VH, float G1_V)\n{\n\tfloat G = G1_V * G1_Smith_beckmann(NL, a2);\n\n\t/* brdf = D * G / (4.0 * NL * NV)\n\t * pdf = D * NH / (4 * VH) [D canceled later by D in brdf] */\n\treturn G * VH / (NH * NV * NL); /* brdf / pdf */\n}\n\nfloat bsdf_ashikhmin_shirley(vec3 N, vec3 L, vec3 V, float roughness)\n{\n\tfloat a, a2; prepare_glossy(roughness, a, a2);\n\n\tvec3 H = normalize(L + V);\n\tfloat NL = max(dot(N, L), 1e-6);\n\tfloat NV = max(dot(N, V), 1e-6);\n\tfloat NH = max(dot(N, H), 1e-6);\n\tfloat VH = max(abs(dot(V, H)), 1e-6);\n\n\tfloat pump = 1.0 / max(1e-6, VH * max(NL, NV));\n\tfloat n_x = 2.0 / a2 - 2.0;\n\tfloat lobe = pow(NH, n_x);\n\tfloat norm = (n_x + 1.0) * 0.125 * M_1_PI;\n\n\treturn NL * norm * lobe * pump;\n}\n\n/* This one returns the brdf already divided by the pdf */\nfloat bsdf_ashikhmin_shirley_pdf(float NV, float NL, float VH)\n{\n\tfloat pump = 1.0 / max(1e-6, VH * max(NL, NV));\n\n\treturn VH * pump;\n}\n\n/* -------- Preview Lights --------- */\n\nvoid node_bsdf_glossy_lights(vec4 color, float roughness, vec3 N, vec3 V, vec4 ambient_light, out vec4 result)\n{\n\tvec3 accumulator = ambient_light.rgb;\n\n\tif (roughness <= 1e-4) {\n\t\tresult = vec4(accumulator * color.rgb, 1.0);\n\t\treturn;\n\t}\n\n\tshade_view(V, V); V = -V;\n\tN = normalize(N);\n\n\t/* directional lights */\n\tfor(int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 L = vec3(0,0,0).xyz;\n\t\tvec3 light_color = vec3(0,0,0).rgb;\n\n\t\taccumulator += light_color * bsdf_ggx(N, L, V, roughness);\n\t}\n\n\tresult = vec4(accumulator * color.rgb, 1.0);\n}\n\n/* -------- Physical Lights --------- */\n\n/* GLOSSY SHARP */\n\nvoid bsdf_glossy_sharp_sphere_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tfloat l_radius = l_areasizex;\n\tL = l_distance * L;\n\tvec3 R = -reflect(V, N);\n\n\tvec3 P = line_aligned_plane_intersect(vec3(0.0), R, L);\n\tbsdf = (distance_squared(P, L) < l_radius * l_radius) ? 1.0 : 0.0;\n\n\t/* Energy conservation + cycle matching */\n\tbsdf *= sphere_energy(l_radius);\n}\n\nvoid bsdf_glossy_sharp_area_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tif (max(l_areasizex, l_areasizey) < 1e-6) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tL = l_distance * L;\n\n\tvec3 lampx, lampy, lampz;\n\tvec2 halfsize = area_light_prepass(l_mat, l_areasizex, l_areasizey, l_areascale, lampx, lampy, lampz);\n\n\t/* Find the intersection point E between the reflection vector and the light plane */\n\tvec3 R = reflect(V, N);\n\tvec3 E = line_plane_intersect(vec3(0.0), R, L, lampz);\n\n\t/* Project it onto the light plane */\n\tvec3 projection = E - L;\n\tfloat A = dot(lampx, projection);\n\tfloat B = dot(lampy, projection);\n\n\tbsdf = (abs(A) < halfsize.x && abs(B) < halfsize.y) ? 1.0 : 0.0;\n\n\t/* Masking */\n\tbsdf *= (dot(-L, lampz) > 0.0) ? 1.0 : 0.0;\n\tbsdf *= (dot(R, lampz) > 0.0) ? 1.0 : 0.0;\n\n\t/* Energy conservation + cycle matching */\n\tbsdf *= rectangle_energy(l_areasizex, l_areasizey);\n}\n\nvoid bsdf_glossy_sharp_sun_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tvec3 R = reflect(V, N);\n\n\tfloat l_radius = l_areasizex;\n\tfloat angle = atan(l_radius);\n\n\tfloat costheta = dot(-L, R);\n\tfloat cosangle = cos(angle);\n\n\tbsdf = (costheta > cosangle) ? 1.0 : 0.0;\n\n\t/* Energy conservation + cycle matching */\n\tbsdf *= disk_energy(l_radius);\n\tbsdf /= costheta * costheta * costheta;\n\tbsdf *= M_PI;\n}\n\n/* GLOSSY GGX */\n\nvoid bsdf_glossy_ggx_sphere_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n#if 1\n\t/* MRP is twice as fast as LTC, does not exhibit crucial artifacts and is better looking */\n\tfloat l_radius = l_areasizex;\n\n\tshade_view(V, V);\n\tvec3 R = reflect(V, N);\n\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point(l_radius, 0.0, vec3(0.0), l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_ggx(N, L, V, roughness);\n\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= sphere_energy(l_radius) * max(l_radius * l_radius, 1e-16); /* l_radius is already inside energy_conservation */\n\tbsdf *= M_PI;\n#else\n\t/* LTC */\n\tfloat l_radius = max(0.007, l_areasizex);\n\n\tvec3 pos = V;\n\tshade_view(V, V);\n\tvec3 R = -reflect(V, N);\n\tL = l_distance * L;\n\tV = -V;\n\tN = -N;\n\n\tvec3 P = line_aligned_plane_intersect(vec3(0.0), R, L);\n\tvec3 Px = normalize(P - L) * l_radius;\n\tvec3 Py = axis_angle_rotation(Px, R, M_PI_2);\n\n\tvec3 points[4];\n\tpoints[0] = l_coords + Px;\n\tpoints[1] = l_coords - Py;\n\tpoints[2] = l_coords - Px;\n\tpoints[3] = l_coords + Py;\n\n\tfloat NV = max(dot(N, V), 1e-8);\n\tvec2 uv = ltc_coords(NV, sqrt(roughness));\n\tmat3 ltcmat = ltc_matrix(uv);\n\n\tbsdf = ltc_evaluate(N, V, pos, ltcmat, points);\n\tbsdf *= texture2D(unfltcmag, uv).r; /* Bsdf matching */\n\n\tbsdf *= M_1_2PI;\n\tbsdf *= sphere_energy(l_radius);\n#endif\n}\n\nvoid bsdf_glossy_ggx_area_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tif (min(l_areasizex, l_areasizey) < 1e-6) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tvec3 pos = V;\n\tshade_view(V, V);\n\tV = -V;\n\tN = -N;\n\n\tvec3 lampx, lampy, lampz;\n\tvec2 halfsize = area_light_prepass(l_mat, l_areasizex, l_areasizey, l_areascale, lampx, lampy, lampz);\n\n\tvec3 points[4];\n\tarea_light_points(l_coords, halfsize, lampx, lampy, points);\n\n\tfloat NV = max(dot(N, V), 1e-8);\n\tvec2 uv = ltc_coords(NV, sqrt(roughness));\n\tmat3 ltcmat = ltc_matrix(uv);\n\n\tbsdf = ltc_evaluate(N, V, pos, ltcmat, points);\n\tbsdf *= texture2D(unfltcmag, uv).r; /* Bsdf matching */\n\n\tbsdf *= step(0.0, -dot(L, lampz));\n\tbsdf *= M_1_2PI;\n\tbsdf *= rectangle_energy(l_areasizex, l_areasizey);\n}\n\nvoid bsdf_glossy_ggx_sun_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\t/* Correct ligth shape but uniform intensity\n\t * Does not take into account the division by costheta^3 */\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tvec3 R = reflect(V, N);\n\n\tfloat l_radius = l_areasizex;\n\tfloat angle = atan(l_radius);\n\n\tfloat costheta = dot(-L, R);\n\tfloat cosangle = cos(angle);\n\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point_disk(l_radius, 1.0, R, L, roughness, energy_conservation);\n\n\tbsdf = bsdf_ggx(N, L, V, roughness);\n\tbsdf *= energy_conservation;\n}\n\n/* GLOSSY BECKMANN */\n\nvoid bsdf_glossy_beckmann_sphere_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\t/* MRP is twice as fast as LTC, does not exhibit crucial artifacts and is better looking */\n\tfloat l_radius = l_areasizex;\n\n\tshade_view(V, V);\n\tvec3 R = reflect(V, N);\n\n\tfloat energy_conservation = 1.0; /* XXX TODO : Energy conservation is done for GGX */\n\tmost_representative_point(l_radius, 0.0, vec3(0.0), l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_beckmann(N, L, V, roughness);\n\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= sphere_energy(l_radius) * max(l_radius * l_radius, 1e-16); /* l_radius is already inside energy_conservation */\n\tbsdf *= M_PI;\n}\n\nvoid bsdf_glossy_beckmann_area_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\t/* TODO Make the other ltc luts */\n\tbsdf_glossy_ggx_area_light( N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, \n\t\tl_mat, roughness, ior, sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, bsdf);\n}\n\nvoid bsdf_glossy_beckmann_sun_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\t/* Correct ligth shape but uniform intensity\n\t * Does not take into account the division by costheta^3 */\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tvec3 R = reflect(V, N);\n\n\tfloat l_radius = l_areasizex;\n\tfloat angle = atan(l_radius);\n\n\tfloat costheta = dot(-L, R);\n\tfloat cosangle = cos(angle);\n\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point_disk(l_radius, 1.0, R, L, roughness, energy_conservation);\n\n\tbsdf = bsdf_beckmann(N, L, V, roughness);\n\tbsdf *= energy_conservation;\n}\n\n/* GLOSSY ASHIKhMIN SHIRLEY */\n\nvoid bsdf_glossy_ashikhmin_shirley_sphere_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\t/* MRP is twice as fast as LTC, does not exhibit crucial artifacts and is better looking */\n\tfloat l_radius = l_areasizex;\n\n\tshade_view(V, V);\n\tvec3 R = reflect(V, N);\n\n\tfloat energy_conservation = 1.0; /* XXX TODO : Energy conservation is done for GGX */\n\tmost_representative_point(l_radius, 0.0, vec3(0.0), l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_ashikhmin_shirley(N, L, V, roughness);\n\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= sphere_energy(l_radius) * max(l_radius * l_radius, 1e-16); /* l_radius is already inside energy_conservation */\n\tbsdf *= M_PI;\n}\n\nvoid bsdf_glossy_ashikhmin_shirley_area_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\t/* TODO Make the other ltc luts */\n\tbsdf_glossy_ggx_area_light( N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, \n\t\tl_mat, roughness, ior, sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, bsdf);\n}\n\nvoid bsdf_glossy_ashikhmin_shirley_sun_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\t/* Correct ligth shape but uniform intensity\n\t * Does not take into account the division by costheta^3 */\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tvec3 R = reflect(V, N);\n\n\tfloat l_radius = l_areasizex;\n\tfloat angle = atan(l_radius);\n\n\tfloat costheta = dot(-L, R);\n\tfloat cosangle = cos(angle);\n\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point_disk(l_radius, 1.0, R, L, roughness, energy_conservation);\n\n\tbsdf = bsdf_ashikhmin_shirley(N, L, V, roughness);\n\tbsdf *= energy_conservation;\n}\n\n/* -------- Image Based Lighting --------- */\n\nvoid env_sampling_glossy_sharp(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\n\t/* Precomputation */\n\tvec3 L = reflect(I, N);\n\tvec3 vL = (viewmat * vec4(L, 0.0)).xyz;\n\n\t/* Probe */\n\tvec4 sample_probe = sample_reflect(L) * specular_occlusion(dot(N, -I), ao_factor, 0.0);\n\n#ifdef USE_SSR\n\t/* SSR */\n\tvec2 hitpixel; vec3 hitco; float hitstep;\n\n\tbool hit = raycast(viewpos, vL, hitstep, hitpixel, hitco);\n\tfloat contrib = ssr_contribution(viewpos, hitstep, hit, hitco);\n\n\tvec4 sample_ssr = bufferFetch(unfscenebuf, ivec2(hitpixel.xy), 0);\n\tsrgb_to_linearrgb(sample_ssr, sample_ssr);\n\n\tresult = mix(sample_probe.rgb, sample_ssr.rgb, contrib);\n#else\n\tresult = sample_probe.rgb;\n#endif\n}\n\nvoid env_sampling_glossy_ggx(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tmake_orthonormals(N, T, B); /* Generate tangent space */\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\tfloat a, a2; prepare_glossy(roughness, a, a2);\n\n\t/* Precomputation */\n\tfloat NV = max(1e-8, abs(dot(I, N)));\n\tfloat G1_V = G1_Smith_GGX(NV, a2);\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 H = sample_ggx(i, a2, N, T, B); /* Microfacet normal */\n\t\tvec3 L = reflect(I, H);\n\t\tfloat NL = dot(N, L);\n\n\t\tif (NL > 0.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat NH = max(1e-8, dot(N, H)); /* cosTheta */\n\t\t\tfloat VH = max(1e-8, -dot(I, H));\n\n\t\t\tfloat pdf = pdf_ggx_reflect(NH, a2);\n\n\t\t\tvec4 sample = sample_reflect_pdf(L, roughness, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF */\n\t\t\tfloat brdf_pdf = bsdf_ggx_pdf(a2, NH, NL, VH, G1_V);\n\n\t\t\tout_radiance += NL * sample * brdf_pdf;\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125 * specular_occlusion(NV, ao_factor, a2);\n}\n\nvoid env_sampling_glossy_beckmann(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tmake_orthonormals(N, T, B); /* Generate tangent space */\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\tfloat a, a2; prepare_glossy(roughness, a, a2);\n\n\t/* Precomputation */\n\tfloat NV = max(1e-8, abs(dot(I, N)));\n\tfloat G1_V = G1_Smith_beckmann(NV, a2);\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 H = sample_beckmann(i, a2, N, T, B); /* Microfacet normal */\n\t\tvec3 L = reflect(I, H);\n\t\tfloat NL = dot(N, L);\n\n\t\tif (NL > 0.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat NH = max(1e-8, dot(N, H)); /* cosTheta */\n\t\t\tfloat VH = max(1e-8, -dot(I, H));\n\n\t\t\tfloat pdf = pdf_beckmann_reflect(NH, a2);\n\n\t\t\tvec4 sample = sample_reflect_pdf(L, roughness, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF */\n\t\t\tfloat brdf_pdf = bsdf_beckmann_pdf(a2, NH, NV, NL, VH, G1_V);\n\n\t\t\tout_radiance += NL * sample * brdf_pdf;\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125 * specular_occlusion(NV, ao_factor, a2);\n}\n\nvoid env_sampling_glossy_ashikhmin_shirley(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tmake_orthonormals(N, T, B); /* Generate tangent space */\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\tfloat a, a2; prepare_glossy(roughness, a, a2);\n\n\t/* Precomputation */\n\tfloat NV = max(1e-8, abs(dot(I, N)));\n\tfloat n_x = 2.0 / a2 - 2.0;\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 H = sample_ashikhmin_shirley(i, n_x, N, T, B); /* Microfacet normal */\n\t\tfloat VH = dot(H, -I);\n\t\tif (VH < 0.0) H = -H;\n\t\t/* reflect I on H to get omega_in */\n\t\tvec3 L = I + (2.0 * VH) * H;\n\t\tfloat NL = dot(N, L);\n\n\t\tif (NL > 0.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat NH = max(1e-8, dot(N, H)); /* cosTheta */\n\t\t\tVH = max(1e-8, abs(VH));\n\t\t\tNL = max(1e-8, NL);\n\n\t\t\tfloat pdf = pdf_ashikhmin_shirley_reflect(NH, VH, n_x);\n\n\t\t\tvec4 sample = sample_reflect_pdf(L, roughness, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF */\n\t\t\tfloat brdf_pdf = bsdf_ashikhmin_shirley_pdf(NV, NL, VH);\n\n\t\t\tout_radiance += NL * sample * brdf_pdf;\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125 * specular_occlusion(NV, ao_factor, a2);\n}\n\n/* -------- Utils Functions --------- */\n\nvec3 sample_hemisphere(float nsample, vec3 N, vec3 T, vec3 B)\n{\n\tvec3 Xi = hammersley_3d(nsample);\n\n\tfloat z = Xi.x; /* cos theta */\n\tfloat r = sqrt( 1.0 - z*z ); /* sin theta */\n\tfloat x = r * Xi.y;\n\tfloat y = r * Xi.z;\n\n\tHt = vec3(x, y, z); /* Global variable */\n\n\treturn from_tangent_to_world(Ht, N, T, B);\n}\n\nfloat pdf_hemisphere()\n{\n\treturn 0.5 * M_1_PI;\n}\n\n/* Second order Spherical Harmonics */\n/* http://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/ */\nvec3 spherical_harmonics_L2(vec3 N)\n{\n\tfloat x = -N.x, y = -N.y, z = -N.z;\n        return unfsh0 +\n        unfsh1 * x +\n        unfsh2 * y +\n        unfsh3 * z +\n        unfsh4 * z * x +\n        unfsh5 * y * z +\n        unfsh6 * y * x +\n        unfsh7 * (3.0 * z * z - 1.0) +\n        unfsh8 * (x*x - y*y);\n    }\n    vec3 orig_spherical_harmonics_L2(vec3 N){\n        vec3 sh = vec3(0.0);\n\n\tsh += 0.282095 * unfsh0;\n\n\tsh += -0.488603 * N.z * unfsh1;\n\tsh += 0.488603 * N.y * unfsh2;\n\tsh += -0.488603 * N.x * unfsh3;\n\n\tsh += 1.092548 * N.x * N.z * unfsh4;\n\tsh += -1.092548 * N.z * N.y * unfsh5;\n\tsh += 0.315392 * (3.0 * N.y * N.y - 1.0) * unfsh6;\n\tsh += -1.092548 * N.x * N.y * unfsh7;\n\tsh += 0.546274 * (N.x * N.x - N.z * N.z) * unfsh8;\n\n\treturn sh;\n}\n\n/* -------- BSDF --------- */\n\nfloat bsdf_lambert(float NL)\n{\n\treturn NL * M_1_PI;\n}\n\nfloat bsdf_oren_nayar(float NL, float LV, float NV, float sigma)\n{\n\tfloat div = 1.0 / (M_PI + ((3.0 * M_PI - 4.0) / 6.0) * sigma);\n\n\tfloat A = 1.0 * div;\n\tfloat B = sigma * div;\n\n\tfloat s = LV - NL * NV;\n\tfloat t = mix(1.0, max(NL, NV), step(0.0, s));\n\treturn NL * (A + B * s / t);\n}\n\nfloat bsdf_oren_nayar(vec3 N, vec3 L, vec3 V, float sigma)\n{\n\tfloat NL = max(0.0, dot(N, L));\n\tfloat LV = max(0.0, dot(L, V));\n\tfloat NV = max(1e-8, dot(N, V));\n\treturn bsdf_oren_nayar(NL, LV, NV, sigma);\n}\n\n\n/* -------- Preview Lights --------- */\n\nvoid node_bsdf_diffuse_lights(vec4 color, float roughness, vec3 N, vec3 V, vec4 ambient_light, out vec4 result)\n{\n\tshade_view(V, V); V = -V;\n\n\t/* ambient light */\n\tvec3 accumulator = ambient_light.rgb;\n\n\t/* oren_nayar approximation for ambient */\n\tfloat NV = clamp(dot(N, V), 0.0, 0.999);\n\tfloat fac = 1.0 - pow(1.0 - NV, 1.3);\n\taccumulator *= mix(1.0, 0.78, fac*roughness);\n\n\t/* directional lights */\n\tfor(int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 L = vec3(0,0,0).xyz;\n\t\tvec3 light_color = vec3(0,0,0).rgb;\n\n\t\tfloat NL = saturate(dot(N,L));\n\t\tfloat lambert = bsdf_lambert(NL);\n\t\tfloat oren_nayar = bsdf_oren_nayar(N, L, V, roughness);\n\n\t\taccumulator += light_color * mix(lambert, oren_nayar, roughness)  * M_PI; /* M_PI to make preview brighter */\n\t}\n\n\tresult = vec4(accumulator*color.rgb, 1.0);\n}\n\n\n/* -------- Physical Lights --------- */\n/* from Sebastien Lagarde\n * course_notes_moving_frostbite_to_pbr.pdf */\n\nvoid bsdf_diffuse_sphere_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tfloat l_radius = max(l_areasizex, 0.0001);\n\tfloat costheta = clamp(dot(N, L), -0.999, 0.999);\n\tfloat h = min(l_radius / l_distance , 0.9999);\n\tfloat h2 = h*h;\n\n\tbsdf = 0.0;\n\tif ( costheta * costheta > h2 ) {\n\t\tbsdf = M_PI * h2 * clamp(costheta, 0.0, 1.0);\n\t}\n\telse {\n\t\tfloat sintheta = sqrt(1.0 - costheta * costheta);\n\t\tfloat x = sqrt(1.0 / h2 - 1.0);\n\t\tfloat y = -x * ( costheta / sintheta );\n\t\tfloat sinthetasqrty = sintheta * sqrt(1.0 - y * y);\n\t\tbsdf = (costheta * acos(y) - x * sinthetasqrty ) * h2 + atan(sinthetasqrty / x);\n\t}\n\n\t/* Energy conservation + cycle matching */\n\tbsdf = max(bsdf, 0.0);\n\tbsdf *= M_1_PI;\n\tbsdf *= sphere_energy(l_radius);\n}\n\nvoid bsdf_diffuse_area_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tif (min(l_areasizex, l_areasizey) < 1e-6) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tvec3 pos = V;\n\tV = -normalize(V);\n\tN = -N;\n\n\tvec3 lampx, lampy, lampz;\n\tvec2 halfsize = area_light_prepass(l_mat, l_areasizex, l_areasizey, l_areascale, lampx, lampy, lampz);\n\n\tvec3 points[4];\n\tarea_light_points(l_coords, halfsize, lampx, lampy, points);\n\n\tbsdf = ltc_evaluate(N, V, pos, mat3(1), points);\n\tbsdf *= step(0.0, -dot(L, lampz));\n\n\t/* Energy conservation + cycle matching */\n\tbsdf *= M_1_2PI;\n\tbsdf *= rectangle_energy(l_areasizex, l_areasizey);\n}\nfloat cot(float x){ return cos(x) / sin(x);}\nfloat acot(float x){ return atan(1.0 / x);}\nvoid bsdf_diffuse_sun_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tfloat l_radius = max(l_areasizex, 0.0001);\n\tfloat costheta = clamp(dot(N, L), -0.999, 0.999);\n\tfloat sintheta = sqrt(1.0 - costheta * costheta);\n\tfloat h = 1.0 / l_radius;\n\tfloat h2 = h * h;\n\n\tif (acos(costheta) < atan(h)) {\n\t\tbsdf = M_PI * (1.0 / (1.0 + h2)) * costheta;\n\t}\n\telse {\n\t\tfloat cottheta = costheta / sintheta;\n\t\tfloat x = sqrt(1.0 - h2 * cottheta * cottheta);\n\t\tbsdf = (-h * x + costheta * (M_PI - acos(h * cottheta))) / (1.0 + h2) + atan(x / h);\n\t}\n\t/* Energy conservation + cycle matching */\n\tfloat d_energy = disk_energy(l_radius);\n\tbsdf = max(bsdf, 0.0) * d_energy;\n\t/* TODO Refine this :\n\t * We can try to add contribution of infinitely many point lights at the border of the disk if we know their intensity\n\t * Border intensity should be added to the above uniform disk calculation and should be complementary */\n\t//bsdf += sqrt(1.0 - abs(costheta * costheta * costheta)) * saturate(M_1_2PI - d_energy);\n\tbsdf *= M_1_PI;\n\n}\n\n\n/* -------- Image Based Lighting --------- */\n\nvoid env_sampling_oren_nayar(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tmake_orthonormals(N, T, B); /* Generate tangent space */\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\n\t/* Precomputation */\n\tfloat NV = max(1e-8, abs(dot(I, N)));\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 L = sample_hemisphere(i, N, T, B);\n\t\tvec3 H = normalize(L - I);\n\n\t\tfloat NL = max(0.0, dot(N, L));\n\n\t\tif (NL != 0.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat pdf = pdf_hemisphere();\n\t\t\tvec4 irradiance = sample_probe_pdf(L, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF*/\n\t\t\tfloat LV = max(0.0, dot(L, -I) );\n\t\t\tfloat brdf = bsdf_oren_nayar(NL, LV, NV, roughness);\n\n\t\t\tout_radiance += irradiance * brdf / pdf;\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125;\n}\n\nvoid env_sampling_diffuse(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Lambert */\n\tvec3 lambert_diff = spherical_harmonics_L2(N);\n\n\t/* early out */\n\tif (roughness < 1e-5) {\n\t\tresult = lambert_diff * ao_factor;\n\t\treturn;\n\t}\n\n\t/* Oren Nayar */\n\tvec3 oren_nayar_diff;\n\tenv_sampling_oren_nayar(\n\t\tpbr, viewpos, invviewmat, viewmat,\n\t\tN, T, roughness, ior, sigma,\n\t\ttoon_size, toon_smooth, anisotropy, aniso_rotation,\n\t\tao_factor, oren_nayar_diff);\n\n\tresult = mix(lambert_diff, oren_nayar_diff, roughness);\n\n\t/* Apply ambient occlusion */\n\tresult *= ao_factor;\n}\n/* -------- Utils Functions --------- */\n\n/* From \n * Importance Sampling Microfacet-Based BSDFs with the Distribution of Visible Normals\n * Supplemental Material 2/2 */\nvec3 sample_ggx_aniso(float nsample, float ax, float ay, vec3 N, vec3 T, vec3 B)\n{\n\tvec3 Xi = hammersley_3d(nsample);\n\n\tfloat tmp = sqrt( Xi.x / (1.0 - Xi.x) );\n\n\tfloat x = ax * tmp * Xi.y;\n\tfloat y = ay * tmp * Xi.z;\n\n\tHt = normalize(vec3(x, y, 1.0)); /* Global variable */\n\n\treturn from_tangent_to_world(Ht, N, T, B);\n}\n\nvec3 sample_beckmann_aniso(float nsample, float ax, float ay, vec3 N, vec3 T, vec3 B)\n{\n\tvec3 Xi = hammersley_3d(nsample);\n\n\tfloat tmp = sqrt( -log(Xi.x) );\n\n\tfloat x = ax * tmp * Xi.y;\n\tfloat y = ay * tmp * Xi.z;\n\n\tHt = normalize(vec3(x, y, 1.0)); /* Global variable */\n\n\treturn from_tangent_to_world(Ht, N, T, B);\n}\n\nfloat bsdf_ashikhmin_shirley_sample_first_quadrant(float n_x, float n_y, inout vec3 Xi, out float phi)\n{\n\tphi = atan(sqrt((n_x + 1.0) / (n_y + 1.0)) * (Xi.z / Xi.y));\n\tXi.y = cos(phi);\n\tXi.z = sin(phi);\n\treturn pow(Xi.x, 1.0 / (n_x * Xi.y*Xi.y + n_y * Xi.z*Xi.z + 1.0));\n}\n\nvec3 sample_ashikhmin_shirley_aniso(float nsample, float n_x, float n_y, vec3 N, vec3 T, vec3 B)\n{\n\tvec3 Xi = hammersley_3d(nsample);\n\tfloat phi, z;\n\n\tif(Xi.x < 0.25) { /* first quadrant */\n\t\tXi.x = 4.0 * Xi.x;\n\t\tz = bsdf_ashikhmin_shirley_sample_first_quadrant(n_x, n_y, Xi, phi);\n\t}\n\telse if(Xi.x < 0.5) { /* second quadrant */\n\t\tXi.x = 4.0 * (.5 - Xi.x);\n\t\tz = bsdf_ashikhmin_shirley_sample_first_quadrant(n_x, n_y, Xi, phi);\n\t\tphi = M_PI - phi;\n\t\tXi.y = cos(phi);\n\t\tXi.z = sin(phi);\n\t}\n\telse if(Xi.x < 0.75) { /* third quadrant */\n\t\tXi.x = 4.0 * (Xi.x - 0.5);\n\t\tz = bsdf_ashikhmin_shirley_sample_first_quadrant(n_x, n_y, Xi, phi);\n\t\tphi = M_PI + phi;\n\t\tXi.y = cos(phi);\n\t\tXi.z = sin(phi);\n\t}\n\telse { /* fourth quadrant */\n\t\tXi.x = 4.0 * (1.0 - Xi.x);\n\t\tz = bsdf_ashikhmin_shirley_sample_first_quadrant(n_x, n_y, Xi, phi);\n\t\tphi = M_2PI - phi;\n\t\tXi.y = cos(phi);\n\t\tXi.z = sin(phi);\n\t}\n\n\tfloat r = sqrt( 1.0 - z * z ); /* sin theta */\n\tfloat x = r * Xi.y;\n\tfloat y = r * Xi.z;\n\n\tHt = vec3(x, y, z); /* Global variable */\n\n\treturn from_tangent_to_world(Ht, N, T, B);\n}\n\nfloat D_ggx_aniso_opti(float NH, float XH2, float YH2, float a2, float ax2, float ay2)\n{\n\tfloat tmp = NH*NH + XH2/ax2 + YH2/ay2; /* Distributing NH */\n\treturn M_PI * a2 * tmp*tmp; /* Doing RCP at the end */\n}\n\nfloat D_beckmann_aniso(float NH, float XH, float YH, float a2, float ax, float ay)\n{\n\tfloat sx = -XH / (NH * ax);\n\tfloat sy = -YH / (NH * ay);\n\n\tfloat NH2 = NH * NH;\n\n\treturn exp(-sx*sx - sy*sy) / (M_PI * a2 * NH2 * NH2);\n}\n\nfloat pdf_ggx_aniso(float NH, float XH2, float YH2, float a2, float ax2, float ay2)\n{\n\tfloat D = D_ggx_aniso_opti(NH, XH2, YH2, a2, ax2, ay2);\n\treturn NH / D;\n}\n\nfloat pdf_beckmann_aniso(float NH, float XH, float YH, float a2, float ax, float ay)\n{\n\tfloat D = D_beckmann_aniso(NH, XH, YH, a2, ax, ay);\n\treturn NH / D;\n}\n\nfloat pdf_ashikhmin_shirley_aniso(float NH, float VH, float XH2, float YH2, float n_x, float n_y)\n{\n\tfloat e = (n_x * XH2 + n_y * YH2) / (1.0 - NH*NH);\n\tfloat lobe = pow(NH, e);\n\tfloat norm = sqrt((n_x + 1.0)*(n_y + 1.0)) * 0.125 * M_1_PI;\n\n\treturn norm * lobe / VH;\n}\n\n/* TODO : this could be precomputed */\nvoid prepare_aniso(vec3 N, float roughness, float rotation, inout vec3 T, inout float anisotropy, out float rough_x, out float rough_y)\n{\n\tanisotropy = clamp(anisotropy, -0.99, 0.99);\n\n\tif (anisotropy < 0.0) {\n\t\trough_x = roughness / (1.0 + anisotropy);\n\t\trough_y = roughness * (1.0 + anisotropy);\n\t}\n\telse {\n\t\trough_x = roughness * (1.0 - anisotropy);\n\t\trough_y = roughness / (1.0 - anisotropy);\n\t}\n\n\tT = axis_angle_rotation(T, N, rotation * M_2PI); /* rotate tangent around normal */\n}\n\n/* -------- BSDF --------- */\n\nfloat bsdf_ggx_aniso(vec3 N, vec3 T, vec3 L, vec3 V, float roughness_x, float roughness_y)\n{\n\t/* GGX Spec Anisotropic */\n\t/* A few note about notations :\n\t * I is the cycles term for Incoming Light, Noted L here (light vector)\n\t * Omega (O) is the cycles term for the Outgoing Light, Noted V here (View vector) */\n\tN = normalize(N);\n\tvec3 X = T, Y, Z = N; /* Inside cycles Z=Normal; X=Tangent; Y=Bitangent; */\n\tmake_orthonormals_tangent(Z, X, Y);\n\tvec3 H = normalize(L + V);\n\n\tfloat ax, ax2; prepare_glossy(roughness_x, ax, ax2);\n\tfloat ay, ay2; prepare_glossy(roughness_y, ay, ay2);\n\tfloat a2 = ax*ay;\n\n\tfloat NH = max(1e-8, dot(N, H));\n\tfloat NL = max(1e-8, dot(N, L));\n\tfloat NV = max(1e-8, dot(N, V));\n\tfloat VX2 = pow(dot(V, X), 2.0); /* cosPhiO */\n\tfloat VY2 = pow(dot(V, Y), 2.0); /* sinPhiO */\n\tfloat LX2 = pow(dot(L, X), 2.0); /* cosPhiI */\n\tfloat LY2 = pow(dot(L, Y), 2.0); /* sinPhiI */\n\tfloat XH2 = pow(dot(X, H), 2.0);\n\tfloat YH2 = pow(dot(Y, H), 2.0);\n\n\t/* G_Smith_GGX */\n\tfloat alphaV2 = (VX2 * ax2 + VY2 * ay2) / (VX2 + VY2);\n\tfloat alphaL2 = (LX2 * ax2 + LY2 * ay2) / (LX2 + LY2);\n\tfloat G = G1_Smith_GGX(NV, alphaV2) * G1_Smith_GGX(NL, alphaL2); /* Doing RCP at the end */\n\n\t/* D_GGX */\n\tfloat D = D_ggx_aniso_opti(NH, XH2, YH2, a2, ax2, ay2);\n\n\t/* Denominator is canceled by G1_Smith */\n\t/* bsdf = D * G / (4.0 * NL * NV); /* Reference function */\n\treturn NL / (D * G); /* NL to Fit cycles Equation : line. 345 in bsdf_microfacet.h */\n}\n\n/* This one returns the brdf already divided by the pdf */\nfloat bsdf_ggx_aniso_pdf(float ax2, float ay2, float LX2, float LY2, float NH, float NV, float NL, float VH, float G1_V)\n{\n\tfloat alphaL2 = (LX2 * ax2 + LY2 * ay2) / (LX2 + LY2);\n\tfloat G = G1_V * G1_Smith_GGX(NL, alphaL2);\n\n\t/* Denominator is canceled by G1_Smith\n\t * brdf = D * G / (4.0 * NL * NV)\n\t * pdf = D * NH / (4 * VH) [D canceled later by D in brdf] */\n\t return 4.0 * VH / (NH * G); /* brdf / pdf */\n}\n\nfloat bsdf_beckmann_aniso(vec3 N, vec3 T, vec3 L, vec3 V, float roughness_x, float roughness_y)\n{\n\t/* Beckmann Spec Anisotropic */\n\t/* A few note about notations :\n\t * I is the cycles term for Incoming Light, Noted L here (light vector)\n\t * Omega (O) is the cycles term for the Outgoing Light, Noted V here (View vector) */\n\tN = normalize(N);\n\tvec3 X = T, Y, Z = N; /* Inside cycles Z=Normal; X=Tangent; Y=Bitangent; */\n\tmake_orthonormals_tangent(Z, X, Y);\n\tvec3 H = normalize(L + V);\n\n\tfloat ax, ax2; prepare_glossy(roughness_x, ax, ax2);\n\tfloat ay, ay2; prepare_glossy(roughness_y, ay, ay2);\n\tfloat a2 = ax*ay;\n\n\tfloat NH = max(1e-8, dot(N, H));\n\tfloat NL = max(1e-8, dot(N, L));\n\tfloat NV = max(1e-8, dot(N, V));\n\tfloat VX2 = pow(dot(V, X), 2.0); /* cosPhiO */\n\tfloat VY2 = pow(dot(V, Y), 2.0); /* sinPhiO */\n\tfloat LX2 = pow(dot(L, X), 2.0); /* cosPhiI */\n\tfloat LY2 = pow(dot(L, Y), 2.0); /* sinPhiI */\n\tfloat XH = dot(X, H);\n\tfloat YH = dot(Y, H);\n\n\tfloat alphaV2 = (VX2 * ax2 + VY2 * ay2) / (VX2 + VY2);\n\tfloat alphaL2 = (LX2 * ax2 + LY2 * ay2) / (LX2 + LY2);\n\tfloat G = G1_Smith_beckmann(NV, alphaV2) * G1_Smith_beckmann(NL, alphaL2);\n\n\tfloat D = D_beckmann_aniso(NH, XH, YH, a2, ax, ay);\n\n\treturn NL * D * G * 0.25 / (NL * NV);\n}\n\n/* This one returns the brdf already divided by the pdf */\nfloat bsdf_beckmann_aniso_pdf(float ax2, float ay2, float LX2, float LY2, float NH, float NV, float NL, float VH, float G1_V)\n{\n\tfloat alphaL2 = (LX2 * ax2 + LY2 * ay2) / (LX2 + LY2);\n\tfloat G = G1_V * G1_Smith_beckmann(NL, alphaL2);\n\n\t/* brdf = D * G / (4.0 * NL * NV)\n\t * pdf = D * NH / (4 * VH) [D canceled later by D in brdf] */\n\treturn G * VH / (NH * NV * NL); /* brdf / pdf */\n}\n\nfloat bsdf_ashikhmin_shirley_aniso(vec3 N, vec3 T, vec3 L, vec3 V, float roughness_x, float roughness_y)\n{\n\t/* Ashikmin Shirley Spec Anisotropic */\n\t/* A few note about notations :\n\t * I is the cycles term for Incoming Light, Noted L here (light vector)\n\t * Omega (O) is the cycles term for the Outgoing Light, Noted V here (View vector) */\n\tN = normalize(N);\n\tvec3 X = T, Y, Z = N; /* Inside cycles Z=Normal; X=Tangent; Y=Bitangent; */\n\tmake_orthonormals_tangent(Z, X, Y);\n\tvec3 H = normalize(L + V);\n\n\tfloat ax, ax2; prepare_glossy(roughness_x, ax, ax2);\n\tfloat ay, ay2; prepare_glossy(roughness_y, ay, ay2);\n\tfloat a2 = ax*ay;\n\tfloat n_x = 2.0 / ax2 - 2.0;\n\tfloat n_y = 2.0 / ay2 - 2.0;\n\n\tfloat NL = max(dot(N, L), 1e-6);\n\tfloat NV = max(dot(N, V), 1e-6);\n\tfloat NH = max(dot(N, H), 1e-6);\n\tfloat VH = max(abs(dot(V, H)), 1e-6);\n\tfloat XH2 = max(pow(dot(X, H), 2.0), 1e-6);\n\tfloat YH2 = max(pow(dot(Y, H), 2.0), 1e-6);\n\n\tfloat pump = 1.0 / max(1e-6, VH * max(NL, NV));\n\n\tfloat e = max(n_x * XH2 + n_y * YH2, 1e-4) / max(1.0 - NH*NH, 1e-4); /* Precision problem here */\n\tfloat lobe = pow(NH, e);\n\tfloat norm = sqrt((n_x + 1.0)*(n_y + 1.0)) * 0.125 * M_1_PI;\n\n\treturn NL * norm * lobe * pump;\n}\n\n/* -------- Preview Lights --------- */\n\nvoid node_bsdf_anisotropic_lights(vec4 color, float roughness, float anisotropy, float rotation, vec3 N, vec3 T, vec3 V, vec4 ambient_light, out vec4 result)\n{\n\tN = normalize(N);\n\tshade_view(V, V); V = -V;\n\n\tfloat rough_x, rough_y;\n\tprepare_aniso(N, roughness, rotation, T, anisotropy, rough_x, rough_y);\n\tvec3 accumulator = ambient_light.rgb;\n\n\tif (max(rough_x, rough_y) <= 1e-4) {\n\t\tresult = vec4(accumulator * color.rgb, 1.0); //Should take roughness into account -> waiting LUT\n\t\treturn;\n\t}\n\n\t/* directional lights */\n\tfor(int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 L = vec3(0,0,0).xyz;\n\t\tvec3 light_color = vec3(0,0,0).rgb;\n\n\t\taccumulator += light_color * bsdf_ggx_aniso(N, T, L, V, rough_x, rough_y);\n\t}\n\n\tresult = vec4(accumulator * color.rgb, 1.0);\n}\n\n\n/* -------- Physical Lights --------- */\n\n/* ANISOTROPIC GGX */\n\nvoid bsdf_anisotropic_ggx_sphere_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\n\tfloat rough_x, rough_y;\n\tprepare_aniso(N, roughness, aniso_rotation, T, anisotropy, rough_x, rough_y);\n\n\tif (max(rough_x, rough_y) < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tfloat l_radius = l_areasizex;\n\n\tvec3 R = reflect(V, N);\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point(l_radius, 0.0, vec3(0.0), l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_ggx_aniso(N, T, L, V, rough_x, rough_y);\n\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= sphere_energy(l_radius) * max(l_radius * l_radius, 1e-16); /* l_radius is already inside energy_conservation */\n\tbsdf *= M_PI; /* XXX : !!! Very Empirical, Fit cycles power */\n}\n\nvoid bsdf_anisotropic_ggx_area_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tif (max(l_areasizex, l_areasizey) < 1e-6) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\n\tfloat rough_x, rough_y;\n\tprepare_aniso(N, roughness, aniso_rotation, T, anisotropy, rough_x, rough_y);\n\n\tl_areasizex *= l_areascale.x;\n\tl_areasizey *= l_areascale.y;\n\n\t/* Used later for Masking : Use the real Light Vector */\n\tvec3 lampz = normalize( (l_mat * vec4(0.0,0.0,1.0,0.0) ).xyz );\n\tfloat masking = max(dot( normalize(-L), lampz), 0.0);\n\n\tvec3 R = reflect(V, N);\n\n\tfloat energy_conservation = 1.0;\n\tfloat max_size = max(l_areasizex, l_areasizey);\n\tfloat min_size = min(l_areasizex, l_areasizey);\n\tvec3 lampVec = (l_areasizex > l_areasizey) ? normalize( (l_mat * vec4(1.0,0.0,0.0,0.0) ).xyz ) : normalize( (l_mat * vec4(0.0,1.0,0.0,0.0) ).xyz );\n\n\tmost_representative_point(min_size/2.0, max_size-min_size, lampVec, l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_ggx_aniso(N, T, L, V, rough_x, rough_y);\n\n\t/* energy_conservation */\n\tfloat LineAngle = clamp( (max_size-min_size) / l_distance, 0.0, 1.0);\n\tfloat energy_conservation_line = energy_conservation * ( roughness / clamp(roughness + 0.5 * LineAngle, 0.0, 1.1));\n\n\t/* XXX : Empirical modification for low roughness matching */\n\tfloat energy_conservation_mod = energy_conservation * (1.0 + roughness) / ( max_size/min_size );\n\tenergy_conservation = mix(energy_conservation_mod, energy_conservation_line, min(roughness/0.3, 0.9*(1.1-roughness)/0.1));\n\n\t/* As we represent the Area Light by a tube light we must use a custom energy conservation */\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= masking;\n\tbsdf *= 23.2;  /* XXX : !!! Very Empirical, Fit cycles power */\n}\n\nvoid bsdf_anisotropic_ggx_sun_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tfloat rough_x, rough_y;\n\tprepare_aniso(N, roughness, aniso_rotation, T, anisotropy, rough_x, rough_y);\n\n\t/* Correct ligth shape but uniform intensity\n\t * Does not take into account the division by costheta^3 */\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tvec3 R = reflect(V, N);\n\n\tfloat l_radius = l_areasizex;\n\tfloat angle = atan(l_radius);\n\n\tfloat costheta = dot(-L, R);\n\tfloat cosangle = cos(angle);\n\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point_disk(l_radius, 1.0, R, L, roughness, energy_conservation);\n\n\tbsdf = bsdf_ggx_aniso(N, T, L, V, rough_x, rough_y);\n\tbsdf *= energy_conservation;\n}\n\n/* ANISOTROPIC BECKMANN */\n\nvoid bsdf_anisotropic_beckmann_sphere_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\n\tfloat rough_x, rough_y;\n\tprepare_aniso(N, roughness, aniso_rotation, T, anisotropy, rough_x, rough_y);\n\n\tif (max(rough_x, rough_y) < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tfloat l_radius = l_areasizex;\n\n\tvec3 R = reflect(V, N);\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point(l_radius, 0.0, vec3(0.0), l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_beckmann_aniso(N, T, L, V, rough_x, rough_y);\n\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= sphere_energy(l_radius) * max(l_radius * l_radius, 1e-16); /* l_radius is already inside energy_conservation */\n\tbsdf *= M_PI; /* XXX : !!! Very Empirical, Fit cycles power */\n}\n\nvoid bsdf_anisotropic_beckmann_area_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tif (max(l_areasizex, l_areasizey) < 1e-6) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tfloat rough_x, rough_y;\n\tprepare_aniso(N, roughness, aniso_rotation, T, anisotropy, rough_x, rough_y);\n\n\tl_areasizex *= l_areascale.x;\n\tl_areasizey *= l_areascale.y;\n\n\t/* Used later for Masking : Use the real Light Vector */\n\tvec3 lampz = normalize( (l_mat * vec4(0.0,0.0,1.0,0.0) ).xyz );\n\tfloat masking = max(dot( normalize(-L), lampz), 0.0);\n\n\tvec3 R = reflect(V, N);\n\n\tfloat energy_conservation = 1.0;\n\tfloat max_size = max(l_areasizex, l_areasizey);\n\tfloat min_size = min(l_areasizex, l_areasizey);\n\tvec3 lampVec = (l_areasizex > l_areasizey) ? normalize( (l_mat * vec4(1.0,0.0,0.0,0.0) ).xyz ) : normalize( (l_mat * vec4(0.0,1.0,0.0,0.0) ).xyz );\n\n\tmost_representative_point(min_size/2.0, max_size-min_size, lampVec, l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_beckmann_aniso(N, T, L, V, rough_x, rough_y);\n\n\t/* energy_conservation */\n\tfloat LineAngle = clamp( (max_size-min_size) / l_distance, 0.0, 1.0);\n\tfloat energy_conservation_line = energy_conservation * ( roughness / clamp(roughness + 0.5 * LineAngle, 0.0, 1.1));\n\n\t/* XXX : Empirical modification for low roughness matching */\n\tfloat energy_conservation_mod = energy_conservation * (1.0 + roughness) / ( max_size/min_size );\n\tenergy_conservation = mix(energy_conservation_mod, energy_conservation_line, min(roughness/0.3, 0.9*(1.1-roughness)/0.1));\n\n\t/* As we represent the Area Light by a tube light we must use a custom energy conservation */\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= masking;\n\tbsdf *= 23.2;  /* XXX : !!! Very Empirical, Fit cycles power */\n}\n\nvoid bsdf_anisotropic_beckmann_sun_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tfloat rough_x, rough_y;\n\tprepare_aniso(N, roughness, aniso_rotation, T, anisotropy, rough_x, rough_y);\n\n\t/* Correct ligth shape but uniform intensity\n\t * Does not take into account the division by costheta^3 */\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tvec3 R = reflect(V, N);\n\n\tfloat l_radius = l_areasizex;\n\tfloat angle = atan(l_radius);\n\n\tfloat costheta = dot(-L, R);\n\tfloat cosangle = cos(angle);\n\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point_disk(l_radius, 1.0, R, L, roughness, energy_conservation);\n\n\tbsdf = bsdf_beckmann_aniso(N, T, L, V, rough_x, rough_y);\n\tbsdf *= energy_conservation;\n}\n\n/* ANISOTROPIC ASHIKHMIN SHIRLEY */\n\nvoid bsdf_anisotropic_ashikhmin_shirley_sphere_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\n\tfloat rough_x, rough_y;\n\tprepare_aniso(N, roughness, aniso_rotation, T, anisotropy, rough_x, rough_y);\n\n\tif (max(rough_x, rough_y) < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tfloat l_radius = l_areasizex;\n\n\tvec3 R = reflect(V, N);\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point(l_radius, 0.0, vec3(0.0), l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_ashikhmin_shirley_aniso(N, T, L, V, rough_x, rough_y);\n\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= sphere_energy(l_radius) * max(l_radius * l_radius, 1e-16); /* l_radius is already inside energy_conservation */\n\tbsdf *= M_PI; /* XXX : !!! Very Empirical, Fit cycles power */\n}\n\nvoid bsdf_anisotropic_ashikhmin_shirley_area_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tif (max(l_areasizex, l_areasizey) < 1e-6) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tfloat rough_x, rough_y;\n\tprepare_aniso(N, roughness, aniso_rotation, T, anisotropy, rough_x, rough_y);\n\n\tl_areasizex *= l_areascale.x;\n\tl_areasizey *= l_areascale.y;\n\n\t/* Used later for Masking : Use the real Light Vector */\n\tvec3 lampz = normalize( (l_mat * vec4(0.0,0.0,1.0,0.0) ).xyz );\n\tfloat masking = max(dot( normalize(-L), lampz), 0.0);\n\n\tvec3 R = reflect(V, N);\n\n\tfloat energy_conservation = 1.0;\n\tfloat max_size = max(l_areasizex, l_areasizey);\n\tfloat min_size = min(l_areasizex, l_areasizey);\n\tvec3 lampVec = (l_areasizex > l_areasizey) ? normalize( (l_mat * vec4(1.0,0.0,0.0,0.0) ).xyz ) : normalize( (l_mat * vec4(0.0,1.0,0.0,0.0) ).xyz );\n\n\tmost_representative_point(min_size/2.0, max_size-min_size, lampVec, l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_ashikhmin_shirley_aniso(N, T, L, V, rough_x, rough_y);\n\n\t/* energy_conservation */\n\tfloat LineAngle = clamp( (max_size-min_size) / l_distance, 0.0, 1.0);\n\tfloat energy_conservation_line = energy_conservation * ( roughness / clamp(roughness + 0.5 * LineAngle, 0.0, 1.1));\n\n\t/* XXX : Empirical modification for low roughness matching */\n\tfloat energy_conservation_mod = energy_conservation * (1.0 + roughness) / ( max_size/min_size );\n\tenergy_conservation = mix(energy_conservation_mod, energy_conservation_line, min(roughness/0.3, 0.9*(1.1-roughness)/0.1));\n\n\t/* As we represent the Area Light by a tube light we must use a custom energy conservation */\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= masking;\n\tbsdf *= 23.2;  /* XXX : !!! Very Empirical, Fit cycles power */\n}\n\nvoid bsdf_anisotropic_ashikhmin_shirley_sun_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tfloat rough_x, rough_y;\n\tprepare_aniso(N, roughness, aniso_rotation, T, anisotropy, rough_x, rough_y);\n\n\t/* Correct ligth shape but uniform intensity\n\t * Does not take into account the division by costheta^3 */\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tvec3 R = reflect(V, N);\n\n\tfloat l_radius = l_areasizex;\n\tfloat angle = atan(l_radius);\n\n\tfloat costheta = dot(-L, R);\n\tfloat cosangle = cos(angle);\n\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point_disk(l_radius, 1.0, R, L, roughness, energy_conservation);\n\n\tbsdf = bsdf_ashikhmin_shirley_aniso(N, T, L, V, rough_x, rough_y);\n\tbsdf *= energy_conservation;\n}\n\n/* -------- Image Based Lighting --------- */\n\nvoid env_sampling_aniso_ggx(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tfloat rough_x, rough_y; prepare_aniso(N, roughness, -aniso_rotation, T, anisotropy, rough_x, rough_y);\n\tfloat ax, ax2; prepare_glossy(rough_x, ax, ax2);\n\tfloat ay, ay2; prepare_glossy(rough_y, ay, ay2);\n\tmake_orthonormals_tangent(N, T, B);\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\n\t/* Precomputation */\n\tfloat max_a = min(1.0, max(ax, ay));\n\tfloat min_a = min(1.0, min(ax, ay));\n\tfloat a2 = ax*ay;\n\tfloat NV = max(1e-8, abs(dot(I, N)));\n\tfloat VX2 = pow(dot(I, T), 2.0); /* cosPhiO */\n\tfloat VY2 = pow(dot(I, B), 2.0); /* sinPhiO */\n\tfloat alphaV2 = (VX2 * ax2 + VY2 * ay2) / (VX2 + VY2);\n\tfloat G1_V = G1_Smith_GGX(NV, alphaV2);\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 H = sample_ggx_aniso(i, ax, ay, N, T, B); /* Microfacet normal */\n\t\tvec3 L = reflect(I, H);\n\t\tfloat NL = dot(N, L);\n\n\t\tif (NL > 0.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat NH = Ht.z;\n\t\t\tfloat XH2 = Ht.x * Ht.x;\n\t\t\tfloat YH2 = Ht.y * Ht.y;\n\n\t\t\tfloat pdf = pdf_ggx_aniso(NH, XH2, YH2, a2, ax, ay);\n\n\t\t\tvec4 sample = sample_reflect_pdf(L, roughness, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF */\n\t\t\tfloat VH = max(1e-8, -dot(I, H));\n\t\t\tfloat LX2 = pow(dot(L, T), 2.0); /* cosPhiI */\n\t\t\tfloat LY2 = pow(dot(L, B), 2.0); /* sinPhiI */\n\t\t\tfloat brdf_pdf = bsdf_ggx_aniso_pdf(ax2, ay2, LX2, LY2, NH, NV, NL, VH, G1_V);\n\n\t\t\tout_radiance += NL * sample * brdf_pdf;\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125 * specular_occlusion(NV, ao_factor, a2);\n}\n\nvoid env_sampling_aniso_beckmann(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tfloat rough_x, rough_y; prepare_aniso(N, roughness, -aniso_rotation, T, anisotropy, rough_x, rough_y);\n\tfloat ax, ax2; prepare_glossy(rough_x, ax, ax2);\n\tfloat ay, ay2; prepare_glossy(rough_y, ay, ay2);\n\tmake_orthonormals_tangent(N, T, B);\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\n\t/* Precomputation */\n\tfloat a2 = ax*ay;\n\tfloat NV = max(1e-8, abs(dot(I, N)));\n\tfloat VX2 = pow(dot(I, T), 2.0); /* cosPhiO */\n\tfloat VY2 = pow(dot(I, B), 2.0); /* sinPhiO */\n\tfloat alphaV2 = (VX2 * ax2 + VY2 * ay2) / (VX2 + VY2);\n\tfloat G1_V = G1_Smith_beckmann(NV, alphaV2);\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 H = sample_beckmann_aniso(i, ax, ay, N, T, B); /* Microfacet normal */\n\t\tvec3 L = reflect(I, H);\n\t\tfloat NL = dot(N, L);\n\n\t\tif (NL > 0.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat NH = Ht.z;\n\t\t\tfloat XH = Ht.x;\n\t\t\tfloat YH = Ht.y;\n\n\t\t\tfloat pdf = pdf_beckmann_aniso(NH, XH, YH, a2, ax, ay);\n\n\t\t\tvec4 sample = sample_reflect_pdf(L, roughness, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF */\n\t\t\tfloat VH = max(1e-8, -dot(I, H));\n\t\t\tfloat LX2 = pow(dot(L, T), 2.0); /* cosPhiI */\n\t\t\tfloat LY2 = pow(dot(L, B), 2.0); /* sinPhiI */\n\t\t\tfloat brdf_pdf = bsdf_beckmann_aniso_pdf(ax2, ay2, LX2, LY2, NH, NV, NL, VH, G1_V);\n\n\t\t\tout_radiance += NL * sample * brdf_pdf;\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125 * specular_occlusion(NV, ao_factor, a2);\n}\n\nvoid env_sampling_aniso_ashikhmin_shirley(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tfloat rough_x, rough_y; prepare_aniso(N, roughness, -aniso_rotation, T, anisotropy, rough_x, rough_y);\n\tfloat ax, ax2; prepare_glossy(rough_x, ax, ax2);\n\tfloat ay, ay2; prepare_glossy(rough_y, ay, ay2);\n\tmake_orthonormals_tangent(N, T, B);\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\n\t/* Precomputation */\n\tfloat a2 = ax*ay;\n\tfloat NV = max(1e-8, abs(dot(I, N)));\n\tfloat VX2 = pow(dot(I, T), 2.0); /* cosPhiO */\n\tfloat VY2 = pow(dot(I, B), 2.0); /* sinPhiO */\n\n\tfloat n_x = 2.0 / ax2 - 2.0;\n\tfloat n_y = 2.0 / ay2 - 2.0;\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 H = sample_ashikhmin_shirley_aniso(i, n_x, n_y, N, T, B); /* Microfacet normal */\n\t\tfloat VH = dot(H, -I);\n\t\tif (VH < 0.0) H = -H;\n\t\t/* reflect I on H to get omega_in */\n\t\tvec3 L = I + (2.0 * VH) * H;\n\t\tfloat NL = dot(N, L);\n\n\t\tif (NL > 0.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat NH = Ht.z;\n\t\t\tfloat XH2 = Ht.x * Ht.x;\n\t\t\tfloat YH2 = Ht.y * Ht.y;\n\t\t\tfloat VH = max(1e-8, -dot(I, H));\n\n\t\t\tfloat pdf = pdf_ashikhmin_shirley_aniso(NH, VH, XH2, YH2, n_x, n_y);\n\n\t\t\tvec4 sample = sample_reflect_pdf(L, roughness, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF */\n\t\t\tfloat brdf_pdf = bsdf_ashikhmin_shirley_pdf(NV, NL, VH); /* Same as isotropic */\n\n\t\t\tout_radiance += NL * sample * brdf_pdf;\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125 * specular_occlusion(NV, ao_factor, a2);\n}/* -------- Utils Functions --------- */\n\nvoid prepare_velvet(float sigma, out float m_1_sig2)\n{\n\tsigma = max(sigma, 1e-2);\n\tm_1_sig2 = 1.0 / (sigma * sigma);\n}\n\n/* -------- BSDF --------- */\n\nfloat bsdf_ashikhmin_velvet(float NL, float NV, float NH, float VH, float m_1_sig2)\n{\n\tfloat NHdivVH = NH / VH;\n\tNHdivVH = max(NHdivVH, 1e-5);\n\n\tfloat fac1 = 2.0 * abs(NHdivVH * NV);\n\tfloat fac2 = 2.0 * abs(NHdivVH * NL);\n\n\tfloat sinNH2 = 1.0 - NH * NH;\n\tfloat sinNH4 = sinNH2 * sinNH2;\n\tfloat cotan2 = (NH * NH) / sinNH2;\n\n\tfloat D = exp(-cotan2 * m_1_sig2) * m_1_sig2 * M_1_PI / sinNH4;\n\tfloat G = min(1.0, min(fac1, fac2)); // TODO: derive G from D analytically\n\n\treturn 0.25 * (D * G) / NV;\n}\n\nfloat bsdf_ashikhmin_velvet(vec3 N, vec3 L, vec3 V, float m_1_sig2)\n{\n\tvec3 H = normalize(L + V);\n\n\tfloat NL = max(dot(N, L), 0.0);\n\tfloat NV = max(dot(N, V), 1e-5);\n\tfloat NH = dot(N, H);\n\tfloat VH = max(abs(dot(V, H)), 1e-5);\n\n\tif(abs(NH) < 1.0-1e-5) {\n\t\treturn bsdf_ashikhmin_velvet(NL, NV, NH, VH, m_1_sig2);\n\t}\n\n\treturn 0.0;\n}\n\n/* -------- Preview Lights --------- */\n\nvoid node_bsdf_velvet_lights(vec4 color, float sigma, vec3 N, vec3 V, vec4 ambient_light, out vec4 result)\n{\n\tshade_view(V, V); V = -V;\n\tfloat m_1_sig2; prepare_velvet(sigma, m_1_sig2);\n\n\t/* ambient light */\n\tvec3 accumulator = ambient_light.rgb;\n\n\t/* directional lights */\n\tfor(int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 L = vec3(0,0,0).xyz;\n\t\tvec3 light_color = vec3(0,0,0).rgb;\n\n\t\taccumulator += light_color * bsdf_ashikhmin_velvet(N, L, V, m_1_sig2);\n\t}\n\n\tresult = vec4(accumulator * color.rgb, 1.0);\n}\n\n/* -------- Physical Lights --------- */\n\n/* VELVET */\n\nvoid bsdf_velvet_sphere_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                          float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                          float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                          out float bsdf)\n{\n\tfloat m_1_sig2; prepare_velvet(sigma, m_1_sig2);\n\n\tbsdf = bsdf_ashikhmin_velvet(N, L, V, m_1_sig2);\n\n\t/* Energy conservation + cycle matching */\n\tbsdf *= 8.0 / (l_distance * l_distance);\n\t/* bsdf *= sphere_energy(l_radius); Velvet is using only point lights for now */\n}\n\nvoid bsdf_velvet_area_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                        float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                        float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                        out float bsdf)\n{\n\tif (max(l_areasizex, l_areasizey) < 1e-6) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tfloat m_1_sig2; prepare_velvet(sigma, m_1_sig2);\n\n\tbsdf = bsdf_ashikhmin_velvet(N, L, V, m_1_sig2);\n\n\t/* Energy conservation + cycle matching */\n\tbsdf *= 8.0 / (l_distance * l_distance);\n\n\t/* l_areasizex *= scale.x;\n\t * l_areasizey *= scale.y;\n\t * bsdf *= rectangle_energy(l_areasizex, l_areasizey); Velvet is using only point lights for now*/\n}\n\nvoid bsdf_velvet_sun_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                       float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                       float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                       out float bsdf)\n{\n\tfloat m_1_sig2; prepare_velvet(sigma, m_1_sig2);\n\n\tbsdf = bsdf_ashikhmin_velvet(N, L, V, m_1_sig2);\n}\n\n\n/* -------- Image Based Lighting --------- */\n\nvoid env_sampling_velvet(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tmake_orthonormals(N, T, B); /* Generate tangent space */\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\n\t/* Precomputation */\n\tfloat m_1_sig2; prepare_velvet(sigma, m_1_sig2);\n\tfloat NV = max(1e-5, abs(dot(I, N)));\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 L = sample_hemisphere(i, N, T, B);\n\t\tvec3 H = normalize(L - I);\n\n\t\tfloat NL = dot(N, L);\n\t\tfloat NH = dot(N, H); /* cosTheta */\n\n\t\tif (NL > 0.0 && abs(NH) < 1.0-1e-5) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat pdf = pdf_hemisphere();\n\t\t\tvec4 irradiance = sample_probe_pdf(L, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF*/\n\t\t\tfloat VH = max(abs(dot(I, H)), 1e-5);\n\t\t\tfloat brdf = bsdf_ashikhmin_velvet(NL, NV, NH, VH, m_1_sig2);\n\n\t\t\tout_radiance += irradiance * brdf / pdf;\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125 * ao_factor;\n}\n/* -------- Utils Functions --------- */\n\nvec3 sample_transparent()\n{\n#ifndef PLANAR_PROBE\n\tvec4 sample = textureCube(unfprobe, I);\n#else\n\tvec4 sample = texture2D(unfrefract, refpos.xy);\n#endif\n\tsrgb_to_linearrgb(sample, sample);\n\treturn sample.rgb;\n}\n\n/* -------- BSDF --------- */\n\n/* -------- Preview Lights --------- */\n\n/* -------- Physical Lights --------- */\n\n/* -------- Image Based Lighting --------- */\n\nvoid env_sampling_transparent(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tresult = sample_transparent();\n}\n/* -------- Utils Functions --------- */\n\nfloat pdf_ggx_refract(float Ht2, float NH, float NV, float VH, float LH, float G1_V, float a2, float eta)\n{\n\treturn (VH * abs(LH)) * (eta*eta) * a2 * G1_V / (Ht2 * NV * D_ggx_opti(NH, a2));\n}\n\nfloat pdf_beckmann_refract(float Ht2, float NH, float NV, float VH, float LH, float G1_V, float a2, float eta)\n{\n\t/* pdf = (VH * abs(LH)) * (ior*ior) * D * G(V) / (Ht2 * NV) */\n\treturn (VH * abs(LH)) * (eta*eta) * D_beckman(NH, a2) * G1_V / (Ht2 * NV);\n}\n\n/* -------- BSDF --------- */\n\nfloat bsdf_ggx_refract(float Ht2, float NH, float NL, float NV, float VH, float LH, float a2, float eta)\n{\n\tfloat G = G1_Smith_GGX(NV, a2) * G1_Smith_GGX(NL, a2);\n\tfloat D = D_ggx_opti(NH, a2); /* Doing RCP and mul a2 at the end */\n\n\t/* bsdf = abs(LH * VH) * (eta*eta) * G * D / (NV * Ht2); /* Reference function */\n\treturn abs(LH * VH) * (NV * NL * 4.0) * a2 * (eta*eta) / (D * G * NV * Ht2); /* Balancing the adjustments made in G1_Smith with (NV * NL * 4.0)*/\n}\n\nfloat bsdf_ggx_refract(vec3 N, vec3 L, vec3 V, float eta, float roughness)\n{\n\t/* GGX Spec Isotropic Transmited */\n\tfloat a, a2; prepare_glossy(roughness, a, a2);\n\n\tvec3 ht = -(eta * L + V);\n\tvec3 Ht = normalize(ht);\n\tfloat Ht2 = dot(ht, ht);\n\tfloat NH = dot(N, Ht);\n\tfloat NL = dot(N, -L);\n\tfloat NV = dot(N, V);\n\tfloat VH = dot(V, Ht);\n\tfloat LH = dot(-L, Ht);\n\n\treturn bsdf_ggx_refract(Ht2, NH, NL, NV, VH, LH, a2, eta);\n}\n\n/* This one returns the brdf already divided by the pdf */\nfloat bsdf_ggx_refract_pdf(float a2, float LH, float NL, float VH)\n{\n\tfloat G1_L = NL * 2.0 / G1_Smith_GGX(NL, a2); /* Balancing the adjustments made in G1_Smith */\n\n\t/* brdf = abs(VH*LH) * (ior*ior) * D * G(V) * G(L) / (Ht2 * NV)\n\t * pdf = (VH * abs(LH)) * (ior*ior) * D * G(V) / (Ht2 * NV) */\n\treturn G1_L * abs(VH*LH) / (VH * abs(LH));\n}\n\nfloat bsdf_beckmann_refract(float Ht2, float NH, float NL, float NV, float VH, float LH, float a, float a2, float eta)\n{\n\tfloat G = G1_Smith_beckmann(NV, a2) * G1_Smith_beckmann(NL, a2);\n\tfloat D = D_beckman(NH, a2);\n\n\treturn abs(LH * VH) * D * G * (eta*eta) / (NV * Ht2);\n}\n\nfloat bsdf_beckmann_refract(vec3 N, vec3 L, vec3 V, float eta, float roughness)\n{\n\tfloat a, a2; prepare_glossy(roughness, a, a2);\n\n\tvec3 ht = -(eta * L + V);\n\tvec3 Ht = normalize(ht);\n\tfloat Ht2 = dot(ht, ht);\n\tfloat NH = dot(N, Ht);\n\tfloat NL = dot(N, -L);\n\tfloat NV = dot(N, V);\n\tfloat VH = dot(V, Ht);\n\tfloat LH = dot(-L, Ht);\n\n\treturn bsdf_beckmann_refract(Ht2, NH, NL, NV, VH, LH, a, a2, eta);\n}\n\n/* This one returns the brdf already divided by the pdf */\nfloat bsdf_beckmann_refract_pdf(float a2, float LH, float NL, float VH)\n{\n\t/* brdf = abs(VH*LH) * (ior*ior) * D * G(V) * G(L) / (Ht2 * NV)\n\t * pdf = (VH * abs(LH)) * (ior*ior) * D * G(V) / (Ht2 * NV) */\n\treturn G1_Smith_beckmann(NL, a2) * abs(VH*LH) / (VH * abs(LH));\n}\n\n/* -------- Preview Lights --------- */\n\nvoid node_bsdf_refraction_lights(vec4 color, float roughness, float ior, vec3 N, vec3 V, vec4 ambient_light, out vec4 result)\n{\n\tnode_bsdf_glossy_lights(color, roughness, N, V, ambient_light, result);\n}\n\n/* -------- Physical Lights --------- */\n\n/* REFRACT SHARP */\n\nvoid bsdf_refract_sharp_sphere_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                                 float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                                 float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                                 out float bsdf)\n{\n\tfloat l_radius = l_areasizex;\n\tL = l_distance * L;\n\tvec3 R = -refract(-V, N, (gl_FrontFacing) ? 1.0/ior : ior);\n\n\tvec3 P = line_aligned_plane_intersect(vec3(0.0), R, L);\n\tbsdf = (distance_squared(P, L) < l_radius * l_radius) ? 1.0 : 0.0;\n\n\t/* Energy conservation + cycle matching */\n\tbsdf *= sphere_energy(l_radius);\n}\n\nvoid bsdf_refract_sharp_area_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                               float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                               float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                               out float bsdf)\n{\n\tif (max(l_areasizex, l_areasizey) < 1e-6) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tL = l_distance * L;\n\n\tvec3 lampx, lampy, lampz;\n\tvec2 halfsize = area_light_prepass(l_mat, l_areasizex, l_areasizey, l_areascale, lampx, lampy, lampz);\n\n\t/* Find the intersection point E between the reflection vector and the light plane */\n\tfloat eta = (gl_FrontFacing) ? ior : 1.0/ior;\n\tvec3 R = refract(-V, N, 1.0/eta);\n\tvec3 E = line_plane_intersect(vec3(0.0), R, L, lampz);\n\n\t/* Project it onto the light plane */\n\tvec3 projection = E - L;\n\tfloat A = dot(lampx, projection);\n\tfloat B = dot(lampy, projection);\n\n\tbsdf = (abs(A) < halfsize.x && abs(B) < halfsize.y) ? 1.0 : 0.0;\n\n\t/* Masking */\n\tbsdf *= (dot(-L, lampz) > 0.0) ? 1.0 : 0.0;\n\tbsdf *= (dot(-R, lampz) > 0.0) ? 1.0 : 0.0;\n\n\t/* Energy conservation + cycle matching */\n\tbsdf *= rectangle_energy(l_areasizex, l_areasizey);\n}\n\nvoid bsdf_refract_sharp_sun_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                              float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                              float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                              out float bsdf)\n{\n\tfloat eta = (gl_FrontFacing) ? ior : 1.0/ior;\n\tvec3 R = refract(-V, N, 1.0/eta);\n\n\tfloat l_radius = l_areasizex;\n\tfloat angle = atan(l_radius);\n\n\tfloat costheta = dot(L, R);\n\tfloat cosangle = cos(angle);\n\n\tbsdf = (costheta > cosangle) ? 1.0 : 0.0;\n\n\t/* Energy conservation + cycle matching */\n\tbsdf *= disk_energy(l_radius);\n\tbsdf /= costheta * costheta * costheta;\n\tbsdf *= M_PI;\n}\n\n/* REFRACT GGX */\n\nvoid bsdf_refract_ggx_sphere_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                               float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                               float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                               out float bsdf)\n{\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tfloat l_radius = l_areasizex;\n\n\tshade_view(V, V);\n\tfloat eta = (gl_FrontFacing) ? ior : 1.0/ior;\n\tvec3 R = refract(-V, N, 1.0/eta);\n\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point(l_radius, 0.0, vec3(0.0), l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_ggx_refract(N, L, V, eta, roughness);\n\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= sphere_energy(l_radius) * max(l_radius * l_radius, 1e-16); /* l_radius is already inside energy_conservation */\n\tbsdf *= M_PI; /* XXX : !!! Very Empirical, Fit cycles power */\n}\n\nvoid bsdf_refract_ggx_area_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                             float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                             float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                             out float bsdf)\n{\n\tif (min(l_areasizex, l_areasizey) < 1e-6) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tl_areasizex *= l_areascale.x;\n\tl_areasizey *= l_areascale.y;\n\n\t/* Used later for Masking : Use the real Light Vector */\n\tvec3 lampz = normalize( (l_mat * vec4(0.0,0.0,1.0,0.0) ).xyz ); //lamp projection axis\n\tfloat masking = max(dot( normalize(-L), lampz), 0.0);\n\n\tfloat max_size = max(l_areasizex, l_areasizey);\n\tfloat min_size = min(l_areasizex, l_areasizey);\n\tvec3 lampVec = (l_areasizex > l_areasizey) ? normalize( (l_mat * vec4(1.0,0.0,0.0,0.0) ).xyz ) : normalize( (l_mat * vec4(0.0,1.0,0.0,0.0) ).xyz );\n\n\n\tfloat eta = (gl_FrontFacing) ? ior : 1.0/ior;\n\tvec3 R = refract(-V, N, 1.0/eta);\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point(min_size/2.0, max_size-min_size, lampVec, l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_ggx_refract(N, L, V, eta, roughness);\n\n\t/* energy_conservation */\n\tfloat LineAngle = clamp( (max_size-min_size) / l_distance, 0.0, 1.0);\n\tfloat energy_conservation_line = energy_conservation * ( roughness / clamp(roughness + 0.5 * LineAngle, 0.0, 1.1));\n\n\t/* XXX : Empirical modification for low roughness matching */\n\tfloat energy_conservation_mod = energy_conservation * (1.0 + roughness) / ( max_size/min_size );\n\tenergy_conservation = mix(energy_conservation_mod, energy_conservation_line, min(roughness/0.3, 0.9*(1.1-roughness)/0.1));\n\n\t/* As we represent the Area Light by a tube light we must use a custom energy conservation */\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= masking;\n\tbsdf *= 23.2; /* XXX : !!! Very Empirical, Fit cycles power */\n}\n\nvoid bsdf_refract_ggx_sun_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                            float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                            float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                            out float bsdf)\n{\n\t/* Correct ligth shape but uniform intensity\n\t * Does not take into account the division by costheta^3 */\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tfloat eta = (gl_FrontFacing) ? ior : 1.0/ior;\n\tvec3 R = refract(-V, N, 1.0/eta);\n\n\tfloat l_radius = l_areasizex;\n\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point_disk(l_radius, 1.0, R, L, roughness, energy_conservation);\n\n\tbsdf = bsdf_ggx_refract(N, L, V, eta, roughness);\n\tbsdf *= energy_conservation;\n}\n\n/* REFRACT BECKMANN */\n\nvoid bsdf_refract_beckmann_sphere_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                               float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                               float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                               out float bsdf)\n{\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tfloat l_radius = l_areasizex;\n\n\tshade_view(V, V);\n\tfloat eta = (gl_FrontFacing) ? ior : 1.0/ior;\n\tvec3 R = refract(-V, N, 1.0/eta);\n\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point(l_radius, 0.0, vec3(0.0), l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_beckmann_refract(N, L, V, eta, roughness);\n\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= sphere_energy(l_radius) * max(l_radius * l_radius, 1e-16); /* l_radius is already inside energy_conservation */\n\tbsdf *= M_PI; /* XXX : !!! Very Empirical, Fit cycles power */\n\tbsdf *= step(0.0, dot(-L, N));\n}\n\nvoid bsdf_refract_beckmann_area_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                             float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                             float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                             out float bsdf)\n{\n\tif (min(l_areasizex, l_areasizey) < 1e-6) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tl_areasizex *= l_areascale.x;\n\tl_areasizey *= l_areascale.y;\n\n\t/* Used later for Masking : Use the real Light Vector */\n\tvec3 lampz = normalize( (l_mat * vec4(0.0,0.0,1.0,0.0) ).xyz ); //lamp projection axis\n\tfloat masking = max(dot( normalize(-L), lampz), 0.0);\n\n\tfloat max_size = max(l_areasizex, l_areasizey);\n\tfloat min_size = min(l_areasizex, l_areasizey);\n\tvec3 lampVec = (l_areasizex > l_areasizey) ? normalize( (l_mat * vec4(1.0,0.0,0.0,0.0) ).xyz ) : normalize( (l_mat * vec4(0.0,1.0,0.0,0.0) ).xyz );\n\n\n\tfloat eta = (gl_FrontFacing) ? ior : 1.0/ior;\n\tvec3 R = refract(-V, N, 1.0/eta);\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point(min_size/2.0, max_size-min_size, lampVec, l_distance, R, L, roughness, energy_conservation);\n\tbsdf = bsdf_beckmann_refract(N, L, V, eta, roughness);\n\n\t/* energy_conservation */\n\tfloat LineAngle = clamp( (max_size-min_size) / l_distance, 0.0, 1.0);\n\tfloat energy_conservation_line = energy_conservation * ( roughness / clamp(roughness + 0.5 * LineAngle, 0.0, 1.1));\n\n\t/* XXX : Empirical modification for low roughness matching */\n\tfloat energy_conservation_mod = energy_conservation * (1.0 + roughness) / ( max_size/min_size );\n\tenergy_conservation = mix(energy_conservation_mod, energy_conservation_line, min(roughness/0.3, 0.9*(1.1-roughness)/0.1));\n\n\t/* As we represent the Area Light by a tube light we must use a custom energy conservation */\n\tbsdf *= energy_conservation / (l_distance * l_distance);\n\tbsdf *= masking;\n\tbsdf *= step(0.0, dot( normalize(-L), N));\n\tbsdf *= 23.2; /* XXX : !!! Very Empirical, Fit cycles power */\n}\n\nvoid bsdf_refract_beckmann_sun_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                            float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                            float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                            out float bsdf)\n{\n\t/* Correct ligth shape but uniform intensity\n\t * Does not take into account the division by costheta^3 */\n\tif (roughness < 1e-4 && l_areasizex == 0.0) {\n\t\tbsdf = 0.0;\n\t\treturn;\n\t}\n\n\tfloat eta = (gl_FrontFacing) ? ior : 1.0/ior;\n\tvec3 R = refract(-V, N, 1.0/eta);\n\n\tfloat l_radius = l_areasizex;\n\n\tfloat energy_conservation = 1.0;\n\tmost_representative_point_disk(l_radius, 1.0, R, L, roughness, energy_conservation);\n\n\tbsdf = bsdf_beckmann_refract(N, L, V, eta, roughness);\n\tbsdf *= energy_conservation;\n\tbsdf *= step(0.0, dot(-L, N));\n}\n\n/* -------- Image Based Lighting --------- */\n\nvoid env_sampling_refract_sharp(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tfloat eta = (gl_FrontFacing) ? 1.0/ior : ior;\n\n\tvec3 L = refract(I, N, eta);\n\n\tresult = sample_refract(L).rgb;\n}\n\nvoid env_sampling_refract_ggx(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tmake_orthonormals(N, T, B); /* Generate tangent space */\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\tfloat a, a2; prepare_glossy(roughness, a, a2);\n\tior = max(ior, 1e-5);\n\n\t/* Precomputation */\n\tfloat NV = max(1e-8, abs(dot(I, N)));\n\tfloat G1_V = G1_Smith_GGX(NV, a2);\n\n\t/* Early out */\n\tif (abs(ior - 1.0) < 1e-4) {\n\t\tresult = sample_transparent();\n\t\treturn;\n\t}\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 H = sample_ggx(i, a2, N, T, B); /* Microfacet normal */\n\t\tfloat eta = 1.0/ior;\n\t\tfloat fresnel = fresnel_dielectric(I, H, ior);\n\n\t\tif (dot(H, -I) < 0.0) {\n\t\t\tH = -H;\n\t\t\teta = ior;\n\t\t}\n\n\t\tvec3 L = refract(I, H, eta);\n\t\tfloat NL = -dot(N, L);\n\t\tif (NL > 0.0 && fresnel != 1.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat NH = dot(N, H); /* cosTheta */\n\t\t\tfloat VH = dot(-I, H);\n\t\t\tfloat LH = dot(L, H);\n\t\t\tfloat tmp = ior * VH + LH;\n\t\t\tfloat Ht2 = tmp * tmp;\n\n\t\t\tfloat pdf = pdf_ggx_refract(Ht2, NH, NV, VH, LH, G1_V, a2, eta);\n\n\t\t\tvec4 sample = sample_refract_pdf(L, roughness, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF */\n\t\t\tfloat brdf_pdf = bsdf_ggx_refract_pdf(a2, LH, NL, VH);\n\n\t\t\tout_radiance += sample * brdf_pdf;\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125;\n}\n\nvoid env_sampling_refract_beckmann(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tmake_orthonormals(N, T, B); /* Generate tangent space */\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\tfloat a, a2; prepare_glossy(roughness, a, a2);\n\tior = max(ior, 1e-5);\n\n\t/* Precomputation */\n\tfloat NV = max(1e-8, abs(dot(I, N)));\n\tfloat G1_V = G1_Smith_GGX(NV, a2);\n\n\t/* Early out */\n\tif (abs(ior - 1.0) < 1e-4) {\n\t\tresult = sample_transparent();\n\t\treturn;\n\t}\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 H = sample_beckmann(i, a2, N, T, B); /* Microfacet normal */\n\t\tfloat eta = 1.0/ior;\n\t\tfloat fresnel = fresnel_dielectric(I, H, ior);\n\n\t\tif (dot(H, -I) < 0.0) {\n\t\t\tH = -H;\n\t\t\teta = ior;\n\t\t}\n\n\t\tvec3 L = refract(I, H, eta);\n\t\tfloat NL = -dot(N, L);\n\t\tif (NL > 0.0 && fresnel != 1.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat NH = dot(N, H); /* cosTheta */\n\t\t\tfloat VH = dot(-I, H);\n\t\t\tfloat LH = dot(L, H);\n\t\t\tfloat tmp = ior * VH + LH;\n\t\t\tfloat Ht2 = tmp * tmp;\n\n\t\t\tfloat pdf = pdf_beckmann_refract(Ht2, NH, NV, VH, LH, G1_V, a2, eta);\n\n\t\t\tvec4 sample = sample_refract_pdf(L, roughness, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF */\n\t\t\tfloat brdf_pdf = bsdf_beckmann_refract_pdf(a2, LH, NL, VH);\n\n\t\t\tout_radiance += sample * brdf_pdf;\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125;\n}/* -------- Utils Functions --------- */\n\nfloat fresnel_blend(float transmit_bsdf, float reflect_bsdf, vec3 V, vec3 N, float ior)\n{\n\t/* Fresnel Blend */\n\tfloat eta = (gl_FrontFacing) ? ior : 1.0/ior;\n\tfloat fresnel = fresnel_dielectric(V, N, eta);\n\n\treturn mix(max(0.0, transmit_bsdf), reflect_bsdf, fresnel);\n}\n\nvec3 fresnel_blend(vec3 transmit_bsdf, vec3 reflect_bsdf, vec3 V, vec3 N, float ior)\n{\n\t/* Fresnel Blend */\n\tfloat eta = (gl_FrontFacing) ? ior : 1.0/ior;\n\tfloat fresnel = fresnel_dielectric(V, N, eta);\n\n\treturn mix(transmit_bsdf, reflect_bsdf, fresnel);\n}\n\n\n/* -------- BSDF --------- */\n\n/* -------- Preview Lights --------- */\n\nvoid node_bsdf_glass_lights(vec4 color, float roughness, float ior, vec3 N, vec3 V, vec4 ambient_light, out vec4 result)\n{\n\tnode_bsdf_glossy_lights(color, roughness, N, V, ambient_light, result);\n}\n\n/* -------- Physical Lights --------- */\n\n/* GLASS GGX */\n\nvoid bsdf_glass_ggx_sphere_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                             float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                             float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                             out float bsdf)\n{\n\tfloat transmit_bsdf, reflect_bsdf;\n\n\tbsdf_refract_ggx_sphere_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                              sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, transmit_bsdf);\n\tbsdf_glossy_ggx_sphere_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                             sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, reflect_bsdf);\n\n\tbsdf = fresnel_blend(transmit_bsdf, reflect_bsdf, V, N, ior);\n}\n\nvoid bsdf_glass_ggx_area_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                           float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                           float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                           out float bsdf)\n{\n\tfloat transmit_bsdf, reflect_bsdf;\n\n\tbsdf_refract_ggx_area_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                            sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, transmit_bsdf);\n\tbsdf_glossy_ggx_area_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                           sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, reflect_bsdf);\n\n\tbsdf = fresnel_blend(transmit_bsdf, reflect_bsdf, V, N, ior);\n}\n\nvoid bsdf_glass_ggx_sun_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                          float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                          float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                          out float bsdf)\n{\n\tfloat transmit_bsdf, reflect_bsdf;\n\n\tbsdf_refract_ggx_sun_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                           sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, transmit_bsdf);\n\tbsdf_glossy_ggx_sun_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                          sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, reflect_bsdf);\n\n\tbsdf = fresnel_blend(transmit_bsdf, reflect_bsdf, V, N, ior);\n}\n\n/* GLASS BECKMANN */\n\nvoid bsdf_glass_beckmann_sphere_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                             float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                             float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                             out float bsdf)\n{\n\tfloat transmit_bsdf, reflect_bsdf;\n\n\tbsdf_refract_beckmann_sphere_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                              sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, transmit_bsdf);\n\tbsdf_glossy_beckmann_sphere_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                             sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, reflect_bsdf);\n\n\tbsdf = fresnel_blend(transmit_bsdf, reflect_bsdf, V, N, ior);\n}\n\nvoid bsdf_glass_beckmann_area_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                           float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                           float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                           out float bsdf)\n{\n\tfloat transmit_bsdf, reflect_bsdf;\n\n\tbsdf_refract_beckmann_area_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                            sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, transmit_bsdf);\n\tbsdf_glossy_beckmann_area_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                           sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, reflect_bsdf);\n\n\tbsdf = fresnel_blend(transmit_bsdf, reflect_bsdf, V, N, ior);\n}\n\nvoid bsdf_glass_beckmann_sun_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                          float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                          float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                          out float bsdf)\n{\n\tfloat transmit_bsdf, reflect_bsdf;\n\n\tbsdf_refract_beckmann_sun_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                           sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, transmit_bsdf);\n\tbsdf_glossy_beckmann_sun_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                          sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, reflect_bsdf);\n\n\tbsdf = fresnel_blend(transmit_bsdf, reflect_bsdf, V, N, ior);\n}\n\n/* GLASS SHARP */\n\nvoid bsdf_glass_sharp_sphere_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                               float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                               float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                               out float bsdf)\n{\n\tfloat transmit_bsdf, reflect_bsdf;\n\n\tbsdf_refract_sharp_sphere_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                                sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, transmit_bsdf);\n\tbsdf_glossy_sharp_sphere_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                               sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, reflect_bsdf);\n\n\tbsdf = fresnel_blend(transmit_bsdf, reflect_bsdf, V, N, ior);\n}\n\nvoid bsdf_glass_sharp_area_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                             float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                             float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                             out float bsdf)\n{\n\tfloat transmit_bsdf, reflect_bsdf;\n\n\tbsdf_refract_sharp_area_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                              sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, transmit_bsdf);\n\tbsdf_glossy_sharp_area_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                             sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, reflect_bsdf);\n\n\tbsdf = fresnel_blend(transmit_bsdf, reflect_bsdf, V, N, ior);\n}\n\nvoid bsdf_glass_sharp_sun_light(vec3 N, vec3 T, vec3 L, vec3 V, vec3 l_coords,\n\t                            float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\t                            float roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\t                            out float bsdf)\n{\n\tfloat transmit_bsdf, reflect_bsdf;\n\n\tbsdf_refract_sharp_sun_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                             sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, transmit_bsdf);\n\tbsdf_glossy_sharp_sun_light(N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, roughness, ior,\n\t                            sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, reflect_bsdf);\n\n\tbsdf = fresnel_blend(transmit_bsdf, reflect_bsdf, V, N, ior);\n}\n\n\n/* -------- Image Based Lighting --------- */\n\nvoid env_sampling_glass_sharp(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\n\t/* reflection */\n\tvec3 R = reflect(I, N);\n\tvec4 reflect_bsdf = sample_reflect(R);\n\n\t/* transmission */\n\tfloat eta = (gl_FrontFacing) ? 1.0/ior : ior;\n\tvec3 Tr = refract(I, N, eta);\n\tvec4 transmit_bsdf = sample_refract(Tr);\n\n\tresult = fresnel_blend(transmit_bsdf.rgb, reflect_bsdf.rgb, I, N, ior) * specular_occlusion(dot(N,-I), ao_factor, 0.0);\n}\n\nvoid env_sampling_glass_ggx(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tmake_orthonormals(N, T, B); /* Generate tangent space */\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\tfloat a, a2; prepare_glossy(roughness, a, a2);\n\tior = max(ior, 1e-5);\n\n\t/* Precomputation */\n\tfloat NV = max(1e-8, abs(dot(I, N)));\n\tfloat G1_V = G1_Smith_GGX(NV, a2);\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 H = sample_ggx(i, a2, N, T, B); /* Microfacet normal */\n\n\t\t/* TODO : For ior < 1.0 && roughness > 0.0 fresnel becomes not accurate.*/\n\t\tfloat fresnel = fresnel_dielectric(I, H, (dot(H, -I) < 0.0) ? 1.0/ior : ior );\n\n\t\t/* reflection */\n\t\tvec3 R = reflect(I, H);\n\t\tfloat NL = dot(N, R);\n\t\tif (NL > 0.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat NH = max(1e-8, dot(N, H)); /* cosTheta */\n\t\t\tfloat VH = max(1e-8, -dot(I, H));\n\n\t\t\tfloat pdf = pdf_ggx_reflect(NH, a2);\n\n\t\t\tvec4 sample = sample_reflect_pdf(R, roughness, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF */\n\t\t\tfloat brdf_pdf = bsdf_ggx_pdf(a2, NH, NL, VH, G1_V);\n\n\t\t\t/* See reflect glossy */\n\t\t\tout_radiance += NL * sample * brdf_pdf * fresnel;\n\t\t}\n\n\t\t/* transmission */\n\t\tfloat eta = 1.0/ior;\n\t\tif (dot(H, -I) < 0.0) {\n\t\t\tH = -H;\n\t\t\teta = ior;\n\t\t}\n\n\t\tvec3 Tr = refract(I, H, eta);\n\t\tNL = -dot(N, Tr);\n\t\tif (NL > 0.0 && fresnel != 1.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat NH = dot(N, H); /* cosTheta */\n\t\t\tfloat VH = dot(-I, H);\n\t\t\tfloat LH = dot(Tr, H);\n\t\t\tfloat tmp = ior * VH + LH;\n\t\t\tfloat Ht2 = tmp * tmp;\n\n\t\t\tfloat pdf = pdf_ggx_refract(Ht2, NH, NV, VH, LH, G1_V, a2, eta);\n\n\t\t\tvec4 sample = sample_refract_pdf(Tr, roughness, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF */\n\t\t\tfloat brdf_pdf = bsdf_ggx_refract_pdf(a2, LH, NL, VH);\n\n\t\t\tout_radiance += sample * brdf_pdf * (1.0 - fresnel);\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125 * specular_occlusion(NV, ao_factor, a2);\n}\n\nvoid env_sampling_glass_beckmann(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tmake_orthonormals(N, T, B); /* Generate tangent space */\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\tfloat a, a2; prepare_glossy(roughness, a, a2);\n\tior = max(ior, 1e-5);\n\n\t/* Precomputation */\n\tfloat NV = max(1e-8, abs(dot(I, N)));\n\tfloat G1_V = G1_Smith_GGX(NV, a2);\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 H = sample_beckmann(i, a2, N, T, B); /* Microfacet normal */\n\n\t\t/* TODO : For ior < 1.0 && roughness > 0.0 fresnel becomes not accurate.*/\n\t\tfloat fresnel = fresnel_dielectric(I, H, (dot(H, -I) < 0.0) ? 1.0/ior : ior );\n\n\t\t/* reflection */\n\t\tvec3 R = reflect(I, H);\n\t\tfloat NL = dot(N, R);\n\t\tif (NL > 0.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat NH = max(1e-8, dot(N, H)); /* cosTheta */\n\t\t\tfloat VH = max(1e-8, -dot(I, H));\n\n\t\t\tfloat pdf = pdf_beckmann_reflect(NH, a2);\n\n\t\t\tvec4 sample = sample_reflect_pdf(R, roughness, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF */\n\t\t\tfloat brdf_pdf = bsdf_beckmann_pdf(a2, NH, NV, NL, VH, G1_V);\n\n\t\t\t/* See reflect glossy */\n\t\t\tout_radiance += NL * sample * brdf_pdf * fresnel;\n\t\t}\n\n\t\t/* transmission */\n\t\tfloat eta = 1.0/ior;\n\t\tif (dot(H, -I) < 0.0) {\n\t\t\tH = -H;\n\t\t\teta = ior;\n\t\t}\n\n\t\tvec3 Tr = refract(I, H, eta);\n\t\tNL = -dot(N, Tr);\n\t\tif (NL > 0.0 && fresnel != 1.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat NH = dot(N, H); /* cosTheta */\n\t\t\tfloat VH = dot(-I, H);\n\t\t\tfloat LH = dot(Tr, H);\n\t\t\tfloat tmp = ior * VH + LH;\n\t\t\tfloat Ht2 = tmp * tmp;\n\n\t\t\tfloat pdf = pdf_beckmann_refract(Ht2, NH, NV, VH, LH, G1_V, a2, eta);\n\n\t\t\tvec4 sample = sample_refract_pdf(Tr, roughness, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF */\n\t\t\tfloat brdf_pdf = bsdf_beckmann_refract_pdf(a2, LH, NL, VH);\n\n\t\t\tout_radiance += sample * brdf_pdf * (1.0 - fresnel);\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125 * specular_occlusion(NV, ao_factor, a2);\n}\n/* -------- Utils Functions --------- */\n\n/* -------- BSDF --------- */\n\n/* -------- Preview Lights --------- */\n\nvoid node_bsdf_translucent_lights(vec4 color, vec3 N, vec3 V, vec4 ambient_light, out vec4 result)\n{\n\tnode_bsdf_diffuse_lights(color, 0.0, -N, V, ambient_light, result);\n}\n\n\n/* -------- Physical Lights --------- */\n\nvoid bsdf_translucent_sphere_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tbsdf_diffuse_sphere_light(-N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, 0.0, ior, sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, bsdf);\n}\n\nvoid bsdf_translucent_area_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tbsdf_diffuse_area_light(-N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, 0.0, ior, sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, bsdf);\n}\n\nvoid bsdf_translucent_sun_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tbsdf_diffuse_sun_light(-N, T, L, V, l_coords, l_distance, l_areasizex, l_areasizey, l_areascale, l_mat, 0.0, ior, sigma, toon_size, toon_smooth, anisotropy, aniso_rotation, bsdf);\n}\n\n/* -------- Image Based Lighting --------- */\n\nvoid env_sampling_translucent(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\tenv_sampling_diffuse(\n\t\tpbr, viewpos, invviewmat, viewmat,\n\t\t-N, T, 0.0, ior, sigma,\n\t\ttoon_size, toon_smooth, anisotropy, aniso_rotation,\n\t\tao_factor, result);\n}\n/* -------- Utils Functions --------- */\n\nvec3 sample_uniform_cone(float nsample, float angle, vec3 N, vec3 T, vec3 B)\n{\n\tvec3 Xi = hammersley_3d(nsample);\n\n\tfloat z = cos(angle * Xi.x);\n\tfloat r = sqrt(1.0 - z*z);\n\tfloat x = r * Xi.y;\n\tfloat y = r * Xi.z;\n\n\tHt = vec3(x, y, z); /* Global variable */\n\n\treturn from_tangent_to_world(Ht, N, T, B);\n}\n\nfloat pdf_uniform_cone(float angle)\n{\n\treturn 0.5 * M_1_PI / (1.0 - cos(angle));\n}\n\nvoid prepare_toon(inout float tsize, inout float tsmooth, out float sample_angle)\n{\n\ttsize = saturate(tsize) * M_PI_2;\n\ttsmooth = saturate(tsmooth) * M_PI_2;\n\tsample_angle = min(tsize + tsmooth, M_PI_2);\n}\n\nfloat bsdf_toon_get_intensity(float max_angle, float tsmooth, float angle)\n{\n\tif(angle < max_angle)\n\t\treturn 1.0;\n\telse if(angle < (max_angle + tsmooth) && tsmooth != 0.0)\n\t\treturn (1.0 - (angle - max_angle)/tsmooth);\n\telse\n\t\treturn 0.0;\n}\n\n/* -------- BSDF --------- */\n\nfloat bsdf_toon(float cosangle, float pdf, float max_angle, float tsmooth)\n{\n\tfloat angle = acos(min(0.9999999, cosangle));\n\tfloat eval = bsdf_toon_get_intensity(max_angle, tsmooth, angle);\n\treturn pdf * eval;\n}\n\nfloat bsdf_toon_diffuse(vec3 N, vec3 L, float sample_angle, float max_angle, float tsmooth)\n{\n\tfloat NL = max(0.0, dot(N, L));\n\n\tif(NL > 0.0) {\n\t\tfloat pdf = pdf_uniform_cone(sample_angle);\n\t\treturn bsdf_toon(NL, pdf, max_angle, tsmooth);\n\t}\n\n\treturn 0.0;\n}\n\nfloat bsdf_toon_glossy(vec3 N, vec3 L, vec3 V, float sample_angle, float max_angle, float tsmooth)\n{\n\tfloat NL = max(0.0, dot(N, L));\n\tfloat NV = max(0.0, dot(N, V));\n\n\tif(NV > 0.0 && NL > 0.0) {\n\t\tvec3 R = -reflect(V, N);\n\t\tfloat RL = max(0.0, dot(R, L));\n\t\tfloat pdf = pdf_uniform_cone(sample_angle);\n\t\treturn bsdf_toon(RL, pdf, max_angle, tsmooth);\n\t}\n\n\treturn 0.0;\n}\n\n\n/* -------- Preview Lights --------- */\n\nvoid node_bsdf_toon_diffuse_lights(vec4 color, float size, float tsmooth, vec3 N, vec3 V, vec4 ambient_light, out vec4 result)\n{\n\tshade_view(V, V); V = -V;\n\tN = normalize(N);\n\tfloat sample_angle; prepare_toon(size, tsmooth, sample_angle);\n\n\t/* ambient light */\n\tvec3 accumulator = ambient_light.rgb;\n\n\t/* directional lights */\n\tfor(int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 L = vec3(0,0,0).xyz;\n\t\tvec3 light_color = vec3(0,0,0).rgb;\n\n\t\taccumulator += light_color * bsdf_toon_diffuse(N, L, sample_angle, size, tsmooth) * M_PI; /* M_PI to make preview brighter */\n\t}\n\n\tresult = vec4(accumulator*color.rgb, 1.0);\n}\n\nvoid node_bsdf_toon_glossy_lights(vec4 color, float size, float tsmooth, vec3 N, vec3 V, vec4 ambient_light, out vec4 result)\n{\n\tshade_view(V, V); V = -V;\n\tN = normalize(N);\n\tfloat sample_angle; prepare_toon(size, tsmooth, sample_angle);\n\n\t/* ambient light */\n\tvec3 accumulator = ambient_light.rgb;\n\n\t/* directional lights */\n\tfor(int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 L = vec3(0,0,0).xyz;\n\t\tvec3 light_color = vec3(0,0,0).rgb;\n\n\t\taccumulator += light_color * bsdf_toon_glossy(N, L, V, sample_angle, size, tsmooth) * M_PI; /* M_PI to make preview brighter */\n\t}\n\n\tresult = vec4(accumulator*color.rgb, 1.0);\n}\n\n\n/* -------- Physical Lights --------- */\n\n/* TOON DIFFUSE */\n\nvoid bsdf_toon_diffuse_sphere_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tfloat sample_angle; prepare_toon(toon_size, toon_smooth, sample_angle);\n\tbsdf = bsdf_toon_diffuse(N, L, sample_angle, toon_size, toon_smooth);\n\n\t/* Energy conservation + cycle matching */\n\tbsdf *= 8.0 / (l_distance * l_distance);\n}\n\nvoid bsdf_toon_diffuse_area_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tfloat sample_angle; prepare_toon(toon_size, toon_smooth, sample_angle);\n\tbsdf = bsdf_toon_diffuse(N, L, sample_angle, toon_size, toon_smooth);\n\n\t/* Energy conservation + cycle matching */\n\tbsdf *= 8.0 / (l_distance * l_distance);\n}\n\nvoid bsdf_toon_diffuse_sun_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tfloat sample_angle; prepare_toon(toon_size, toon_smooth, sample_angle);\n\tbsdf = bsdf_toon_diffuse(N, L, sample_angle, toon_size, toon_smooth);\n}\n\n/* TOON GLOSSY */\n\nvoid bsdf_toon_glossy_sphere_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tfloat sample_angle; prepare_toon(toon_size, toon_smooth, sample_angle);\n\tbsdf = bsdf_toon_glossy(N, L, V, sample_angle, toon_size, toon_smooth);\n}\n\nvoid bsdf_toon_glossy_area_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tfloat sample_angle; prepare_toon(toon_size, toon_smooth, sample_angle);\n\tbsdf = bsdf_toon_glossy(N, L, V, sample_angle, toon_size, toon_smooth);\n\n\t/* Energy conservation + cycle matching */\n\tbsdf *= 8.0 / (l_distance * l_distance);\n}\n\nvoid bsdf_toon_glossy_sun_light(\n\tvec3 N, vec3 T, vec3 L, vec3 V,\n\tvec3 l_coords, float l_distance, float l_areasizex, float l_areasizey, vec2 l_areascale, mat4 l_mat,\n\tfloat roughness, float ior, float sigma, float toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tout float bsdf)\n{\n\tfloat sample_angle; prepare_toon(toon_size, toon_smooth, sample_angle);\n\tbsdf = bsdf_toon_glossy(N, L, V, sample_angle, toon_size, toon_smooth);\n}\n\n\n/* -------- Image Based Lighting --------- */\n\nvoid env_sampling_toon_diffuse(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tmake_orthonormals(N, T, B); /* Generate tangent space */\n\tfloat sample_angle; prepare_toon(toon_size, toon_smooth, sample_angle);\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\n\t/* Precomputation */\n\tfloat NV = max(0.0, dot(I, N));\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 L = sample_uniform_cone(i, sample_angle, N, T, B);\n\t\tfloat NL = dot(N, L);\n\n\t\tif (NL > 0.0) {\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat pdf = pdf_uniform_cone(sample_angle);\n\t\t\tvec4 irradiance = sample_probe_pdf(L, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF*/\n\t\t\tfloat brdf = bsdf_toon(NL, pdf, toon_size, toon_smooth);\n\n\t\t\tout_radiance += irradiance * brdf / pdf;\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125 * ao_factor;\n}\n\nvoid env_sampling_toon_glossy(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\t/* Setup */\n\tvector_prepass(viewpos, N, invviewmat, viewmat);\n\tfloat sample_angle; prepare_toon(toon_size, toon_smooth, sample_angle);\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\n\t/* Precomputation */\n\tfloat NV = max(1e-8, dot(I, N));\n\tvec3 R = reflect(I, N);\n\n\t/* We are sampling aroung R so generate basis with it */\n\tmake_orthonormals(R, T, B); /* Generate tangent space */\n\n\t/* Integrating Envmap */\n\tvec4 out_radiance = vec4(0.0);\n\tfloat i; for (int iii = 0; iii < 32; iii++) { i = float(iii);\n\t\tvec3 L = sample_uniform_cone(i, sample_angle, R, T, B);\n\n\t\tfloat NL = dot(N, L);\n\n\t\tif (NL > 0.0) {\n\t\t\tfloat RL = max(0.0, dot(R, L));\n\n\t\t\t/* Step 1 : Sampling Environment */\n\t\t\tfloat pdf = pdf_uniform_cone(sample_angle);\n\t\t\tvec4 irradiance = sample_reflect_pdf(L, 0.0, pdf);\n\n\t\t\t/* Step 2 : Integrating BRDF*/\n\t\t\tfloat brdf = bsdf_toon(RL, pdf, toon_size, toon_smooth);\n\n\t\t\tout_radiance += irradiance * brdf / pdf;\n\t\t}\n\t}\n\n\tresult = out_radiance.rgb * 0.03125 * specular_occlusion(NV, ao_factor, roughness);\n}\n/* -------- Utils Functions --------- */\nvec2 sample_disk(float nsample, float invsamplenbr)\n{\n\tvec3 Xi = hammersley_3d(nsample, invsamplenbr);\n\n\tfloat x = Xi.x * Xi.y;\n\tfloat y = Xi.x * Xi.z;\n\n\treturn vec2(x, y);\n}\n\nvec3 sample_hemisphere(float nsample, float invsamplenbr, vec3 N, vec3 T, vec3 B)\n{\n\tvec3 Xi = hammersley_3d(nsample, invsamplenbr);\n\n\tfloat z = Xi.x; /* cos theta */\n\tfloat r = sqrt( 1.0 - z*z ); /* sin theta */\n\tfloat x = r * Xi.y;\n\tfloat y = r * Xi.z;\n\n\tHt = vec3(x, y, z); /* Global variable */\n\n\treturn from_tangent_to_world(Ht, N, T, B);\n}\n\n#ifdef USE_SSAO\n\n#if 0 /* Cheap */\n\nfloat ssao(vec3 viewpos, vec3 viewnor, out float result)\n{\n\tfloat dist = unfssaoparam.z;\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\n\t/* get uv of the shading point */\n\tvec4 projvec = projection_matrix * vec4(viewpos, 1.0);\n\tvec2 uv = (projvec.xy / projvec.w) * 0.5 + 0.5;\n\n\tvec2 offset;\n\toffset.x = projection_matrix[0][0] * dist / projvec.w;\n\toffset.y = projection_matrix[1][1] * dist / projvec.w;\n\t/* convert from -1.0...1.0 range to 0.0..1.0 for easy use with texture coordinates */\n\toffset *= 0.5;\n\n\tfloat factor = 0.0;\n\t/* We don't need as much samples for ssao */\n\tfor (float i = 0.0; i < unfssaoparam.x; i++) {\n\t\tvec2 Xi = sample_disk(i, 1/unfssaoparam.x);\n\t\tvec2 uvsample = uv + Xi * offset;\n\n\t\tif (uvsample.x > 1.0 || uvsample.x < 0.0 || uvsample.y > 1.0 || uvsample.y < 0.0)\n\t\t\tcontinue;\n\n\t\tfloat sampledepth = frontface_depth(ivec2(uvsample * unfclip.zw));\n\n\t\t/* Background Case */\n\t\tif (sampledepth == 1.0)\n\t\t\tcontinue;\n\n\t\tvec3 samplepos = position_from_depth(uvsample, sampledepth);\n\n\t\tvec3 dir = samplepos - viewpos;\n\t\tfloat len = length(dir);\n\t\tfloat f = dot(dir, viewnor);\n\n\t\t/* use minor bias here to cancel self shadowing */\n\t\tif (f > 0.05 * len + 0.0001)\n\t\t\tfactor += f / (len + len * len * len);\n\t}\n\n\tresult = saturate(1.0 - factor / unfssaoparam.x);\n}\n\n#else /* Expensive */\n\nvoid ssao(vec3 viewpos, vec3 viewnor, out float result)\n{\n\tfloat dist = unfssaoparam.z;\n\tsetup_noise(gl_FragCoord.xy); /* Noise to dither the samples */\n\n\tvec3 T;\n\tmake_orthonormals(viewnor, T, B); /* Generate tangent space */\n\n\tfloat homcoord = (projection_matrix[3][3] == 0.0) ? projection_matrix[2][3] * viewpos.z : dist;\n\n\tfloat factor = 0.0;\n\tfloat weight = 0.0;\n\n\tfor (float i = 0.0; i < unfssaoparam.x; i++) {\n\t\tvec3 Xi = sample_hemisphere(i, 1/unfssaoparam.x, viewnor, T, B);\n\n\t\tfloat pdf = dot(Xi, viewnor);\n\t\tweight += pdf;\n\n\t\t/* Raymarch */\n\t\t/* We jitter the starting position by a percentage of the normal \n\t\t * offset to a v o i d banding artifact for thin objects but\n\t\t * we still finish at the same final position to a v o i d\n\t\t * less sampling at the edges of the occlusion effect */\n\t\tvec3 offset = dist * Xi / unfssaoparam.y;\n\t\tvec3 ray = (jitternoise.y - 0.5) * -offset;\n\t\tvec3 endoffset = offset - ray;\n\n\t\tfor (float j = unfssaoparam.y; j > 0.0; j--) {\n\n\t\t\tray += (j == 1) ? endoffset : offset;\n\n\t\t\tvec4 co = unfpixelprojmat * vec4(ray + viewpos, 1.0);\n\t\t\tco.xy /= co.w;\n\n\t\t\t/* Discard ray leaving screen */\n\t\t\tif (co.x > unfclip.z || co.x < 0.0 || co.y > unfclip.w || co.y < 0.0)\n\t\t\t\tbreak;\n\n\t\t\tfloat sampledepth = frontface_depth(ivec2(co.xy), 0);\n\n\t\t\t/* Background Case */\n\t\t\tif (sampledepth == 1.0)\n\t\t\t\tcontinue;\n\n\t\t\t/* We have a hit */\n\t\t\tif (sampledepth > ray.z + viewpos.z + homcoord * 0.002\n#ifdef USE_BACKFACE\n\t\t\t && backface_depth(ivec2(co.xy), 0) < ray.z + viewpos.z\n#endif\n\t\t\t )\n\t\t\t{\n\t\t\t\tfactor += pdf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = saturate(1.0 - (factor / weight) * unfssaoparam.w);\n}\n#endif\n#else\nvoid ssao(vec3 viewpos, vec3 viewnor, out float result)\n{\n\tresult = 1.0;\n}\n#endif\n\n\n/* -------- BSDF --------- */\n\n/* -------- Preview Lights --------- */\n\n/* -------- Physical Lights --------- */\n\n/* -------- Image Based Lighting --------- */\n\nvoid env_sampling_ambient_occlusion(\n\tfloat pbr, vec3 viewpos, mat4 invviewmat, mat4 viewmat,\n\tvec3 N, vec3 T, float roughness, float ior, float sigma,\n\tfloat toon_size, float toon_smooth, float anisotropy, float aniso_rotation,\n\tfloat ao_factor, out vec3 result)\n{\n\tresult = vec3(ao_factor);\n}/*********** NEW SHADER NODES ***************/\n\n/* Blending */\nvoid node_bsdf_opaque(vec4 color, vec4 ambient_light, vec4 direct_light, out vec4 result)\n{\n\tresult = vec4( (ambient_light.rgb + direct_light.rgb) * color.rgb, 1.0);\n}\n\nvoid node_bsdf_transparent(vec4 color, vec4 background, out vec4 result)\n{\n\tresult = vec4( background.rgb * color.rgb, color.a);\n}\n\n/* Others Bsdfs */\n\nvoid node_subsurface_scattering(vec4 color, float scale, vec3 radius, float sharpen, float texture_blur, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse_lights(color, 0.0, N, vec3(0.0), vec4(0.2), result);\n}\n\nvoid node_bsdf_hair(vec4 color, float offset, float roughnessu, float roughnessv, vec3 tangent, out vec4 result)\n{\n\tresult = color;\n}\n\nvoid node_ambient_occlusion(vec4 color, out vec4 result)\n{\n\tresult = color;\n}\n\nvoid node_holdout(out vec4 result)\n{\n\tresult = vec4(0.0);\n}\n\n/* emission */\n\nvoid node_emission(vec4 color, float strength, vec3 N, out vec4 result)\n{\n\tresult = color*strength;\n}\n\n/* blackbody */\n\nvoid node_blackbody(float T, out vec4 col)\n{\n\tfloat u = ( 0.860117757 + 1.54118254e-4 * T + 1.28641212e-7 * T*T ) / ( 1.0 + 8.42420235e-4 * T + 7.08145163e-7 * T*T );\n\tfloat v = ( 0.317398726 + 4.22806245e-5 * T + 4.20481691e-8 * T*T ) / ( 1.0 - 2.89741816e-5 * T + 1.61456053e-7 * T*T );\n\n\tfloat x = 3.0*u / ( 2.0*u - 8.0*v + 4.0 );\n\tfloat y = 2.0*v / ( 2.0*u - 8.0*v + 4.0 );\n\tfloat z = 1.0 - x - y;\n\n\tfloat Y = 1.0;\n\tfloat X = Y/y * x;\n\tfloat Z = Y/y * z;\n\n\tmat3 XYZtoRGB = mat3(\n\t\t3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385, 1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560, 1.0572252\n\t);\n\n\tcol = vec4(( XYZtoRGB * vec3( X, Y, Z ) ), 1.0);\n}\n\nvec3 xyz_to_rgb(float x, float y, float z)\n{\n\treturn vec3( 3.240479 * x + -1.537150 * y + -0.498535 * z,\n\t             -0.969256 * x +  1.875991 * y +  0.041556 * z,\n\t              0.055648 * x + -0.204043 * y +  1.057311 * z);\n}\n\n// CIE colour matching functions xBar, yBar, and zBar for\n//\t wavelengths from 380 through 780 nanometers, every 5\n//\t nanometers.  For a wavelength lambda in this range:\n//\t\t  cie_colour_match[(lambda - 380) / 5][0] = xBar\n//\t\t  cie_colour_match[(lambda - 380) / 5][1] = yBar\n//\t\t  cie_colour_match[(lambda - 380) / 5][2] = zBar\nuniform vec3 node_wavelength_LUT[81];\n\nvoid node_wavelength(float w, out vec4 col)\n{\n\tfloat ii = (w-380.0) * (1.0/5.0);  // scaled 0..80\n\tint i = int(ii);\n\tvec3 color;\n\n\tif(i < 0 || i >= 80) {\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tii -= float(i);\n\t\tcolor = mix(node_wavelength_LUT[i], node_wavelength_LUT[i+1], ii);\n\t}\n\n\tcolor = xyz_to_rgb(color.x, color.y, color.z);\n\tcolor *= 1.0/2.52;\t// Empirical scale from lg to make all comps <= 1\n\n\t/* Clamp to zero if values are smaller */\n\tcol = vec4(max(color, vec3(0.0, 0.0, 0.0)), 1.0);\n\n\t// srgb_to_linearrgb(col, col);\n}\n\n/* background */\n\nvoid background_transform_to_world(vec3 viewvec, out vec3 worldvec)\n{\n\tvec4 v = (projection_matrix[3][3] == 0.0) ? vec4(viewvec, 1.0) : vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 co_homogenous = v;\n\n\tvec4 co = vec4(co_homogenous.xyz / co_homogenous.w, 0.0);\n\tworldvec = (view_imat3 * co.xyz);\n}\n\nvoid node_background(vec4 color, float strength, vec3 N, out vec4 result)\n{\n\tresult = color * strength;\n}\n\n/* closures */\n\nvoid node_mix_shader(float fac, vec4 shader1, vec4 shader2, out vec4 shader)\n{\n\tshader = mix(shader1, shader2, saturate(fac));\n}\n\nvoid node_add_shader(vec4 shader1, vec4 shader2, out vec4 shader)\n{\n\tshader = shader1 + shader2;\n}\n\n/* fresnel */\n\nvoid node_fresnel(float ior, vec3 N, vec3 I, out float result)\n{\n\t/* handle perspective/orthographic */\n\tvec3 I_view = (projection_matrix[3][3] == 0.0) ? normalize(I) : vec3(0.0, 0.0, -1.0);\n\n\tfloat eta = max(ior, 0.00001);\n\tresult = fresnel_dielectric(I_view, N, (gl_FrontFacing) ? eta : 1.0/eta);\n}\n\n/* layer_weight */\n\nvoid node_layer_weight(float blend, vec3 N, vec3 I, out float fresnel, out float facing)\n{\n\t/* fresnel */\n\tfloat eta = max(1.0 - blend, 0.00001);\n\tvec3 I_view = (projection_matrix[3][3] == 0.0) ? normalize(I) : vec3(0.0, 0.0, -1.0);\n\n\tfresnel = fresnel_dielectric(I_view, N, (gl_FrontFacing)? 1.0/eta : eta );\n\n\t/* facing */\n\tfacing = abs(dot(I_view, N));\n\tif (blend != 0.5) {\n\t\tblend = clamp(blend, 0.0, 0.99999);\n\t\tblend = (blend < 0.5) ? 2.0 * blend : 0.5 / (1.0 - blend);\n\t\tfacing = pow(facing, blend);\n\t}\n\tfacing = 1.0 - facing;\n}\n\n/* gamma */\n\nvoid node_gamma(vec4 col, float gamma, out vec4 outcol)\n{\n\toutcol = col;\n\n\tif (col.r > 0.0)\n\t\toutcol.r = compatible_pow(col.r, gamma);\n\tif (col.g > 0.0)\n\t\toutcol.g = compatible_pow(col.g, gamma);\n\tif (col.b > 0.0)\n\t\toutcol.b = compatible_pow(col.b, gamma);\n}\n\n/* geometry */\n\nvoid node_attribute(vec3 attr, out vec4 outcol, out vec3 outvec, out float outf)\n{\n\toutcol = vec4(attr, 1.0);\n\toutvec = attr;\n\toutf = (attr.x + attr.y + attr.z) / 3.0;\n}\n\nvoid node_uvmap(vec3 attr_uv, out vec3 outvec)\n{\n\toutvec = attr_uv;\n}\n\nvoid tangent_orco_x(vec3 orco_in, out vec3 orco_out)\n{\n\torco_out = vec3(0.0, orco_in.z * -0.5, orco_in.y * 0.5);\n}\n\nvoid tangent_orco_y(vec3 orco_in, out vec3 orco_out)\n{\n\torco_out = vec3(orco_in.z * -0.5, 0.0, orco_in.x * 0.5);\n}\n\nvoid tangent_orco_z(vec3 orco_in, out vec3 orco_out)\n{\n\torco_out = vec3(orco_in.y * -0.5, orco_in.x * 0.5, 0.0);\n}\n\nvoid node_tangent(vec3 N, vec3 orco, mat4 objmat, mat4 invviewmat, out vec3 T)\n{\n\tN = (invviewmat*vec4(N, 0.0)).xyz;\n\tT = (objmat*vec4(orco, 0.0)).xyz;\n\tT = cross(N, normalize(cross(T, N)));\n}\n\nvoid node_tangentmap(vec4 attr_tangent, mat4 toworld, out vec3 tangent)\n{\n\ttangent = (toworld * vec4(attr_tangent.xyz, 0.0)).xyz;\n}\n\nvoid default_tangent(vec3 N, vec3 orco, mat4 objmat, mat4 viewmat, mat4 invviewmat, out vec3 T)\n{\n\torco = vec3(orco.y * -0.5, orco.x * 0.5, 0.0);\n\tnode_tangent(N, orco, objmat, invviewmat, T);\n\tT = (viewmat * vec4(T, 0.0)).xyz;\n}\n\nvoid node_geometry(vec3 I, vec3 N, vec3 attr_orco, mat4 toworld, mat4 fromobj,\n\tout vec3 position, out vec3 normal, out vec3 tangent,\n\tout vec3 true_normal, out vec3 incoming, out vec3 parametric,\n\tout float backfacing, out float pointiness)\n{\n\tposition = (toworld * vec4(I, 1.0)).xyz;\n\tnormal = (toworld * vec4(N, 0.0)).xyz;\n\tattr_orco = vec3(attr_orco.y * -0.5, attr_orco.x * 0.5, 0.0);\n\tnode_tangent(N, attr_orco, fromobj, toworld, tangent);\n\ttrue_normal = normal;\n\n\t/* handle perspective/orthographic */\n\tvec3 I_view = (projection_matrix[3][3] == 0.0) ? normalize(I) : vec3(0.0, 0.0, -1.0);\n\tincoming = -(toworld * vec4(I_view, 0.0)).xyz;\n\n\tparametric = vec3(0.0);\n\tbackfacing = (gl_FrontFacing) ? 0.0 : 1.0;\n\tpointiness = 0.5;\n}\n\nvoid node_geometry_lamp(vec3 N, vec4 P, vec3 I, mat4 toworld,\n\tout vec3 position, out vec3 normal, out vec3 tangent,\n\tout vec3 true_normal, out vec3 incoming, out vec3 parametric,\n\tout float backfacing, out float pointiness)\n{\n\tposition = (toworld*P).xyz;\n\tnormal = normalize(toworld*vec4(N, 0.0)).xyz;\n\ttangent = vec3(0.0);\n\ttrue_normal = normal;\n\tincoming = normalize(toworld*vec4(I, 0.0)).xyz;\n\n\tparametric = vec3(0.0);\n\tbackfacing = 0.0;\n\tpointiness = 0.0;\n}\n\nvoid node_tex_coord(\n        vec3 I, vec3 N, mat4 viewinvmat, mat4 obinvmat, vec4 camerafac,\n        vec3 attr_orco, vec3 attr_uv,\n        out vec3 generated, out vec3 normal, out vec3 uv, out vec3 object,\n        out vec3 camera, out vec3 window, out vec3 reflection)\n{\n\tgenerated = attr_orco * 0.5 + vec3(0.5);\n\tnormal = normalize((obinvmat * (viewinvmat * vec4(N, 0.0))).xyz);\n\tuv = attr_uv;\n\tobject = (obinvmat * (viewinvmat * vec4(I, 1.0))).xyz;\n\tcamera = vec3(I.xy, -I.z);\n\tvec4 projvec = projection_matrix * vec4(I, 1.0);\n\twindow = vec3(mtex_2d_mapping(projvec.xyz / projvec.w).xy * camerafac.xy + camerafac.zw, 0.0);\n\n\tvec3 shade_I;\n\tshade_view(I, shade_I);\n\tvec3 view_reflection = reflect(shade_I, normalize(N));\n\treflection = (viewinvmat * vec4(view_reflection, 0.0)).xyz;\n}\n\nvoid node_tex_coord_background(\n        vec3 I, vec3 N, mat4 viewinvmat, mat4 obinvmat, vec4 camerafac,\n        vec3 attr_orco, vec3 attr_uv,\n        out vec3 generated, out vec3 normal, out vec3 uv, out vec3 object,\n        out vec3 camera, out vec3 window, out vec3 reflection)\n{\n\tvec4 v = (projection_matrix[3][3] == 0.0) ? vec4(I, 1.0) : vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 co_homogenous = v;\n\n\tvec4 co = vec4(co_homogenous.xyz / co_homogenous.w, 0.0);\n\n\tco = normalize(co);\n\tvec3 coords = (view_imat3 * co.xyz);\n\n\tgenerated = coords;\n\tnormal = -coords;\n\tuv = vec3(attr_uv.xy, 0.0);\n\tobject = coords;\n\n\tcamera = vec3(co.xy, -co.z);\n\twindow = (projection_matrix[3][3] == 0.0) ?\n             vec3(mtex_2d_mapping(I).xy * camerafac.xy + camerafac.zw, 0.0) :\n             vec3(vec2(0.5) * camerafac.xy + camerafac.zw, 0.0);\n\n\treflection = -coords;\n}\n\n/* textures */\n\nfloat calc_gradient(vec3 p, int gradient_type)\n{\n\tfloat x, y, z;\n\tx = p.x;\n\ty = p.y;\n\tz = p.z;\n\tif (gradient_type == 0) {  /* linear */\n\t\treturn x;\n\t}\n\telse if (gradient_type == 1) {  /* quadratic */\n\t\tfloat r = max(x, 0.0);\n\t\treturn r * r;\n\t}\n\telse if (gradient_type == 2) {  /* easing */\n\t\tfloat r = min(max(x, 0.0), 1.0);\n\t\tfloat t = r * r;\n\t\treturn (3.0 * t - 2.0 * t * r);\n\t}\n\telse if (gradient_type == 3) {  /* diagonal */\n\t\treturn (x + y) * 0.5;\n\t}\n\telse if (gradient_type == 4) {  /* radial */\n\t\treturn atan(y, x) / (M_PI * 2.0) + 0.5;\n\t}\n\telse {\n\t\tfloat r = max(1.0 - sqrt(x * x + y * y + z * z), 0.0);\n\t\tif (gradient_type == 5) {  /* quadratic sphere */\n\t\t\treturn r * r;\n\t\t}\n\t\telse if (gradient_type == 6) {  /* sphere */\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn 0.0;\n}\n\nvoid node_tex_gradient(vec3 co, float gradient_type, out vec4 color, out float fac)\n{\n\tfloat f = calc_gradient(co, int(gradient_type));\n\tf = clamp(f, 0.0, 1.0);\n\n\tcolor = vec4(f, f, f, 1.0);\n\tfac = f;\n}\n\nvoid node_tex_checker(vec3 co, vec4 color1, vec4 color2, float scale, out vec4 color, out float fac)\n{\n\tvec3 p = co * scale;\n\n\t/* Prevent precision issues on unit coordinates. */\n\tp.x = (p.x + 0.000001) * 0.999999;\n\tp.y = (p.y + 0.000001) * 0.999999;\n\tp.z = (p.z + 0.000001) * 0.999999;\n\n\t\n    float xi = (abs(floor(p.x)));\n\tfloat yi = (abs(floor(p.y)));\n\tfloat zi = (abs(floor(p.z)));\n\tbool check = ((mod(xi, 2.0) == mod(yi, 2.0)) == bool(mod(zi, 2.0)));\n\tcolor = check ? color1 : color2;\n\tfac = check ? 1.0 : 0.0;\n    }\n    void original_checker(vec3 p, vec4 color1, vec4 color2, float scale, out vec4 color, out float fac){\n    int xi;\n    \n\tint yi = int(abs(floor(p.y)));\n\tint zi = int(abs(floor(p.z)));\n\n\tbool check = true;\n\n\tcolor = check ? color1 : color2;\n\tfac = check ? 1.0 : 0.0;\n}\n\n#ifdef BIT_OPERATIONS\nvec2 calc_brick_texture(vec3 p, float mortar_size, float bias,\n                        float brick_width, float row_height,\n                        float offset_amount, int offset_frequency,\n                        float squash_amount, int squash_frequency)\n{\n\tint bricknum, rownum;\n\tfloat offset = 0.0;\n\tfloat x, y;\n\n\trownum = floor_to_int(p.y / row_height);\n\n\tif (offset_frequency != 0 && squash_frequency != 0.0) {\n\t\tbrick_width *= (rownum % squash_frequency != 0.0) ? 1.0 : squash_amount; /* squash */\n\t\toffset = (rownum % offset_frequency != 0.0) ? 0.0 : (brick_width * offset_amount); /* offset */\n\t}\n\n\tbricknum = floor_to_int((p.x + offset) / brick_width);\n\n\tx = (p.x + offset) - brick_width * bricknum;\n\ty = p.y - row_height * rownum;\n\n\treturn vec2(clamp((integer_noise((rownum << 16) + (bricknum & 0xFFFF)) + bias), 0.0, 1.0),\n\t            (x < mortar_size || y < mortar_size ||\n\t             x > (brick_width - mortar_size) ||\n\t             y > (row_height - mortar_size)) ? 1.0 : 0.0);\n}\n#endif\n\nvoid node_tex_brick(vec3 co,\n                    vec4 color1, vec4 color2,\n                    vec4 mortar, float scale,\n                    float mortar_size, float bias,\n                    float brick_width, float row_height,\n                    float offset_amount, float offset_frequency,\n                    float squash_amount, float squash_frequency,\n                    out vec4 color, out float fac)\n{\n#ifdef BIT_OPERATIONS\n\tvec2 f2 = calc_brick_texture(co * scale,\n\t                             mortar_size, bias,\n\t                             brick_width, row_height,\n\t                             offset_amount, int(offset_frequency),\n\t                             squash_amount, int(squash_frequency));\n\tfloat tint = f2.x;\n\tfloat f = f2.y;\n\tif (f != 1.0) {\n\t\tfloat facm = 1.0 - tint;\n\t\tcolor1 = facm * color1 + tint * color2;\n\t}\n\tcolor = (f == 1.0) ? mortar : color1;\n\tfac = f;\n#else\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n#endif\n}\n\nvoid node_tex_clouds(vec3 co, float size, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_environment_equirectangular(vec3 co, sampler2D ima, out vec4 color)\n{\n\tvec3 nco = normalize(co);\n\tfloat u = (view_imat3[2][0]<0.0)?\n        -atan(nco.y, nco.x) / (2.0 * M_PI) + 0.5:\n        -atan(-nco.y, -nco.x) / (2.0 * M_PI);\n\tfloat v = atan(nco.z, hypot(nco.x, nco.y)) / M_PI + 0.5;\n\n\tcolor = texture2D(ima, vec2(u, v));\n}\n\nvoid node_tex_environment_mirror_ball(vec3 co, sampler2D ima, out vec4 color)\n{\n\tvec3 nco = normalize(co);\n\n\tnco.y -= 1.0;\n\n\tfloat div = 2.0 * sqrt(max(-0.5 * nco.y, 0.0));\n\tif(div > 0.0)\n\t\tnco /= div;\n\n\tfloat u = 0.5 * (nco.x + 1.0);\n\tfloat v = 0.5 * (nco.z + 1.0);\n\n\tcolor = texture2D(ima, vec2(u, v));\n}\n\nvoid node_tex_environment_empty(vec3 co, out vec4 color)\n{\n\tcolor = vec4(1.0, 0.0, 1.0, 1.0);\n}\n\nvoid node_tex_image(vec3 co, sampler2D ima, out vec4 color, out float alpha)\n{\n\tcolor = texture2D(ima, co.xy);\n\talpha = color.a;\n}\n\nvoid node_tex_image_closest(vec3 co, sampler2D ima, vec2 res, out vec4 color, out float alpha)\n{\n#if __VERSION__ < 130\n\tcolor = texture2DLodEXT(ima, (floor(co.xy * res) + 0.5) / res, 0.0);\n#else\n\tcolor = texelFetch(ima, ivec2(fract(co.xy) * res), 0);\n#endif\n\talpha = color.a;\n}\n\nvoid node_tex_image_box(vec3 texco,\n                        vec3 nob,\n                        sampler2D ima,\n                        float blend,\n                        out vec4 color,\n                        out float alpha)\n{\n\t/* project from direction vector to barycentric coordinates in triangles */\n\tnob = vec3(abs(nob.x), abs(nob.y), abs(nob.z));\n\tnob /= (nob.x + nob.y + nob.z);\n\n\t/* basic idea is to think of this as a triangle, each corner representing\n\t * one of the 3 faces of the cube. in the corners we have single textures,\n\t * in between we blend between two textures, and in the middle we a blend\n\t * between three textures.\n\t *\n\t * the Nxyz values are the barycentric coordinates in an equilateral\n\t * triangle, which in case of blending, in the middle has a smaller\n\t * equilateral triangle where 3 textures blend. this divides things into\n\t * 7 zones, with an if () test for each zone */\n\n\tvec3 weight = vec3(0.0, 0.0, 0.0);\n\tfloat limit = 0.5 * (1.0 + blend);\n\n\t/* first test for corners with single texture */\n\tif (nob.x > limit * (nob.x + nob.y) && nob.x > limit * (nob.x + nob.z)) {\n\t\tweight.x = 1.0;\n\t}\n\telse if (nob.y > limit * (nob.x + nob.y) && nob.y > limit * (nob.y + nob.z)) {\n\t\tweight.y = 1.0;\n\t}\n\telse if (nob.z > limit * (nob.x + nob.z) && nob.z > limit * (nob.y + nob.z)) {\n\t\tweight.z = 1.0;\n\t}\n\telse if (blend > 0.0) {\n\t\t/* in case of blending, test for mixes between two textures */\n\t\tif (nob.z < (1.0 - limit) * (nob.y + nob.x)) {\n\t\t\tweight.x = nob.x / (nob.x + nob.y);\n\t\t\tweight.x = clamp((weight.x - 0.5 * (1.0 - blend)) / blend, 0.0, 1.0);\n\t\t\tweight.y = 1.0 - weight.x;\n\t\t}\n\t\telse if (nob.x < (1.0 - limit) * (nob.y + nob.z)) {\n\t\t\tweight.y = nob.y / (nob.y + nob.z);\n\t\t\tweight.y = clamp((weight.y - 0.5 * (1.0 - blend)) / blend, 0.0, 1.0);\n\t\t\tweight.z = 1.0 - weight.y;\n\t\t}\n\t\telse if (nob.y < (1.0 - limit) * (nob.x + nob.z)) {\n\t\t\tweight.x = nob.x / (nob.x + nob.z);\n\t\t\tweight.x = clamp((weight.x - 0.5 * (1.0 - blend)) / blend, 0.0, 1.0);\n\t\t\tweight.z = 1.0 - weight.x;\n\t\t}\n\t\telse {\n\t\t\t/* last case, we have a mix between three */\n\t\t\tweight.x = ((2.0 - limit) * nob.x + (limit - 1.0)) / (2.0 * limit - 1.0);\n\t\t\tweight.y = ((2.0 - limit) * nob.y + (limit - 1.0)) / (2.0 * limit - 1.0);\n\t\t\tweight.z = ((2.0 - limit) * nob.z + (limit - 1.0)) / (2.0 * limit - 1.0);\n\t\t}\n\t}\n\telse {\n\t\t/* Desperate mode, no valid choice anyway, fallback to one side.*/\n\t\tweight.x = 1.0;\n\t}\n\n\tcolor = vec4(0);\n\tif (weight.x > 0.0) {\n\t\tcolor += weight.x * texture2D(ima, texco.yz);\n\t}\n\tif (weight.y > 0.0) {\n\t\tcolor += weight.y * texture2D(ima, texco.xz);\n\t}\n\tif (weight.z > 0.0) {\n\t\tcolor += weight.z * texture2D(ima, texco.yx);\n\t}\n\n\talpha = color.a;\n}\n\nvoid node_tex_image_empty(vec3 co, out vec4 color, out float alpha)\n{\n\tcolor = vec4(0.0);\n\talpha = 0.0;\n}\n\nvoid node_tex_magic(vec3 co, float scale, float distortion, float depth, out vec4 color, out float fac)\n{\n\tvec3 p = co * scale;\n\tfloat x = sin((p.x + p.y + p.z) * 5.0);\n\tfloat y = cos((-p.x + p.y - p.z) * 5.0);\n\tfloat z = -cos((-p.x - p.y + p.z) * 5.0);\n\n\tif (depth > 0.0) {\n\t\tx *= distortion;\n\t\ty *= distortion;\n\t\tz *= distortion;\n\t\ty = -cos(x - y + z);\n\t\ty *= distortion;\n\t\tif (depth > 1.0) {\n\t\t\tx = cos(x - y - z);\n\t\t\tx *= distortion;\n\t\t\tif (depth > 2.0) {\n\t\t\t\tz = sin(-x - y - z);\n\t\t\t\tz *= distortion;\n\t\t\t\tif (depth > 3.0) {\n\t\t\t\t\tx = -cos(-x + y - z);\n\t\t\t\t\tx *= distortion;\n\t\t\t\t\tif (depth > 4.0) {\n\t\t\t\t\t\ty = -sin(-x + y + z);\n\t\t\t\t\t\ty *= distortion;\n\t\t\t\t\t\tif (depth > 5.0) {\n\t\t\t\t\t\t\ty = -cos(-x + y + z);\n\t\t\t\t\t\t\ty *= distortion;\n\t\t\t\t\t\t\tif (depth > 6.0) {\n\t\t\t\t\t\t\t\tx = cos(x + y + z);\n\t\t\t\t\t\t\t\tx *= distortion;\n\t\t\t\t\t\t\t\tif (depth > 7.0) {\n\t\t\t\t\t\t\t\t\tz = sin(x + y - z);\n\t\t\t\t\t\t\t\t\tz *= distortion;\n\t\t\t\t\t\t\t\t\tif (depth > 8.0) {\n\t\t\t\t\t\t\t\t\t\tx = -cos(-x - y + z);\n\t\t\t\t\t\t\t\t\t\tx *= distortion;\n\t\t\t\t\t\t\t\t\t\tif (depth > 9.0) {\n\t\t\t\t\t\t\t\t\t\t\ty = -sin(x - y + z);\n\t\t\t\t\t\t\t\t\t\t\ty *= distortion;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (distortion != 0.0) {\n\t\tdistortion *= 2.0;\n\t\tx /= distortion;\n\t\ty /= distortion;\n\t\tz /= distortion;\n\t}\n\n\tcolor = vec4(0.5 - x, 0.5 - y, 0.5 - z, 1.0);\n\tfac = (color.x + color.y + color.z) / 3.0;\n}\n\n#ifdef BIT_OPERATIONS\nfloat noise_fade(float t)\n{\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat noise_scale3(float result)\n{\n\treturn 0.9820 * result;\n}\n\nfloat noise_nerp(float t, float a, float b)\n{\n\treturn (1.0 - t) * a + t * b;\n}\n\nfloat noise_grad(uint hash, float x, float y, float z)\n{\n\tuint h = hash & 15;\n\tfloat u = h < 8 ? x : y;\n\tfloat vt = ((h == 12) || (h == 14)) ? x : z;\n\tfloat v = h < 4 ? y : vt;\n\treturn (((h & 1) != 0) ? -u : u) + (((h & 2) != 0) ? -v : v);\n}\n\nfloat noise_perlin(float x, float y, float z)\n{\n\tint X; float fx = floorfrac(x, X);\n\tint Y; float fy = floorfrac(y, Y);\n\tint Z; float fz = floorfrac(z, Z);\n\n\tfloat u = noise_fade(fx);\n\tfloat v = noise_fade(fy);\n\tfloat w = noise_fade(fz);\n\n\tfloat result;\n\n\tresult = noise_nerp(w, noise_nerp(v, noise_nerp(u, noise_grad(hash(X, Y, Z), fx, fy, fz),\n\t                                                noise_grad(hash(X + 1, Y, Z), fx - 1.0, fy, fz)),\n\t                                  noise_nerp(u, noise_grad(hash(X, Y + 1, Z), fx, fy - 1.0, fz),\n\t                                             noise_grad(hash(X + 1, Y + 1, Z), fx - 1.0, fy - 1.0, fz))),\n\t                    noise_nerp(v, noise_nerp(u, noise_grad(hash(X, Y, Z + 1), fx, fy, fz - 1.0),\n\t                                             noise_grad(hash(X + 1, Y, Z + 1), fx - 1.0, fy, fz - 1.0)),\n\t                               noise_nerp(u, noise_grad(hash(X, Y + 1, Z + 1), fx, fy - 1.0, fz - 1.0),\n\t                                          noise_grad(hash(X + 1, Y + 1, Z + 1), fx - 1.0, fy - 1.0, fz - 1.0))));\n\treturn noise_scale3(result);\n}\n\nfloat noise(vec3 p)\n{\n\treturn 0.5 * noise_perlin(p.x, p.y, p.z) + 0.5;\n}\n\nfloat snoise(vec3 p)\n{\n\treturn noise_perlin(p.x, p.y, p.z);\n}\n\nfloat noise_turbulence(vec3 p, float octaves, int hard)\n{\n\tfloat fscale = 1.0;\n\tfloat amp = 1.0;\n\tfloat sum = 0.0;\n\tint i, n;\n\toctaves = clamp(octaves, 0.0, 16.0);\n\tn = int(octaves);\n\tfor (i = 0; i <= n; i++) {\n\t\tfloat t = noise(fscale * p);\n\t\tif (hard != 0.0) {\n\t\t\tt = abs(2.0 * t - 1.0);\n\t\t}\n\t\tsum += t * amp;\n\t\tamp *= 0.5;\n\t\tfscale *= 2.0;\n\t}\n\tfloat rmd = octaves - floor(octaves);\n\tif  (rmd != 0.0) {\n\t\tfloat t = noise(fscale * p);\n\t\tif (hard != 0.0) {\n\t\t\tt = abs(2.0 * t - 1.0);\n\t\t}\n\t\tfloat sum2 = sum + t * amp;\n\t\tsum *= (float(1 << n) / float((1 << (n + 1)) - 1.0));\n\t\tsum2 *= (float(1 << (n + 1)) / float((1 << (n + 2)) - 1.0));\n\t\treturn (1.0 - rmd) * sum + rmd * sum2;\n\t}\n\telse {\n\t\tsum *= (float(1 << n) / float((1 << (n + 1)) - 1.0));\n\t\treturn sum;\n\t}\n}\n#endif  // BIT_OPERATIONS\n\nvoid node_tex_noise(vec3 co, float scale, float detail, float distortion, out vec4 color, out float fac)\n{\n#ifdef BIT_OPERATIONS\n\tvec3 p = co * scale;\n\tint hard = 0;\n\tif (distortion != 0.0) {\n\t\tvec3 r, offset = vec3(13.5, 13.5, 13.5);\n\t\tr.x = noise(p + offset) * distortion;\n\t\tr.y = noise(p) * distortion;\n\t\tr.z = noise(p - offset) * distortion;\n\t\tp += r;\n\t}\n\n\tfac = noise_turbulence(p, detail, hard);\n\tcolor = vec4(fac,\n\t             noise_turbulence(vec3(p.y, p.x, p.z), detail, hard),\n\t             noise_turbulence(vec3(p.y, p.z, p.x), detail, hard),\n\t             1);\n#else  // BIT_OPERATIONS\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n#endif  // BIT_OPERATIONS\n}\n\n\n#ifdef BIT_OPERATIONS\n\n/* Musgrave fBm\n *\n * H: fractal increment parameter\n * lacunarity: gap between successive frequencies\n * octaves: number of frequencies in the fBm\n *\n * from \"Texturing and Modelling: A procedural approach\"\n */\n\nfloat noise_musgrave_fBm(vec3 p, float H, float lacunarity, float octaves)\n{\n\tfloat rmd;\n\tfloat value = 0.0;\n\tfloat pwr = 1.0;\n\tfloat pwHL = pow(lacunarity, -H);\n\tint i;\n\n\tfor (i = 0; i < int(octaves); i++) {\n\t\tvalue += snoise(p) * pwr;\n\t\tpwr *= pwHL;\n\t\tp *= lacunarity;\n\t}\n\n\trmd = octaves - floor(octaves);\n\tif (rmd != 0.0)\n\t\tvalue += rmd * snoise(p) * pwr;\n\n\treturn value;\n}\n\n/* Musgrave Multifractal\n *\n * H: highest fractal dimension\n * lacunarity: gap between successive frequencies\n * octaves: number of frequencies in the fBm\n */\n\nfloat noise_musgrave_multi_fractal(vec3 p, float H, float lacunarity, float octaves)\n{\n\tfloat rmd;\n\tfloat value = 1.0;\n\tfloat pwr = 1.0;\n\tfloat pwHL = pow(lacunarity, -H);\n\tint i;\n\n\tfor (i = 0; i < int(octaves); i++) {\n\t\tvalue *= (pwr * snoise(p) + 1.0);\n\t\tpwr *= pwHL;\n\t\tp *= lacunarity;\n\t}\n\n\trmd = octaves - floor(octaves);\n\tif (rmd != 0.0)\n\t\tvalue *= (rmd * pwr * snoise(p) + 1.0); /* correct? */\n\n\treturn value;\n}\n\n/* Musgrave Heterogeneous Terrain\n *\n * H: fractal dimension of the roughest area\n * lacunarity: gap between successive frequencies\n * octaves: number of frequencies in the fBm\n * offset: raises the terrain from `sea level'\n */\n\nfloat noise_musgrave_hetero_terrain(vec3 p, float H, float lacunarity, float octaves, float offset)\n{\n\tfloat value, increment, rmd;\n\tfloat pwHL = pow(lacunarity, -H);\n\tfloat pwr = pwHL;\n\tint i;\n\n\t/* first unscaled octave of function; later octaves are scaled */\n\tvalue = offset + snoise(p);\n\tp *= lacunarity;\n\n\tfor (i = 1; i < int(octaves); i++) {\n\t\tincrement = (snoise(p) + offset) * pwr * value;\n\t\tvalue += increment;\n\t\tpwr *= pwHL;\n\t\tp *= lacunarity;\n\t}\n\n\trmd = octaves - floor(octaves);\n\tif (rmd != 0.0) {\n\t\tincrement = (snoise(p) + offset) * pwr * value;\n\t\tvalue += rmd * increment;\n\t}\n\n\treturn value;\n}\n\n/* Hybrid Additive/Multiplicative Multifractal Terrain\n *\n * H: fractal dimension of the roughest area\n * lacunarity: gap between successive frequencies\n * octaves: number of frequencies in the fBm\n * offset: raises the terrain from `sea level'\n */\n\nfloat noise_musgrave_hybrid_multi_fractal(vec3 p, float H, float lacunarity, float octaves, float offset, float gain)\n{\n\tfloat result, signal, weight, rmd;\n\tfloat pwHL = pow(lacunarity, -H);\n\tfloat pwr = pwHL;\n\tint i;\n\n\tresult = snoise(p) + offset;\n\tweight = gain * result;\n\tp *= lacunarity;\n\n\tfor (i = 1; (weight > 0.001) && (i < int(octaves)); i++) {\n\t\tif (weight > 1.0)\n\t\t\tweight = 1.0;\n\n\t\tsignal = (snoise(p) + offset) * pwr;\n\t\tpwr *= pwHL;\n\t\tresult += weight * signal;\n\t\tweight *= gain * signal;\n\t\tp *= lacunarity;\n\t}\n\n\trmd = octaves - floor(octaves);\n\tif (rmd != 0.0)\n\t\tresult += rmd * ((snoise(p) + offset) * pwr);\n\n\treturn result;\n}\n\n/* Ridged Multifractal Terrain\n *\n * H: fractal dimension of the roughest area\n * lacunarity: gap between successive frequencies\n * octaves: number of frequencies in the fBm\n * offset: raises the terrain from `sea level'\n */\n\nfloat noise_musgrave_ridged_multi_fractal(vec3 p, float H, float lacunarity, float octaves, float offset, float gain)\n{\n\tfloat result, signal, weight;\n\tfloat pwHL = pow(lacunarity, -H);\n\tfloat pwr = pwHL;\n\tint i;\n\n\tsignal = offset - abs(snoise(p));\n\tsignal *= signal;\n\tresult = signal;\n\tweight = 1.0;\n\n\tfor (i = 1; i < int(octaves); i++) {\n\t\tp *= lacunarity;\n\t\tweight = clamp(signal * gain, 0.0, 1.0);\n\t\tsignal = offset - abs(snoise(p));\n\t\tsignal *= signal;\n\t\tsignal *= weight;\n\t\tresult += signal * pwr;\n\t\tpwr *= pwHL;\n\t}\n\n\treturn result;\n}\n\nfloat svm_musgrave(int type,\n                   float dimension,\n                   float lacunarity,\n                   float octaves,\n                   float offset,\n                   float intensity,\n                   float gain,\n                   vec3 p)\n{\n\tif (type == 0 /*NODE_MUSGRAVE_MULTIFRACTAL*/)\n\t\treturn intensity * noise_musgrave_multi_fractal(p, dimension, lacunarity, octaves);\n\telse if (type == 1 /*NODE_MUSGRAVE_FBM*/)\n\t\treturn intensity * noise_musgrave_fBm(p, dimension, lacunarity, octaves);\n\telse if (type == 2 /*NODE_MUSGRAVE_HYBRID_MULTIFRACTAL*/)\n\t\treturn intensity * noise_musgrave_hybrid_multi_fractal(p, dimension, lacunarity, octaves, offset, gain);\n\telse if (type == 3 /*NODE_MUSGRAVE_RIDGED_MULTIFRACTAL*/)\n\t\treturn intensity * noise_musgrave_ridged_multi_fractal(p, dimension, lacunarity, octaves, offset, gain);\n\telse if (type == 4 /*NODE_MUSGRAVE_HETERO_TERRAIN*/)\n\t\treturn intensity * noise_musgrave_hetero_terrain(p, dimension, lacunarity, octaves, offset);\n\treturn 0.0;\n}\n#endif  // #ifdef BIT_OPERATIONS\n\nvoid node_tex_musgrave(vec3 co,\n                       float scale,\n                       float detail,\n                       float dimension,\n                       float lacunarity,\n                       float offset,\n                       float gain,\n                       float type,\n                       out vec4 color,\n                       out float fac)\n{\n#ifdef BIT_OPERATIONS\n\tfac = svm_musgrave(int(type),\n\t                   dimension,\n\t                   lacunarity,\n\t                   detail,\n\t                   offset,\n\t                   1.0,\n\t                   gain,\n\t                   co * scale);\n#else\n\tfac = 1.0;\n#endif\n\n\tcolor = vec4(fac, fac, fac, 1.0);\n}\n\nvoid node_tex_sky(vec3 co, out vec4 color)\n{\n\tcolor = vec4(1.0);\n}\n\nvoid node_tex_voronoi(vec3 co, float scale, float coloring, out vec4 color, out float fac)\n{\n#ifdef BIT_OPERATIONS\n\tvec3 p = co * scale;\n\tint xx, yy, zz, xi, yi, zi;\n\tfloat da[4];\n\tvec3 pa[4];\n\n\txi = floor_to_int(p[0]);\n\tyi = floor_to_int(p[1]);\n\tzi = floor_to_int(p[2]);\n\n\tda[0] = 1e+10;\n\tda[1] = 1e+10;\n\tda[2] = 1e+10;\n\tda[3] = 1e+10;\n\n\tfor (xx = xi - 1; xx <= xi + 1; xx++) {\n\t\tfor (yy = yi - 1; yy <= yi + 1; yy++) {\n\t\t\tfor (zz = zi - 1; zz <= zi + 1; zz++) {\n\t\t\t\tvec3 ip = vec3(xx, yy, zz);\n\t\t\t\tvec3 vp = cellnoise_color(ip);\n\t\t\t\tvec3 pd = p - (vp + ip);\n\t\t\t\tfloat d = dot(pd, pd);\n\t\t\t\tvp += vec3(xx, yy, zz);\n\t\t\t\tif (d < da[0]) {\n\t\t\t\t\tda[3] = da[2];\n\t\t\t\t\tda[2] = da[1];\n\t\t\t\t\tda[1] = da[0];\n\t\t\t\t\tda[0] = d;\n\t\t\t\t\tpa[3] = pa[2];\n\t\t\t\t\tpa[2] = pa[1];\n\t\t\t\t\tpa[1] = pa[0];\n\t\t\t\t\tpa[0] = vp;\n\t\t\t\t}\n\t\t\t\telse if (d < da[1]) {\n\t\t\t\t\tda[3] = da[2];\n\t\t\t\t\tda[2] = da[1];\n\t\t\t\t\tda[1] = d;\n\n\t\t\t\t\tpa[3] = pa[2];\n\t\t\t\t\tpa[2] = pa[1];\n\t\t\t\t\tpa[1] = vp;\n\t\t\t\t}\n\t\t\t\telse if (d < da[2]) {\n\t\t\t\t\tda[3] = da[2];\n\t\t\t\t\tda[2] = d;\n\n\t\t\t\t\tpa[3] = pa[2];\n\t\t\t\t\tpa[2] = vp;\n\t\t\t\t}\n\t\t\t\telse if (d < da[3]) {\n\t\t\t\t\tda[3] = d;\n\t\t\t\t\tpa[3] = vp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (coloring == 0.0) {\n\t\tfac = abs(da[0]);\n\t\tcolor = vec4(fac, fac, fac, 1);\n\t}\n\telse {\n\t\tcolor = vec4(cellnoise_color(pa[0]), 1);\n\t\tfac = (color.x + color.y + color.z) * (1.0 / 3.0);\n\t}\n#else  // BIT_OPERATIONS\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n#endif  // BIT_OPERATIONS\n}\n\n#ifdef BIT_OPERATIONS\nfloat calc_wave(vec3 p, float distortion, float detail, float detail_scale, int wave_type, int wave_profile)\n{\n\tfloat n;\n\n\tif (wave_type == 0.0) /* type bands */\n\t\tn = (p.x + p.y + p.z) * 10.0;\n\telse /* type rings */\n\t\tn = length(p) * 20.0;\n\n\tif (distortion != 0.0)\n\t\tn += distortion * noise_turbulence(p * detail_scale, detail, 0);\n\n\tif (wave_profile == 0.0) { /* profile sin */\n\t\treturn 0.5 + 0.5 * sin(n);\n\t}\n\telse { /* profile saw */\n\t\tn /= 2.0 * M_PI;\n\t\tn -= int(n);\n\t\treturn (n < 0.0) ? n + 1.0 : n;\n\t}\n}\n#endif  // BIT_OPERATIONS\n\nvoid node_tex_wave(\n        vec3 co, float scale, float distortion, float detail, float detail_scale, float wave_type, float wave_profile,\n        out vec4 color, out float fac)\n{\n#ifdef BIT_OPERATIONS\n\tfloat f;\n\tf = calc_wave(co * scale, distortion, detail, detail_scale, int(wave_type), int(wave_profile));\n\n\tcolor = vec4(f, f, f, 1.0);\n\tfac = f;\n#else  // BIT_OPERATIONS\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n#endif  // BIT_OPERATIONS\n}\n\n/* light path */\n\nvoid node_light_path(\n\tout float is_camera_ray,\n\tout float is_shadow_ray,\n\tout float is_diffuse_ray,\n\tout float is_glossy_ray,\n\tout float is_singular_ray,\n\tout float is_reflection_ray,\n\tout float is_transmission_ray,\n\tout float ray_length,\n\tout float ray_depth,\n\tout float transparent_depth,\n\tout float transmission_depth)\n{\n\tis_camera_ray = 1.0;\n\tis_shadow_ray = 0.0;\n\tis_diffuse_ray = 0.0;\n\tis_glossy_ray = 0.0;\n\tis_singular_ray = 0.0;\n\tis_reflection_ray = 0.0;\n\tis_transmission_ray = 0.0;\n\tray_length = 1.0;\n\tray_depth = 1.0;\n\ttransparent_depth = 1.0;\n\ttransmission_depth = 1.0;\n}\n\nvoid node_light_falloff(float strength, float tsmooth, vec4 lamppos, vec3 pos, out float quadratic, out float linear, out float constant)\n{\n\tfloat ray_length = length(lamppos.xyz - pos);\n\n\tif (tsmooth > 0.0) {\n\t\tfloat squared = ray_length * ray_length;\n\t\tstrength *= squared / (tsmooth + squared);\n\t}\n\n\tquadratic = strength;\n\tlinear = (strength * ray_length);\n\tconstant = (strength * ray_length * ray_length);\n}\n\nvoid node_object_info(mat4 objmat, out vec3 location, out float object_index, out float material_index, out float random)\n{\n\tlocation = objmat[3].xyz;\n\tobject_index = 0.0;\n\tmaterial_index = 0.0;\n\trandom = 0.0;\n}\n\nvoid node_normal_map(vec4 tangent, vec3 normal, vec3 texnormal, out vec3 outnormal)\n{\n\tvec3 B = tangent.w * cross(normal, tangent.xyz);\n\n\toutnormal = texnormal.x * tangent.xyz + texnormal.y * B + texnormal.z * normal;\n\toutnormal = normalize(outnormal);\n}\n\nvoid node_bump(float strength, float dist, float height, vec3 N, vec3 surf_pos, float invert, out vec3 result)\n{\n\tif (invert != 0.0) {\n\t\tdist *= -1.0;\n\t}\n\tvec3 dPdx = dFdx(surf_pos);\n\tvec3 dPdy = dFdy(surf_pos);\n\n\t/* Get surface tangents from normal. */\n\tvec3 Rx = cross(dPdy, N);\n\tvec3 Ry = cross(N, dPdx);\n\n\t/* Compute surface gradient and determinant. */\n\tfloat det = dot(dPdx, Rx);\n\tfloat absdet = abs(det);\n\n\tfloat dHdx = dFdx(height);\n\tfloat dHdy = dFdy(height);\n\tvec3 surfgrad = dHdx * Rx + dHdy * Ry;\n\n\tstrength = max(strength, 0.0);\n\n\tresult = normalize(absdet * N - dist * sign(det) * surfgrad);\n\tresult = normalize(strength * result + (1.0 - strength) * N);\n}\n\n/* output */\n\nvoid node_output_material(vec4 surface, vec4 volume, float displacement, out vec4 result)\n{\n\tresult = surface;\n}\n\nvoid node_output_world(vec4 surface, vec4 volume, out vec4 result)\n{\n\tresult = surface;\n}\n\nvoid node_output_lamp(vec4 surface, out vec4 result)\n{\n\tresult = surface;\n}\n","type":"SHADER_LIB"},{"filter":null,"type":"TEXTURE","formats":{"jpeg":[{"file_size":8311260,"height":4096,"width":8192,"file_name":"PANO_20170709_153604.jpg-8192x4096.jpg"}]},"use_mipmap":null,"name":"PANO_20170709_153604.jpg","wrap":null},{"filter":null,"type":"TEXTURE","formats":{"jpeg":[{"file_size":27187492,"height":8192,"width":8192,"file_name":"Fingerprints004_OVERLAY_VAR1_HIRES.jpg-8192x8192.jpg"}]},"use_mipmap":null,"name":"Fingerprints004_OVERLAY_VAR1_HIRES.jpg","wrap":null},{"filter":null,"type":"TEXTURE","formats":{"jpeg":[{"file_size":65802,"height":512,"width":512,"file_name":"roorh.jpg"}]},"use_mipmap":null,"name":"roorh","wrap":null},{"filter":null,"type":"TEXTURE","formats":{"jpeg":[{"file_size":5856144,"height":4096,"width":4096,"file_name":"RustMixedOnPaint012_NRM_6K.jpg-4096x4096.jpg"}]},"use_mipmap":null,"name":"RustMixedOnPaint012_NRM_6K.jpg","wrap":null},{"fragment":"varying vec2 uv0;\nvarying vec4 tangent1;\nvarying vec3 view_normal2;\nvarying vec3 view_position3;\nvarying vec3 orco4;\nuniform sampler2D image0;\nuniform mat4 view_imat1;\nuniform sampler2D image2;\nuniform sampler2D image3;\nuniform mat4 ob_mat4;\nuniform mat4 view_mat5;\nuniform vec3 lamp_dir6;\nuniform float lamp_size7;\nuniform vec4 lamp_col8;\nuniform float lamp_strength9;\nuniform sampler2D lamp_shadow_map10;\nuniform mat4 lamp_shadow_proj11;\nuniform float lamp_shadow_bias12;\nuniform float lamp_bleed_bias13;\nuniform mat4 ob_view_mat14;\nvoid main(){\n    vec4 color4_a;\n    float float_b;\n    vec3 vec3_c;\n    vec3 vec3_d;\n    vec3 vec3_e;\n    vec3 vec3_f;\n    vec3 vec3_g;\n    vec3 vec3_h;\n    vec4 color4_i;\n    float float_j;\n    vec4 color4_k;\n    float float_l;\n    vec4 color4_m;\n    float float_n;\n    float float_o;\n    vec4 color4_p;\n    vec3 vec3_q;\n    vec3 vec3_r;\n    vec3 vec3_s;\n    vec3 vec3_t;\n    float float_u;\n    vec3 vec3_v;\n    vec3 vec3_w;\n    float float_x;\n    vec3 color3_y;\n    vec4 color4_z;\n    float float_A;\n    float float_B;\n    vec4 color4_C;\n    vec4 color4_D;\n    vec4 vec4_E;\n    vec4 vec4_F;\n    float float_G;\n    vec3 vec3_H;\n    float float_I;\n    vec4 color4_J;\n    vec4 vec4_K;\n    vec4 vec4_L;\n    vec3 vec3_M;\n    float float_N;\n    vec4 color4_O;\n    vec4 vec4_P;\n    vec4 vec4_Q;\n    float float_R;\n    vec4 color4_S;\n    vec4 color4_T;\n    vec4 vec4_U;\n    node_tex_image(vec3(uv0.xy, 0.0), image0, color4_a, float_b);\n    \n    vec3_h = gl_FrontFacing? view_normal2: -view_normal2;\n    color_to_normal_new_shading(color4_a.xyz, vec3_c);\n    node_normal_map(tangent1, vec3_h, vec3_c, vec3_d);\n    vec_math_mix(max(0.0, (0.30000001192092896)), vec3_d, vec3_h, vec3_f);\n    direction_transform_m4v3(vec3_f, view_imat1, vec3_g);\n    vec3_e = normalize(vec3_g);\n    node_tex_image(vec3(uv0.xy, 0.0), image2, color4_i, float_j);\n    \n    node_tex_image(vec3(uv0.xy, 0.0), image3, color4_k, float_l);\n    \n    \n    hue_sat((0.5), (2.0), (1.0), (1.0), color4_i, color4_m);\n    \n    float_n = convert_rgba_to_float(color4_k)*convert_rgba_to_float(color4_k);\n    node_fresnel((1.4500000476837158), vec3_e, view_position3, float_o);\n    mix_blend(float_o, color4_i, color4_m, color4_p);\n    default_tangent(vec3_h, orco4, ob_mat4, view_mat5, view_imat1, vec3_q);\n    vect_normalize(vec3_q, vec3_r);\n    direction_transform_m4v3(vec3_r, view_imat1, vec3_s);\n    vect_normalize(vec3_s, vec3_t);\n    ssao(view_position3, vec3_h, float_u);\n    viewN_to_shadeN(vec3_h, vec3_w);\n    bsdf_glossy_ggx_sun_light(vec3_w, vec3_r, lamp_dir6, view_position3, vec3(0.0), (1.0), lamp_size7, 0.0, vec2(1.0), mat4(0.0), float_n, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, float_x);\n    shade_mul_value_v3(lamp_strength9, lamp_col8.xyz, color3_y);\n    shade_mul_value((100.0), vec4(color3_y.xyz, 1.0), color4_z);\n    shade_inp(vec3_w, lamp_dir6, float_A);\n    test_shadowbuf_vsm(view_position3, lamp_shadow_map10, lamp_shadow_proj11, lamp_shadow_bias12, lamp_bleed_bias13, float_A, float_B);\n    shade_mul_value(float_B, color4_z, color4_C);\n    shade_madd_clamped(vec4(0.0, 0.0, 0.0, 0.0), vec4(vec3(float_x), 1.0), color4_C, color4_D);\n    env_sampling_glossy_ggx(0.0, view_position3, view_imat1, ob_view_mat14, vec3_e, vec3_t, float_n, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, float_u, vec3_v);\n    shade_clamp_positive(vec4(vec3_v.xyz, 1.0), vec4_E);\n    node_bsdf_opaque(color4_p,vec4_E,color4_D,vec4_F);\n    \n    \n    \n    float_G = convert_rgba_to_float(color4_k)*convert_rgba_to_float(color4_k);\n    bsdf_glossy_ggx_sun_light(vec3_w, vec3_r, lamp_dir6, view_position3, vec3(0.0), (1.0), lamp_size7, 0.0, vec2(1.0), mat4(0.0), float_G, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, float_I);\n    shade_madd_clamped(vec4(0.0, 0.0, 0.0, 0.0), vec4(vec3(float_I), 1.0), color4_C, color4_J);\n    env_sampling_glossy_ggx(0.0, view_position3, view_imat1, ob_view_mat14, vec3_e, vec3_t, float_G, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, float_u, vec3_H);\n    shade_clamp_positive(vec4(vec3_H.xyz, 1.0), vec4_K);\n    node_bsdf_opaque(color4_i,vec4_K,color4_J,vec4_L);\n    bsdf_diffuse_sun_light(vec3_w, vec3_r, lamp_dir6, view_position3, vec3(0.0), (1.0), lamp_size7, 0.0, vec2(1.0), mat4(0.0), float_G, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, float_N);\n    shade_madd_clamped(vec4(0.0, 0.0, 0.0, 0.0), vec4(vec3(float_N), 1.0), color4_C, color4_O);\n    env_sampling_diffuse(0.0, view_position3, view_imat1, ob_view_mat14, vec3_e, vec3_t, float_G, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, float_u, vec3_M);\n    shade_clamp_positive(vec4(vec3_M.xyz, 1.0), vec4_P);\n    node_bsdf_opaque(color4_i,vec4_P,color4_O,vec4_Q);\n    node_fresnel((1.4500000476837158), vec3_e, view_position3, float_R);\n    node_mix_shader(float_R, vec4_Q, vec4_L, color4_S);\n    \n    \n    node_mix_shader((1.0), color4_S, vec4_F, color4_T);\n    \n    \n    linearrgb_to_srgb(color4_T, vec4_U);\n    gl_FragColor = vec4_U;\n}","varyings":[{"datatype":"vec2","varname":"uv0","attname":"","type":"UV"},{"datatype":"vec4","varname":"tangent1","attname":"","type":"TANGENT"},{"datatype":"vec3","varname":"view_normal2","type":"VIEW_NORMAL"},{"datatype":"vec3","varname":"view_position3","type":"VIEW_POSITION"},{"datatype":"vec3","varname":"orco4","type":"ORCO"}],"uniforms":[{"image":"RustMixedOnPaint012_NRM_6K.jpg","datatype":"sampler2D","varname":"image0","type":"IMAGE"},{"datatype":"mat4","varname":"view_imat1","type":"VIEW_IMAT"},{"image":"roorh","datatype":"sampler2D","varname":"image2","type":"IMAGE"},{"image":"Fingerprints004_OVERLAY_VAR1_HIRES.jpg","datatype":"sampler2D","varname":"image3","type":"IMAGE"},{"datatype":"mat4","varname":"ob_mat4","type":"OB_MAT"},{"datatype":"mat4","varname":"view_mat5","type":"VIEW_MAT"},{"datatype":"vec3","lamp":"Lamp","varname":"lamp_dir6","type":"LAMP_DIR"},{"datatype":"float","lamp":"Lamp","varname":"lamp_size7","type":"LAMP_SIZE"},{"datatype":"vec4","lamp":"Lamp","varname":"lamp_col8","type":"LAMP_COL"},{"datatype":"float","lamp":"Lamp","varname":"lamp_strength9","type":"LAMP_STRENGTH"},{"datatype":"sampler2D","lamp":"Lamp","varname":"lamp_shadow_map10","type":"LAMP_SHADOW_MAP"},{"datatype":"mat4","lamp":"Lamp","varname":"lamp_shadow_proj11","type":"LAMP_SHADOW_PROJ"},{"datatype":"float","lamp":"Lamp","varname":"lamp_shadow_bias12","type":"LAMP_SHADOW_BIAS"},{"datatype":"float","lamp":"Lamp","varname":"lamp_bleed_bias13","type":"LAMP_BLEED_BIAS"},{"datatype":"mat4","varname":"ob_view_mat14","type":"OB_VIEW_MAT"}],"type":"MATERIAL","material_type":"BLENDER_CYCLES_PBR","name":"pbr"},{"markers":[],"name":"simple_action","channels":[],"type":"ACTION"}]