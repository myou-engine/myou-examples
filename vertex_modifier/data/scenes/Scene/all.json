[{"background_color":[0.05087608844041824,0.05087608844041824,0.05087608844041824],"sequencer_strips":[],"markers":[],"frame_start":1,"stereo_eye_separation":0.10000000149011612,"active_camera":"Camera","frame_end":250,"debug_physics":false,"gravity":[0,0,-9.800000190734863],"fps":24,"type":"SCENE","stereo":false,"name":"Scene","ambient_color":[0.0,0.0,0.0]},{"passes":[0],"matrix_parent_inverse":[1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0],"properties":{},"collision_compound":false,"collision_mask":255,"dimensions":[16.0,16.0,0.0],"scene":"Scene","no_sleeping":false,"uv_multiplier":1.0,"shape_multiplier":1.0,"hash":"05fabbc5f134771ce9a2f3c057b13d6b42e6cf39","radius":1.0,"elasticity":0.0,"collision_margin":0.03999999910593033,"collision_group":1,"friction_coefficients":[1.0,1.0,1.0],"phy_type":"STATIC","pos":[0.0,0.0,0.0],"avg_poly_area":0.00048828125,"scale":[8.0,8.0,8.0],"bbox":[-1.0,-1.0,0.0,1.0,1.0,0.0],"angular_factor":[1,1,1],"friction":0.5,"type":"MESH","tris_count":8192.0,"rot_mode":"Q","name":"grid","collision_bounds_type":"BOX","stride":24,"mass":1.0,"all_f":false,"materials":["grid"],"center":[0.0,0.0,0.0],"dupli_group":null,"offsets":[0,0,98304,24576],"elements":[["normal"],["uv","UVMap"]],"anisotropic_friction":false,"actions":[],"is_ghost":false,"visible":true,"animation_strips":[],"mesh_name":"grid","position":[0.0,0.0,0.0],"rot":[1.0,0.0,0.0,0.0],"zindex":1,"parent":null,"linear_factor":[1,1,1],"offset_scale":[1,1,1],"form_factor":0.4000000059604645,"parent_bone":"","color":[1.0,1.0,1.0,1.0],"lod_levels":[]},{"matrix_parent_inverse":[1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0],"properties":{},"collision_compound":false,"collision_mask":255,"dimensions":[0.0,0.0,0.0],"scene":"Scene","no_sleeping":false,"clip_start":1.0007989406585693,"tex_size":2880,"radius":1.0,"elasticity":0,"collision_margin":0.05999999865889549,"collision_group":1,"friction_coefficients":[1.0,1.0,1.0],"falloff_distance":29.999982833862305,"phy_type":"STATIC","pos":[4.076245307922363,1.0054539442062378,5.903861999511719],"scale":[1.0,1.0,1.0],"angular_factor":[1,1,1],"friction":0.5,"type":"LAMP","rot_mode":"Q","name":"Lamp","collision_bounds_type":"BOX","mass":1.0,"energy":1,"dupli_group":null,"anisotropic_friction":false,"lamp_type":"SUN","actions":[],"is_ghost":false,"visible":true,"shadow":false,"animation_strips":[],"position":[4.076245307922363,1.0054539442062378,5.903861999511719],"rot":[0.570947527885437,0.16907575726509094,0.27217137813568115,0.7558803558349609],"parent":null,"linear_factor":[1,1,1],"offset_scale":[1,1,1],"clip_end":30.00200080871582,"form_factor":0.4000000059604645,"parent_bone":"","color":[1.0,1.0,1.0],"frustum_size":10.0},{"elasticity":0,"mass":1.0,"ortho_scale":7.314285755157471,"actions":[],"properties":{},"dupli_group":null,"collision_compound":false,"collision_mask":255,"dimensions":[0.0,0.0,0.0],"scene":"Scene","friction_coefficients":[1.0,1.0,1.0],"parent":null,"cam_type":"PERSP","matrix_parent_inverse":[1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0],"is_ghost":false,"sensor_fit":"AUTO","visible":true,"radius":1.0,"clip_end":100.0,"animation_strips":[],"linear_factor":[1,1,1],"collision_group":1,"anisotropic_friction":false,"position":[-22.392019271850586,-23.74361228942871,23.587770462036133],"no_sleeping":false,"rot_mode":"Q","clip_start":0.10000000149011612,"phy_type":"STATIC","pos":[-22.392019271850586,-23.74361228942871,23.587770462036133],"angle":0.8575560450553894,"collision_margin":0.05999999865889549,"offset_scale":[1,1,1],"scale":[1.0,0.9999999403953552,0.9999999403953552],"form_factor":0.4000000059604645,"parent_bone":"","angular_factor":[1,1,1],"color":[0.0,0.0,0.0,0.0],"friction":0.5,"type":"CAMERA","rot":[0.8595263361930847,0.39928433299064636,-0.20467014610767365,-0.24473795294761658],"name":"Camera","collision_bounds_type":"BOX"},{"type":"SHADER_LIB","code":"#extension GL_OES_standard_derivatives : enable\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat exp_blender(float f)\n{\n\treturn pow(2.71828182846, f);\n}\n\nfloat compatible_pow(float x, float y)\n{\n\tif(y == 0.0) /* x^0 -> 1, including 0^0 */\n\t\treturn 1.0;\n\n\t/* glsl pow doesn't accept negative x */\n\tif(x < 0.0) {\n\t\tif(mod(-y, 2.0) == 0.0)\n\t\t\treturn pow(-x, y);\n\t\telse\n\t\t\treturn -pow(-x, y);\n\t}\n\telse if(x == 0.0)\n\t\treturn 0.0;\n\n\treturn pow(x, y);\n}\n\nvoid rgb_to_hsv(vec4 rgb, out vec4 outcol)\n{\n\tfloat cmax, cmin, h, s, v, cdelta;\n\tvec3 c;\n\n\tcmax = max(rgb[0], max(rgb[1], rgb[2]));\n\tcmin = min(rgb[0], min(rgb[1], rgb[2]));\n\tcdelta = cmax-cmin;\n\n\tv = cmax;\n\tif (cmax!=0.0)\n\t\ts = cdelta/cmax;\n\telse {\n\t\ts = 0.0;\n\t\th = 0.0;\n\t}\n\n\tif (s == 0.0) {\n\t\th = 0.0;\n\t}\n\telse {\n\t\tc = (vec3(cmax, cmax, cmax) - rgb.xyz)/cdelta;\n\n\t\tif (rgb.x==cmax) h = c[2] - c[1];\n\t\telse if (rgb.y==cmax) h = 2.0 + c[0] -  c[2];\n\t\telse h = 4.0 + c[1] - c[0];\n\n\t\th /= 6.0;\n\n\t\tif (h<0.0)\n\t\t\th += 1.0;\n\t}\n\n\toutcol = vec4(h, s, v, rgb.w);\n}\n\nvoid hsv_to_rgb(vec4 hsv, out vec4 outcol)\n{\n\tfloat i, f, p, q, t, h, s, v;\n\tvec3 rgb;\n\n\th = hsv[0];\n\ts = hsv[1];\n\tv = hsv[2];\n\n\tif(s==0.0) {\n\t\trgb = vec3(v, v, v);\n\t}\n\telse {\n\t\tif(h==1.0)\n\t\t\th = 0.0;\n\t\t\n\t\th *= 6.0;\n\t\ti = floor(h);\n\t\tf = h - i;\n\t\trgb = vec3(f, f, f);\n\t\tp = v*(1.0-s);\n\t\tq = v*(1.0-(s*f));\n\t\tt = v*(1.0-(s*(1.0-f)));\n\t\t\n\t\tif (i == 0.0) rgb = vec3(v, t, p);\n\t\telse if (i == 1.0) rgb = vec3(q, v, p);\n\t\telse if (i == 2.0) rgb = vec3(p, v, t);\n\t\telse if (i == 3.0) rgb = vec3(p, q, v);\n\t\telse if (i == 4.0) rgb = vec3(t, p, v);\n\t\telse rgb = vec3(v, p, q);\n\t}\n\n\toutcol = vec4(rgb, hsv.w);\n}\n\nfloat srgb_to_linearrgb(float c)\n{\n\tif(c < 0.04045)\n\t\treturn (c < 0.0) ? 0.0: c * (1.0 / 12.92);\n\telse\n\t\treturn pow((c + 0.055)*(1.0/1.055), 2.4);\n}\n\nfloat linearrgb_to_srgb(float c)\n{\n\tif(c < 0.0031308)\n\t\treturn (c < 0.0) ? 0.0: c * 12.92;\n\telse\n\t\treturn 1.055 * pow(c, 1.0/2.4) - 0.055;\n}\n\nvoid srgb_to_linearrgb(vec4 col_from, out vec4 col_to)\n{\n\tcol_to.r = srgb_to_linearrgb(col_from.r);\n\tcol_to.g = srgb_to_linearrgb(col_from.g);\n\tcol_to.b = srgb_to_linearrgb(col_from.b);\n\tcol_to.a = col_from.a;\n}\n\nvoid linearrgb_to_srgb(vec4 col_from, out vec4 col_to)\n{\n\tcol_to.r = linearrgb_to_srgb(col_from.r);\n\tcol_to.g = linearrgb_to_srgb(col_from.g);\n\tcol_to.b = linearrgb_to_srgb(col_from.b);\n\tcol_to.a = col_from.a;\n}\n\n#define M_PI 3.14159265358979323846\n#define M_1_PI 0.31830988618379069\n\n/*********** SHADER NODES ***************/\n\nvoid vcol_attribute(vec4 attvcol, out vec4 vcol)\n{\n\tvcol = vec4(attvcol.x/255.0, attvcol.y/255.0, attvcol.z/255.0, 1.0);\n}\n\nvoid uv_attribute(vec2 attuv, out vec3 uv)\n{\n\tuv = vec3(attuv*2.0 - vec2(1.0, 1.0), 0.0);\n}\n\nvoid geom(vec3 co, vec3 nor, mat4 viewinvmat, vec3 attorco, vec2 attuv, vec4 attvcol, out vec3 global, out vec3 local, out vec3 view, out vec3 orco, out vec3 uv, out vec3 normal, out vec4 vcol, out float vcol_alpha, out float frontback)\n{\n\tlocal = co;\n\tview = (0.0 == 0.0)? normalize(local): vec3(0.0, 0.0, -1.0);\n\tglobal = (viewinvmat*vec4(local, 1.0)).xyz;\n\torco = attorco;\n\tuv_attribute(attuv, uv);\n\tnormal = -normalize(nor);\t/* blender render normal is negated */\n\tvcol_attribute(attvcol, vcol);\n\tvcol_alpha = attvcol.a;\n\tfrontback = (gl_FrontFacing)? 1.0: 0.0;\n}\n\nvoid mapping(vec3 vec, mat4 mat, vec3 minvec, vec3 maxvec, float domin, float domax, out vec3 outvec)\n{\n\toutvec = (mat * vec4(vec, 1.0)).xyz;\n\tif(domin == 1.0)\n\t\toutvec = max(outvec, minvec);\n\tif(domax == 1.0)\n\t\toutvec = min(outvec, maxvec);\n}\n\nvoid camera(vec3 co, out vec3 outview, out float outdepth, out float outdist)\n{\n\toutdepth = abs(co.z);\n\toutdist = length(co);\n\toutview = normalize(co);\n}\n\nvoid lamp(vec4 col, vec3 lv, float dist, vec3 shadow, float visifac, out vec4 outcol, out vec3 outlv, out float outdist, out vec4 outshadow, out float outvisifac)\n{\n\toutcol = col;\n\toutlv = lv;\n\toutdist = dist;\n\toutshadow = vec4(shadow, 1.0);\n\toutvisifac = visifac;\n}\n\nvoid math_add(float val1, float val2, out float outval)\n{\n\toutval = val1 + val2;\n}\n\nvoid math_subtract(float val1, float val2, out float outval)\n{\n\toutval = val1 - val2;\n}\n\nvoid math_multiply(float val1, float val2, out float outval)\n{\n\toutval = val1 * val2;\n}\n\nvoid math_divide(float val1, float val2, out float outval)\n{\n\tif (val2 == 0.0)\n\t\toutval = 0.0;\n\telse\n\t\toutval = val1 / val2;\n}\n\nvoid math_sine(float val, out float outval)\n{\n\toutval = sin(val);\n}\n\nvoid math_cosine(float val, out float outval)\n{\n\toutval = cos(val);\n}\n\nvoid math_tangent(float val, out float outval)\n{\n\toutval = tan(val);\n}\n\nvoid math_asin(float val, out float outval)\n{\n\tif (val <= 1.0 && val >= -1.0)\n\t\toutval = asin(val);\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_acos(float val, out float outval)\n{\n\tif (val <= 1.0 && val >= -1.0)\n\t\toutval = acos(val);\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_atan(float val, out float outval)\n{\n\toutval = atan(val);\n}\n\nvoid math_pow(float val1, float val2, out float outval)\n{\n\tif (val1 >= 0.0) {\n\t\toutval = compatible_pow(val1, val2);\n\t}\n\telse {\n\t\tfloat val2_mod_1 = mod(abs(val2), 1.0);\n\n\t\tif (val2_mod_1 > 0.999 || val2_mod_1 < 0.001)\n\t\t\toutval = compatible_pow(val1, floor(val2 + 0.5));\n\t\telse\n\t\t\toutval = 0.0;\n\t}\n}\n\nvoid math_log(float val1, float val2, out float outval)\n{\n\tif(val1 > 0.0  && val2 > 0.0)\n\t\toutval= log2(val1) / log2(val2);\n\telse\n\t\toutval= 0.0;\n}\n\nvoid math_max(float val1, float val2, out float outval)\n{\n\toutval = max(val1, val2);\n}\n\nvoid math_min(float val1, float val2, out float outval)\n{\n\toutval = min(val1, val2);\n}\n\nvoid math_round(float val, out float outval)\n{\n\toutval= floor(val + 0.5);\n}\n\nvoid math_less_than(float val1, float val2, out float outval)\n{\n\tif(val1 < val2)\n\t\toutval = 1.0;\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_greater_than(float val1, float val2, out float outval)\n{\n\tif(val1 > val2)\n\t\toutval = 1.0;\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_modulo(float val1, float val2, out float outval)\n{\n\tif (val2 == 0.0)\n\t\toutval = 0.0;\n\telse\n\t\toutval = mod(val1, val2);\n}\n\nvoid math_abs(float val1, out float outval)\n{\n    outval = abs(val1);\n}\n\nvoid squeeze(float val, float width, float center, out float outval)\n{\n\toutval = 1.0/(1.0 + pow(2.71828183, -((val-center)*width)));\n}\n\nvoid vec_math_add(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 + v2;\n\toutval = (abs(outvec[0]) + abs(outvec[1]) + abs(outvec[2]))/3.0;\n}\n\nvoid vec_math_sub(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 - v2;\n\toutval = (abs(outvec[0]) + abs(outvec[1]) + abs(outvec[2]))/3.0;\n}\n\nvoid vec_math_average(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 + v2;\n\toutval = length(outvec);\n\toutvec = normalize(outvec);\n}\n\nvoid vec_math_dot(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = vec3(0, 0, 0);\n\toutval = dot(v1, v2);\n}\n\nvoid vec_math_cross(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = cross(v1, v2);\n\toutval = length(outvec);\n}\n\nvoid vec_math_normalize(vec3 v, out vec3 outvec, out float outval)\n{\n\toutval = length(v);\n\toutvec = normalize(v);\n}\n\nvoid vec_math_negate(vec3 v, out vec3 outv)\n{\n\toutv = vec3(0.0)-v;\n}\n\nvoid normal(vec3 dir, vec3 nor, out vec3 outnor, out float outdot)\n{\n\toutnor = nor;\n\toutdot = -dot(dir, nor);\n}\n\nvoid curves_vec(float fac, vec3 vec, sampler2D curvemap, out vec3 outvec)\n{\n\toutvec.x = texture2D(curvemap, vec2((vec.x + 1.0)*0.5, 0.0)).x;\n\toutvec.y = texture2D(curvemap, vec2((vec.y + 1.0)*0.5, 0.0)).y;\n\toutvec.z = texture2D(curvemap, vec2((vec.z + 1.0)*0.5, 0.0)).z;\n\n\tif (fac != 1.0)\n\t\toutvec = (outvec*fac) + (vec*(1.0-fac));\n\n}\n\nvoid curves_rgb(float fac, vec4 col, sampler2D curvemap, out vec4 outcol)\n{\n\toutcol.r = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.r, 0.0)).a, 0.0)).r;\n\toutcol.g = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.g, 0.0)).a, 0.0)).g;\n\toutcol.b = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.b, 0.0)).a, 0.0)).b;\n\n\tif (fac != 1.0)\n\t\toutcol = (outcol*fac) + (col*(1.0-fac));\n\n\toutcol.a = col.a;\n}\n\nvoid set_value(float val, out float outval)\n{\n\toutval = val;\n}\n\nvoid set_rgb(vec3 col, out vec3 outcol)\n{\n\toutcol = col;\n}\n\nvoid set_rgba(vec4 col, out vec4 outcol)\n{\n\toutcol = col;\n}\n\nvoid set_value_zero(out float outval)\n{\n\toutval = 0.0;\n}\n\nvoid set_value_one(out float outval)\n{\n\toutval = 1.0;\n}\n\nvoid set_rgb_zero(out vec3 outval)\n{\n\toutval = vec3(0.0);\n}\n\nvoid set_rgb_one(out vec3 outval)\n{\n\toutval = vec3(1.0);\n}\n\nvoid set_rgba_zero(out vec4 outval)\n{\n\toutval = vec4(0.0);\n}\n\nvoid set_rgba_one(out vec4 outval)\n{\n\toutval = vec4(1.0);\n}\n\nvoid brightness_contrast(vec4 col, float brightness, float contrast, out vec4 outcol)\n{\n\tfloat a = 1.0 + contrast;\n\tfloat b = brightness - contrast*0.5;\n\n\toutcol.r = max(a*col.r + b, 0.0);\n\toutcol.g = max(a*col.g + b, 0.0);\n\toutcol.b = max(a*col.b + b, 0.0);\n\toutcol.a = col.a;\n}\n\nvoid mix_blend(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_add(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 + col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_mult(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 * col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_screen(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = vec4(1.0) - (vec4(facm) + fac*(vec4(1.0) - col2))*(vec4(1.0) - col1);\n\toutcol.a = col1.a;\n}\n\nvoid mix_overlay(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tif(outcol.r < 0.5)\n\t\toutcol.r *= facm + 2.0*fac*col2.r;\n\telse\n\t\toutcol.r = 1.0 - (facm + 2.0*fac*(1.0 - col2.r))*(1.0 - outcol.r);\n\n\tif(outcol.g < 0.5)\n\t\toutcol.g *= facm + 2.0*fac*col2.g;\n\telse\n\t\toutcol.g = 1.0 - (facm + 2.0*fac*(1.0 - col2.g))*(1.0 - outcol.g);\n\n\tif(outcol.b < 0.5)\n\t\toutcol.b *= facm + 2.0*fac*col2.b;\n\telse\n\t\toutcol.b = 1.0 - (facm + 2.0*fac*(1.0 - col2.b))*(1.0 - outcol.b);\n}\n\nvoid mix_sub(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 - col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_div(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tif(col2.r != 0.0) outcol.r = facm*outcol.r + fac*outcol.r/col2.r;\n\tif(col2.g != 0.0) outcol.g = facm*outcol.g + fac*outcol.g/col2.g;\n\tif(col2.b != 0.0) outcol.b = facm*outcol.b + fac*outcol.b/col2.b;\n}\n\nvoid mix_diff(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, abs(col1 - col2), fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_dark(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol.rgb = min(col1.rgb, col2.rgb*fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_light(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol.rgb = max(col1.rgb, col2.rgb*fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_dodge(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = col1;\n\n\tif(outcol.r != 0.0) {\n\t\tfloat tmp = 1.0 - fac*col2.r;\n\t\tif(tmp <= 0.0)\n\t\t\toutcol.r = 1.0;\n\t\telse if((tmp = outcol.r/tmp) > 1.0)\n\t\t\toutcol.r = 1.0;\n\t\telse\n\t\t\toutcol.r = tmp;\n\t}\n\tif(outcol.g != 0.0) {\n\t\tfloat tmp = 1.0 - fac*col2.g;\n\t\tif(tmp <= 0.0)\n\t\t\toutcol.g = 1.0;\n\t\telse if((tmp = outcol.g/tmp) > 1.0)\n\t\t\toutcol.g = 1.0;\n\t\telse\n\t\t\toutcol.g = tmp;\n\t}\n\tif(outcol.b != 0.0) {\n\t\tfloat tmp = 1.0 - fac*col2.b;\n\t\tif(tmp <= 0.0)\n\t\t\toutcol.b = 1.0;\n\t\telse if((tmp = outcol.b/tmp) > 1.0)\n\t\t\toutcol.b = 1.0;\n\t\telse\n\t\t\toutcol.b = tmp;\n\t}\n}\n\nvoid mix_burn(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat tmp, facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\ttmp = facm + fac*col2.r;\n\tif(tmp <= 0.0)\n\t\toutcol.r = 0.0;\n\telse if((tmp = (1.0 - (1.0 - outcol.r)/tmp)) < 0.0)\n\t\toutcol.r = 0.0;\n\telse if(tmp > 1.0)\n\t\toutcol.r = 1.0;\n\telse\n\t\toutcol.r = tmp;\n\n\ttmp = facm + fac*col2.g;\n\tif(tmp <= 0.0)\n\t\toutcol.g = 0.0;\n\telse if((tmp = (1.0 - (1.0 - outcol.g)/tmp)) < 0.0)\n\t\toutcol.g = 0.0;\n\telse if(tmp > 1.0)\n\t\toutcol.g = 1.0;\n\telse\n\t\toutcol.g = tmp;\n\n\ttmp = facm + fac*col2.b;\n\tif(tmp <= 0.0)\n\t\toutcol.b = 0.0;\n\telse if((tmp = (1.0 - (1.0 - outcol.b)/tmp)) < 0.0)\n\t\toutcol.b = 0.0;\n\telse if(tmp > 1.0)\n\t\toutcol.b = 1.0;\n\telse\n\t\toutcol.b = tmp;\n}\n\nvoid mix_hue(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2, tmp;\n\trgb_to_hsv(col2, hsv2);\n\n\tif(hsv2.y != 0.0) {\n\t\trgb_to_hsv(outcol, hsv);\n\t\thsv.x = hsv2.x;\n\t\thsv_to_rgb(hsv, tmp); \n\n\t\toutcol = mix(outcol, tmp, fac);\n\t\toutcol.a = col1.a;\n\t}\n}\n\nvoid mix_sat(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2;\n\trgb_to_hsv(outcol, hsv);\n\n\tif(hsv.y != 0.0) {\n\t\trgb_to_hsv(col2, hsv2);\n\n\t\thsv.y = facm*hsv.y + fac*hsv2.y;\n\t\thsv_to_rgb(hsv, outcol);\n\t}\n}\n\nvoid mix_val(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\tvec4 hsv, hsv2;\n\trgb_to_hsv(col1, hsv);\n\trgb_to_hsv(col2, hsv2);\n\n\thsv.z = facm*hsv.z + fac*hsv2.z;\n\thsv_to_rgb(hsv, outcol);\n}\n\nvoid mix_color(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2, tmp;\n\trgb_to_hsv(col2, hsv2);\n\n\tif(hsv2.y != 0.0) {\n\t\trgb_to_hsv(outcol, hsv);\n\t\thsv.x = hsv2.x;\n\t\thsv.y = hsv2.y;\n\t\thsv_to_rgb(hsv, tmp); \n\n\t\toutcol = mix(outcol, tmp, fac);\n\t\toutcol.a = col1.a;\n\t}\n}\n\nvoid mix_soft(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\tvec4 one= vec4(1.0);\n\tvec4 scr= one - (one - col2)*(one - col1);\n\toutcol = facm*col1 + fac*((one - col1)*col2*col1 + col1*scr);\n}\n\nvoid mix_linear(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\n\toutcol = col1;\n\n\tif(col2.r > 0.5)\n\t\toutcol.r= col1.r + fac*(2.0*(col2.r - 0.5));\n\telse\n\t\toutcol.r= col1.r + fac*(2.0*(col2.r) - 1.0);\n\n\tif(col2.g > 0.5)\n\t\toutcol.g= col1.g + fac*(2.0*(col2.g - 0.5));\n\telse\n\t\toutcol.g= col1.g + fac*(2.0*(col2.g) - 1.0);\n\n\tif(col2.b > 0.5)\n\t\toutcol.b= col1.b + fac*(2.0*(col2.b - 0.5));\n\telse\n\t\toutcol.b= col1.b + fac*(2.0*(col2.b) - 1.0);\n}\n\nvoid valtorgb(float fac, sampler2D colormap, out vec4 outcol, out float outalpha)\n{\n\toutcol = texture2D(colormap, vec2(fac, 0.0));\n\toutalpha = outcol.a;\n}\n\nvoid rgbtobw(vec4 color, out float outval)  \n{\n\toutval = color.r*0.35 + color.g*0.45 + color.b*0.2; /* keep these factors in sync with texture.h:RGBTOBW */\n}\n\nvoid invert(float fac, vec4 col, out vec4 outcol)\n{\n\toutcol.xyz = mix(col.xyz, vec3(1.0, 1.0, 1.0) - col.xyz, fac);\n\toutcol.w = col.w;\n}\n\nvoid hue_sat(float hue, float sat, float value, float fac, vec4 col, out vec4 outcol)\n{\n\tvec4 hsv;\n\n\trgb_to_hsv(col, hsv);\n\n\thsv[0] += (hue - 0.5);\n\tif(hsv[0]>1.0) hsv[0]-=1.0; else if(hsv[0]<0.0) hsv[0]+= 1.0;\n\thsv[1] *= sat;\n\tif(hsv[1]>1.0) hsv[1]= 1.0; else if(hsv[1]<0.0) hsv[1]= 0.0;\n\thsv[2] *= value;\n\tif(hsv[2]>1.0) hsv[2]= 1.0; else if(hsv[2]<0.0) hsv[2]= 0.0;\n\n\thsv_to_rgb(hsv, outcol);\n\n\toutcol = mix(col, outcol, fac);\n}\n\nvoid separate_rgb(vec4 col, out float r, out float g, out float b)\n{\n\tr = col.r;\n\tg = col.g;\n\tb = col.b;\n}\n\nvoid combine_rgb(float r, float g, float b, out vec4 col)\n{\n\tcol = vec4(r, g, b, 1.0);\n}\n\nvoid separate_hsv(vec4 col, out float h, out float s, out float v)\n{\n\tvec4 hsv;\n\n\trgb_to_hsv(col, hsv);\n\th = hsv[0];\n\ts = hsv[1];\n\tv = hsv[2];\n}\n\nvoid combine_hsv(float h, float s, float v, out vec4 col)\n{\n\thsv_to_rgb(vec4(h, s, v, 1.0), col);\n}\n\nvoid output_node(vec4 rgb, float alpha, out vec4 outrgb)\n{\n\toutrgb = vec4(rgb.rgb, alpha);\n}\n\n/*********** TEXTURES ***************/\n\nvoid texture_flip_blend(vec3 vec, out vec3 outvec)\n{\n\toutvec = vec.yxz;\n}\n\nvoid texture_blend_lin(vec3 vec, out float outval)\n{\n\toutval = (1.0+vec.x)/2.0;\n}\n\nvoid texture_blend_quad(vec3 vec, out float outval)\n{\n\toutval = max((1.0+vec.x)/2.0, 0.0);\n\toutval *= outval;\n}\n\nvoid texture_wood_sin(vec3 vec, out float value, out vec4 color, out vec3 normal)\n{\n\tfloat a = sqrt(vec.x*vec.x + vec.y*vec.y + vec.z*vec.z)*20.0;\n\tfloat wi = 0.5 + 0.5*sin(a);\n\n\tvalue = wi;\n\tcolor = vec4(wi, wi, wi, 1.0);\n\tnormal = vec3(0.0, 0.0, 0.0);\n}\n\nvoid texture_image(vec3 vec, sampler2D ima, out float value, out vec4 color, out vec3 normal)\n{\n\tcolor = texture2D(ima, (vec.xy + vec2(1.0, 1.0))*0.5);\n\tvalue = color.a;\n\n\tnormal.x = 2.0*(color.r - 0.5);\n\tnormal.y = 2.0*(0.5 - color.g);\n\tnormal.z = 2.0*(color.b - 0.5);\n}\n\n/************* MTEX *****************/\n\nvoid texco_orco(vec3 attorco, out vec3 orco)\n{\n\torco = attorco;\n}\n\nvoid texco_uv(vec2 attuv, out vec3 uv)\n{\n\t/* disabled for now, works together with leaving out mtex_2d_mapping\n\t   uv = vec3(attuv*2.0 - vec2(1.0, 1.0), 0.0); */\n\tuv = vec3(attuv, 0.0);\n}\n\nvoid texco_norm(vec3 normal, out vec3 outnormal)\n{\n\t/* corresponds to shi->orn, which is negated so cancels\n\t   out blender normal negation */\n\toutnormal = normalize(normal);\n}\n\nvoid texco_tangent(vec4 tangent, out vec3 outtangent)\n{\n\touttangent = normalize(tangent.xyz);\n}\n\nvoid texco_global(mat4 viewinvmat, vec3 co, out vec3 global)\n{\n\tglobal = (viewinvmat*vec4(co, 1.0)).xyz;\n}\n\nvoid texco_object(mat4 viewinvmat, mat4 obinvmat, vec3 co, out vec3 object)\n{\n\tobject = (obinvmat*(viewinvmat*vec4(co, 1.0))).xyz;\n}\n\nvoid texco_refl(vec3 vn, vec3 view, out vec3 ref)\n{\n\tref = view - 2.0*dot(vn, view)*vn;\n}\n\nvoid shade_norm(vec3 normal, out vec3 outnormal)\n{\n\t/* blender render normal is negated */\n\toutnormal = -normalize(normal);\n}\n\nvoid mtex_rgb_blend(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol = fact*texcol + facm*outcol;\n}\n\nvoid mtex_rgb_mul(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol = (facm + fact*texcol)*outcol;\n}\n\nvoid mtex_rgb_screen(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol = vec3(1.0) - (vec3(facm) + fact*(vec3(1.0) - texcol))*(vec3(1.0) - outcol);\n}\n\nvoid mtex_rgb_overlay(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tif(outcol.r < 0.5)\n\t\tincol.r = outcol.r*(facm + 2.0*fact*texcol.r);\n\telse\n\t\tincol.r = 1.0 - (facm + 2.0*fact*(1.0 - texcol.r))*(1.0 - outcol.r);\n\n\tif(outcol.g < 0.5)\n\t\tincol.g = outcol.g*(facm + 2.0*fact*texcol.g);\n\telse\n\t\tincol.g = 1.0 - (facm + 2.0*fact*(1.0 - texcol.g))*(1.0 - outcol.g);\n\n\tif(outcol.b < 0.5)\n\t\tincol.b = outcol.b*(facm + 2.0*fact*texcol.b);\n\telse\n\t\tincol.b = 1.0 - (facm + 2.0*fact*(1.0 - texcol.b))*(1.0 - outcol.b);\n}\n\nvoid mtex_rgb_sub(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tincol = -fact*facg*texcol + outcol;\n}\n\nvoid mtex_rgb_add(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tincol = fact*facg*texcol + outcol;\n}\n\nvoid mtex_rgb_div(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tif(texcol.r != 0.0) incol.r = facm*outcol.r + fact*outcol.r/texcol.r;\n\tif(texcol.g != 0.0) incol.g = facm*outcol.g + fact*outcol.g/texcol.g;\n\tif(texcol.b != 0.0) incol.b = facm*outcol.b + fact*outcol.b/texcol.b;\n}\n\nvoid mtex_rgb_diff(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol = facm*outcol + fact*abs(texcol - outcol);\n}\n\nvoid mtex_rgb_dark(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm, col;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol.r = min(outcol.r, texcol.r) * fact + outcol.r * facm;\n\tincol.g = min(outcol.g, texcol.g) * fact + outcol.g * facm;\n\tincol.b = min(outcol.b, texcol.b) * fact + outcol.b * facm;\n}\n\nvoid mtex_rgb_light(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm, col;\n\n\tfact *= facg;\n\n\tcol = fact*texcol.r;\n\tif(col > outcol.r) incol.r = col; else incol.r = outcol.r;\n\tcol = fact*texcol.g;\n\tif(col > outcol.g) incol.g = col; else incol.g = outcol.g;\n\tcol = fact*texcol.b;\n\tif(col > outcol.b) incol.b = col; else incol.b = outcol.b;\n}\n\nvoid mtex_rgb_hue(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_hue(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_sat(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_sat(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_val(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_val(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_color(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_color(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_value_vars(inout float fact, float facg, out float facm)\n{\n\tfact *= abs(facg);\n\tfacm = 1.0-fact;\n\n\tif(facg < 0.0) {\n\t\tfloat tmp = fact;\n\t\tfact = facm;\n\t\tfacm = tmp;\n\t}\n}\n\nvoid mtex_value_blend(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = fact*texcol + facm*outcol;\n}\n\nvoid mtex_value_mul(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfacm = 1.0 - facg;\n\tincol = (facm + fact*texcol)*outcol;\n}\n\nvoid mtex_value_screen(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfacm = 1.0 - facg;\n\tincol = 1.0 - (facm + fact*(1.0 - texcol))*(1.0 - outcol);\n}\n\nvoid mtex_value_sub(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfact = -fact;\n\tincol = fact*texcol + outcol;\n}\n\nvoid mtex_value_add(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfact = fact;\n\tincol = fact*texcol + outcol;\n}\n\nvoid mtex_value_div(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tif(texcol != 0.0)\n\t\tincol = facm*outcol + fact*outcol/texcol;\n\telse\n\t\tincol = 0.0;\n}\n\nvoid mtex_value_diff(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = facm*outcol + fact*abs(texcol - outcol);\n}\n\nvoid mtex_value_dark(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = facm*outcol + fact*min(outcol, texcol);\n}\n\nvoid mtex_value_light(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfloat col = fact*texcol;\n\tif(col > outcol) incol = col; else incol = outcol;\n}\n\nvoid mtex_value_clamp_positive(float fac, out float outfac)\n{\n\toutfac = max(fac, 0.0);\n}\n\nvoid mtex_value_clamp(float fac, out float outfac)\n{\n\toutfac = clamp(fac, 0.0, 1.0);\n}\n\nvoid mtex_har_divide(float har, out float outhar)\n{\n\touthar = har/128.0;\n}\n\nvoid mtex_har_multiply_clamp(float har, out float outhar)\n{\n\thar *= 128.0;\n\n\tif(har < 1.0) outhar = 1.0;\n\telse if(har > 511.0) outhar = 511.0;\n\telse outhar = har;\n}\n\nvoid mtex_alpha_from_col(vec4 col, out float alpha)\n{\n\talpha = col.a;\n}\n\nvoid mtex_alpha_to_col(vec4 col, float alpha, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, alpha);\n}\n\nvoid mtex_rgbtoint(vec4 rgb, out float intensity)\n{\n\tintensity = dot(vec3(0.35, 0.45, 0.2), rgb.rgb);\n}\n\nvoid mtex_value_invert(float invalue, out float outvalue)\n{\n\toutvalue = 1.0 - invalue;\n}\n\nvoid mtex_rgb_invert(vec4 inrgb, out vec4 outrgb)\n{\n\toutrgb = vec4(vec3(1.0) - inrgb.rgb, inrgb.a);\n}\n\nvoid mtex_value_stencil(float stencil, float intensity, out float outstencil, out float outintensity)\n{\n\tfloat fact = intensity;\n\toutintensity = intensity*stencil;\n\toutstencil = stencil*fact;\n}\n\nvoid mtex_rgb_stencil(float stencil, vec4 rgb, out float outstencil, out vec4 outrgb)\n{\n\tfloat fact = rgb.a;\n\toutrgb = vec4(rgb.rgb, rgb.a*stencil);\n\toutstencil = stencil*fact;\n}\n\nvoid mtex_mapping_ofs(vec3 texco, vec3 ofs, out vec3 outtexco)\n{\n\touttexco = texco + ofs;\n}\n\nvoid mtex_mapping_size(vec3 texco, vec3 size, out vec3 outtexco)\n{\n\touttexco = size*texco;\n}\n\nvoid mtex_2d_mapping(vec3 vec, out vec3 outvec)\n{\n\toutvec = vec3(vec.xy*0.5 + vec2(0.5, 0.5), vec.z);\n}\n\nvoid mtex_image(vec3 texco, sampler2D ima, out float value, out vec4 color)\n{\n\tcolor = texture2D(ima, texco.xy);\n\tvalue = 1.0;\n}\n\nvoid mtex_normal(vec3 texco, sampler2D ima, out vec3 normal)\n{\n\t// The invert of the red channel is to make\n\t// the normal map compliant with the outside world.\n\t// It needs to be done because in Blender\n\t// the normal used points inward.\n\t// Should this ever change this negate must be removed.\n\tvec4 color = texture2D(ima, texco.xy);\n\tnormal = 2.0*(vec3(-color.r, color.g, color.b) - vec3(-0.5, 0.5, 0.5));\n}\n\nvoid mtex_bump_normals_init( vec3 vN, out vec3 vNorg, out vec3 vNacc, out float fPrevMagnitude )\n{\n\tvNorg = vN;\n\tvNacc = vN;\n\tfPrevMagnitude = 1.0;\n}\n\n/** helper method to extract the upper left 3x3 matrix from a 4x4 matrix */\nmat3 to_mat3(mat4 m4)\n{\n\tmat3 m3;\n\tm3[0] = m4[0].xyz;\n\tm3[1] = m4[1].xyz;\n\tm3[2] = m4[2].xyz;\n\treturn m3;\n}\n\nvoid mtex_bump_init_objspace( vec3 surf_pos, vec3 surf_norm,\n\t\t\t\t\t\t\t  mat4 mView, mat4 mViewInv, mat4 mObj, mat4 mObjInv, \n\t\t\t\t\t\t\t  float fPrevMagnitude_in, vec3 vNacc_in,\n\t\t\t\t\t\t\t  out float fPrevMagnitude_out, out vec3 vNacc_out, \n\t\t\t\t\t\t\t  out vec3 vR1, out vec3 vR2, out float fDet ) \n{\n\tmat3 obj2view = to_mat3(mat4(1));\n\tmat3 view2obj = to_mat3(mat4(1));\n\t\n\tvec3 vSigmaS = view2obj * dFdx( surf_pos );\n\tvec3 vSigmaT = view2obj * dFdy( surf_pos );\n\tvec3 vN = normalize( surf_norm * obj2view );\n\n\tvR1 = cross( vSigmaT, vN );\n\tvR2 = cross( vN, vSigmaS ) ;\n\tfDet = dot ( vSigmaS, vR1 );\n\t\n\t/* pretransform vNacc (in mtex_bump_apply) using the inverse transposed */\n\tvR1 = vR1 * view2obj;\n\tvR2 = vR2 * view2obj;\n\tvN = vN * view2obj;\n\t\n\tfloat fMagnitude = abs(fDet) * length(vN);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_init_texturespace( vec3 surf_pos, vec3 surf_norm, \n\t\t\t\t\t\t\t\t  float fPrevMagnitude_in, vec3 vNacc_in,\n\t\t\t\t\t\t\t\t  out float fPrevMagnitude_out, out vec3 vNacc_out, \n\t\t\t\t\t\t\t\t  out vec3 vR1, out vec3 vR2, out float fDet ) \n{\n\tvec3 vSigmaS = dFdx( surf_pos );\n\tvec3 vSigmaT = dFdy( surf_pos );\n\tvec3 vN = surf_norm; /* normalized interpolated vertex normal */\n\t\n\tvR1 = normalize( cross( vSigmaT, vN ) );\n\tvR2 = normalize( cross( vN, vSigmaS ) );\n\tfDet = sign( dot(vSigmaS, vR1) );\n\t\n\tfloat fMagnitude = abs(fDet);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_init_viewspace( vec3 surf_pos, vec3 surf_norm, \n\t\t\t\t\t\t\t   float fPrevMagnitude_in, vec3 vNacc_in,\n\t\t\t\t\t\t\t   out float fPrevMagnitude_out, out vec3 vNacc_out, \n\t\t\t\t\t\t\t   out vec3 vR1, out vec3 vR2, out float fDet ) \n{\n\tvec3 vSigmaS = dFdx( surf_pos );\n\tvec3 vSigmaT = dFdy( surf_pos );\n\tvec3 vN = surf_norm; /* normalized interpolated vertex normal */\n\t\n\tvR1 = cross( vSigmaT, vN );\n\tvR2 = cross( vN, vSigmaS ) ;\n\tfDet = dot ( vSigmaS, vR1 );\n\t\n\tfloat fMagnitude = abs(fDet);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_tap3( vec3 texco, sampler2D ima, float hScale, \n                     out float dBs, out float dBt )\n{\n\tvec2 STll = texco.xy;\n\tvec2 STlr = texco.xy + dFdx(texco.xy) ;\n\tvec2 STul = texco.xy + dFdy(texco.xy) ;\n\t\n\tfloat Hll,Hlr,Hul;\n\trgbtobw( texture2D(ima, STll), Hll );\n\trgbtobw( texture2D(ima, STlr), Hlr );\n\trgbtobw( texture2D(ima, STul), Hul );\n\t\n\tdBs = hScale * (Hlr - Hll);\n\tdBt = hScale * (Hul - Hll);\n}\n\n#ifdef BUMP_BICUBIC\n\nvoid mtex_bump_bicubic( vec3 texco, sampler2D ima, float hScale, \n                     out float dBs, out float dBt ) \n{\n\tfloat Hl;\n\tfloat Hr;\n\tfloat Hd;\n\tfloat Hu;\n\t\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n \n\tvec2 STl = texco.xy - 0.5 * TexDx ;\n\tvec2 STr = texco.xy + 0.5 * TexDx ;\n\tvec2 STd = texco.xy - 0.5 * TexDy ;\n\tvec2 STu = texco.xy + 0.5 * TexDy ;\n\t\n\trgbtobw(texture2D(ima, STl), Hl);\n\trgbtobw(texture2D(ima, STr), Hr);\n\trgbtobw(texture2D(ima, STd), Hd);\n\trgbtobw(texture2D(ima, STu), Hu);\n\t\n\tvec2 dHdxy = vec2(Hr - Hl, Hu - Hd);\n\tfloat fBlend = clamp(1.0-textureQueryLOD(ima, texco.xy).x, 0.0, 1.0);\n\tif(fBlend!=0.0)\n\t{\n\t\t// the derivative of the bicubic sampling of level 0\n\t\tivec2 vDim;\n\t\tvDim = textureSize(ima, 0);\n\n\t\t// taking the fract part of the texture coordinate is a hardcoded wrap mode.\n\t\t// this is acceptable as textures use wrap mode exclusively in 3D view elsewhere in blender. \n\t\t// this is done so that we can still get a valid texel with uvs outside the 0,1 range\n\t\t// by texelFetch below, as coordinates are clamped when using this function.\n\t\tvec2 fTexLoc = vDim*fract(texco.xy) - vec2(0.5, 0.5);\n\t\tivec2 iTexLoc = ivec2(floor(fTexLoc));\n\t\tvec2 t = clamp(fTexLoc - iTexLoc, 0.0, 1.0);\t\t// sat just to be pedantic\n\n/*******************************************************************************************\n * This block will replace the one below when one channel textures are properly supported. *\n *******************************************************************************************\n\t\tvec4 vSamplesUL = textureGather(ima, (iTexLoc+ivec2(-1,-1) + vec2(0.5,0.5))/vDim );\n\t\tvec4 vSamplesUR = textureGather(ima, (iTexLoc+ivec2(1,-1) + vec2(0.5,0.5))/vDim );\n\t\tvec4 vSamplesLL = textureGather(ima, (iTexLoc+ivec2(-1,1) + vec2(0.5,0.5))/vDim );\n\t\tvec4 vSamplesLR = textureGather(ima, (iTexLoc+ivec2(1,1) + vec2(0.5,0.5))/vDim );\n\n\t\tmat4 H = mat4(vSamplesUL.w, vSamplesUL.x, vSamplesLL.w, vSamplesLL.x,\n\t\t\t\t\tvSamplesUL.z, vSamplesUL.y, vSamplesLL.z, vSamplesLL.y,\n\t\t\t\t\tvSamplesUR.w, vSamplesUR.x, vSamplesLR.w, vSamplesLR.x,\n\t\t\t\t\tvSamplesUR.z, vSamplesUR.y, vSamplesLR.z, vSamplesLR.y);\n*/\t\n\t\tivec2 iTexLocMod = iTexLoc + ivec2(-1, -1);\n\n\t\tmat4 H;\n\t\t\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\tivec2 iTexTmp = iTexLocMod + ivec2(i,j);\n\t\t\t\t\n\t\t\t\t// wrap texture coordinates manually for texelFetch to work on uvs oitside the 0,1 range.\n\t\t\t\t// this is guaranteed to work since we take the fractional part of the uv above.\n\t\t\t\tiTexTmp.x = (iTexTmp.x < 0)? iTexTmp.x + vDim.x : ((iTexTmp.x >= vDim.x)? iTexTmp.x - vDim.x : iTexTmp.x);\n\t\t\t\tiTexTmp.y = (iTexTmp.y < 0)? iTexTmp.y + vDim.y : ((iTexTmp.y >= vDim.y)? iTexTmp.y - vDim.y : iTexTmp.y);\n\n\t\t\t\trgbtobw(texelFetch(ima, iTexTmp, 0), H[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfloat x = t.x, y = t.y;\n\t\tfloat x2 = x * x, x3 = x2 * x, y2 = y * y, y3 = y2 * y;\n\n\t\tvec4 X = vec4(-0.5*(x3+x)+x2,\t\t1.5*x3-2.5*x2+1,\t-1.5*x3+2*x2+0.5*x,\t\t0.5*(x3-x2));\n\t\tvec4 Y = vec4(-0.5*(y3+y)+y2,\t\t1.5*y3-2.5*y2+1,\t-1.5*y3+2*y2+0.5*y,\t\t0.5*(y3-y2));\n\t\tvec4 dX = vec4(-1.5*x2+2*x-0.5,\t\t4.5*x2-5*x,\t\t\t-4.5*x2+4*x+0.5,\t\t1.5*x2-x);\n\t\tvec4 dY = vec4(-1.5*y2+2*y-0.5,\t\t4.5*y2-5*y,\t\t\t-4.5*y2+4*y+0.5,\t\t1.5*y2-y);\n\t\n\t\t// complete derivative in normalized coordinates (mul by vDim)\n\t\tvec2 dHdST = vDim * vec2(dot(Y, H * dX), dot(dY, H * X));\n\n\t\t// transform derivative to screen-space\n\t\tvec2 dHdxy_bicubic = vec2( dHdST.x * TexDx.x + dHdST.y * TexDx.y,\n\t\t\t\t\t\t\t\t   dHdST.x * TexDy.x + dHdST.y * TexDy.y );\n\n\t\t// blend between the two\n\t\tdHdxy = dHdxy*(1-fBlend) + dHdxy_bicubic*fBlend;\n\t}\n\n\tdBs = hScale * dHdxy.x;\n\tdBt = hScale * dHdxy.y;\n}\n\n#endif\n\nvoid mtex_bump_tap5( vec3 texco, sampler2D ima, float hScale, \n                     out float dBs, out float dBt ) \n{\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\tvec2 STc = texco.xy;\n\tvec2 STl = texco.xy - 0.5 * TexDx ;\n\tvec2 STr = texco.xy + 0.5 * TexDx ;\n\tvec2 STd = texco.xy - 0.5 * TexDy ;\n\tvec2 STu = texco.xy + 0.5 * TexDy ;\n\t\n\tfloat Hc,Hl,Hr,Hd,Hu;\n\trgbtobw( texture2D(ima, STc), Hc );\n\trgbtobw( texture2D(ima, STl), Hl );\n\trgbtobw( texture2D(ima, STr), Hr );\n\trgbtobw( texture2D(ima, STd), Hd );\n\trgbtobw( texture2D(ima, STu), Hu );\n\t\n\tdBs = hScale * (Hr - Hl);\n\tdBt = hScale * (Hu - Hd);\n}\n\nvoid mtex_bump_deriv( vec3 texco, sampler2D ima, float ima_x, float ima_y, float hScale, \n                     out float dBs, out float dBt ) \n{\n\tfloat s = 1.0;\t\t// negate this if flipped texture coordinate\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\t\n\t// this variant using a derivative map is described here\n\t// http://mmikkelsen3d.blogspot.com/2011/07/derivative-maps.html\n\tvec2 dim = vec2(ima_x, ima_y);\n\tvec2 dBduv = hScale*dim*(2.0*texture2D(ima, texco.xy).xy-1.0);\n\t\n\tdBs = dBduv.x*TexDx.x + s*dBduv.y*TexDx.y;\n\tdBt = dBduv.x*TexDy.x + s*dBduv.y*TexDy.y;\n}\n\nvoid mtex_bump_apply( float fDet, float dBs, float dBt, vec3 vR1, vec3 vR2, vec3 vNacc_in,\n\t\t\t\t\t  out vec3 vNacc_out, out vec3 perturbed_norm ) \n{\n\tvec3 vSurfGrad = sign(fDet) * ( dBs * vR1 + dBt * vR2 );\n\t\n\tvNacc_out = vNacc_in - vSurfGrad;\n\tperturbed_norm = normalize( vNacc_out );\n}\n\nvoid mtex_bump_apply_texspace( float fDet, float dBs, float dBt, vec3 vR1, vec3 vR2,\n                               sampler2D ima, vec3 texco, float ima_x, float ima_y, vec3 vNacc_in,\n\t\t\t\t\t\t\t   out vec3 vNacc_out, out vec3 perturbed_norm ) \n{\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\tvec3 vSurfGrad = sign(fDet) * ( \n\t            dBs / length( vec2(ima_x*TexDx.x, ima_y*TexDx.y) ) * vR1 + \n\t            dBt / length( vec2(ima_x*TexDy.x, ima_y*TexDy.y) ) * vR2 );\n\t\t\t\t\n\tvNacc_out = vNacc_in - vSurfGrad;\n\tperturbed_norm = normalize( vNacc_out );\n}\n\nvoid mtex_negate_texnormal(vec3 normal, out vec3 outnormal)\n{\n\toutnormal = vec3(-normal.x, -normal.y, normal.z);\n}\n\nvoid mtex_nspace_tangent(vec4 tangent, vec3 normal, vec3 texnormal, out vec3 outnormal)\n{\n\tvec3 B = tangent.w * cross(normal, tangent.xyz);\n\n\toutnormal = texnormal.x*tangent.xyz + texnormal.y*B + texnormal.z*normal;\n\toutnormal = normalize(outnormal);\n}\n\nvoid mtex_nspace_world(mat4 viewmat, vec3 texnormal, out vec3 outnormal)\n{\n\toutnormal = normalize((viewmat*vec4(texnormal, 0.0)).xyz);\n}\n\nvoid mtex_nspace_object(mat4 viewmat, mat4 obmat, vec3 texnormal, out vec3 outnormal)\n{\n\toutnormal = normalize((viewmat*(obmat*vec4(texnormal, 0.0))).xyz);\n}\n\nvoid mtex_blend_normal(float norfac, vec3 normal, vec3 newnormal, out vec3 outnormal)\n{\n\toutnormal = (1.0 - norfac)*normal + norfac*newnormal;\n\toutnormal = normalize(outnormal);\n}\n\n/******* MATERIAL *********/\n\nvoid lamp_visibility_sun_hemi(vec3 lampvec, out vec3 lv, out float dist, out float visifac)\n{\n\tlv = lampvec;\n\tdist = 1.0;\n\tvisifac = 1.0;\n}\n\nvoid lamp_visibility_other(vec3 co, vec3 lampco, out vec3 lv, out float dist, out float visifac)\n{\n\tlv = co - lampco;\n\tdist = length(lv);\n\tlv = normalize(lv);\n\tvisifac = 1.0;\n}\n\nvoid lamp_falloff_invlinear(float lampdist, float dist, out float visifac)\n{\n\tvisifac = lampdist/(lampdist + dist);\n}\n\nvoid lamp_falloff_invsquare(float lampdist, float dist, out float visifac)\n{\n\tvisifac = lampdist/(lampdist + dist*dist);\n}\n\nvoid lamp_falloff_sliders(float lampdist, float ld1, float ld2, float dist, out float visifac)\n{\n\tfloat lampdistkw = lampdist*lampdist;\n\n\tvisifac = lampdist/(lampdist + ld1*dist);\n\tvisifac *= lampdistkw/(lampdistkw + ld2*dist*dist);\n}\n\nvoid lamp_falloff_curve(float lampdist, sampler2D curvemap, float dist, out float visifac)\n{\n\tvisifac = texture2D(curvemap, vec2(dist/lampdist, 0.0)).x;\n}\n\nvoid lamp_visibility_sphere(float lampdist, float dist, float visifac, out float outvisifac)\n{\n\tfloat t= lampdist - dist;\n\n\toutvisifac= visifac*max(t, 0.0)/lampdist;\n}\n\nvoid lamp_visibility_spot_square(vec3 lampvec, mat4 lampimat, vec3 lv, out float inpr)\n{\n\tif(dot(lv, lampvec) > 0.0) {\n\t\tvec3 lvrot = (lampimat*vec4(lv, 0.0)).xyz;\n\t\tfloat x = max(abs(lvrot.x/lvrot.z), abs(lvrot.y/lvrot.z));\n\n\t\tinpr = 1.0/sqrt(1.0 + x*x);\n\t}\n\telse\n\t\tinpr = 0.0;\n}\n\nvoid lamp_visibility_spot_circle(vec3 lampvec, vec3 lv, out float inpr)\n{\n\tinpr = dot(lv, lampvec);\n}\n\nvoid lamp_visibility_spot(float spotsi, float spotbl, float inpr, float visifac, out float outvisifac)\n{\n\tfloat t = spotsi;\n\n\tif(inpr <= t) {\n\t\toutvisifac = 0.0;\n\t}\n\telse {\n\t\tt = inpr - t;\n\n\t\t/* soft area */\n\t\tif(spotbl != 0.0)\n\t\t\tinpr *= smoothstep(0.0, 1.0, t/spotbl);\n\n\t\toutvisifac = visifac*inpr;\n\t}\n}\n\nvoid lamp_visibility_clamp(float visifac, out float outvisifac)\n{\n\toutvisifac = (visifac < 0.001)? 0.0: visifac;\n}\n\nvoid shade_view(vec3 co, out vec3 view)\n{\n\t/* handle perspective/orthographic */\n\tview = (0.0 == 0.0)? normalize(co): vec3(0.0, 0.0, -1.0);\n}\n\nvoid shade_tangent_v(vec3 lv, vec3 tang, out vec3 vn)\n{\n\tvec3 c = cross(lv, tang);\n\tvec3 vnor = cross(c, tang);\n\n\tvn = -normalize(vnor);\n}\n\nvoid shade_inp(vec3 vn, vec3 lv, out float inp)\n{\n\tinp = dot(vn, lv);\n}\n\nvoid shade_is_no_diffuse(out float is)\n{\n\tis = 0.0;\n}\n\nvoid shade_is_hemi(float inp, out float is)\n{\n\tis = 0.5*inp + 0.5;\n}\n\nfloat area_lamp_energy(mat4 area, vec3 co, vec3 vn)\n{\n\tvec3 vec[4], c[4];\n\tfloat rad[4];float fac;\n\t\n\tvec[0] = normalize(co - area[0].xyz);\n\tvec[1] = normalize(co - area[1].xyz);\n\tvec[2] = normalize(co - area[2].xyz);\n\tvec[3] = normalize(co - area[3].xyz);\n\n\tc[0] = normalize(cross(vec[0], vec[1]));\n\tc[1] = normalize(cross(vec[1], vec[2]));\n\tc[2] = normalize(cross(vec[2], vec[3]));\n\tc[3] = normalize(cross(vec[3], vec[0]));\n\n\trad[0] = acos(dot(vec[0], vec[1]));\n\trad[1] = acos(dot(vec[1], vec[2]));\n\trad[2] = acos(dot(vec[2], vec[3]));\n\trad[3] = acos(dot(vec[3], vec[0]));\n\n\tfac=  rad[0]*dot(vn, c[0]);\n\tfac+= rad[1]*dot(vn, c[1]);\n\tfac+= rad[2]*dot(vn, c[2]);\n\tfac+= rad[3]*dot(vn, c[3]);\n\n\treturn max(fac, 0.0);\n}\n\nvoid shade_inp_area(vec3 position, vec3 lampco, vec3 lampvec, vec3 vn, mat4 area, float areasize, float k, out float inp)\n{\n\tvec3 co = position;\n\tvec3 vec = co - lampco;\n\n\tif(dot(vec, lampvec) < 0.0) {\n\t\tinp = 0.0;\n\t}\n\telse {\n\t\tfloat intens = area_lamp_energy(area, co, vn);\n\n\t\tinp = pow(intens*areasize, k);\n\t}\n}\n\nvoid shade_diffuse_oren_nayer(float nl, vec3 n, vec3 l, vec3 v, float rough, out float is)\n{\n\tvec3 h = normalize(v + l);\n\tfloat nh = max(dot(n, h), 0.0);\n\tfloat nv = max(dot(n, v), 0.0);\n\tfloat realnl = dot(n, l);\n\n\tif(realnl < 0.0) {\n\t\tis = 0.0;\n\t}\n\telse if(nl < 0.0) {\n\t\tis = 0.0;\n\t}\n\telse {\n\t\tfloat vh = max(dot(v, h), 0.0);\n\t\tfloat Lit_A = acos(realnl);\n\t\tfloat View_A = acos(nv);\n\n\t\tvec3 Lit_B = normalize(l - realnl*n);\n\t\tvec3 View_B = normalize(v - nv*n);\n\n\t\tfloat t = max(dot(Lit_B, View_B), 0.0);\n\n\t\tfloat a, b;\n\n\t\tif(Lit_A > View_A) {\n\t\t\ta = Lit_A;\n\t\t\tb = View_A;\n\t\t}\n\t\telse {\n\t\t\ta = View_A;\n\t\t\tb = Lit_A;\n\t\t}\n\n\t\tfloat A = 1.0 - (0.5*((rough*rough)/((rough*rough) + 0.33)));\n\t\tfloat B = 0.45*((rough*rough)/((rough*rough) + 0.09));\n\n\t\tb *= 0.95;\n\t\tis = nl*(A + (B * t * sin(a) * tan(b)));\n\t}\n}\n\nvoid shade_diffuse_toon(vec3 n, vec3 l, vec3 v, float size, float tsmooth, out float is)\n{\n\tfloat rslt = dot(n, l);\n\tfloat ang = acos(rslt);\n\n\tif(ang < size) is = 1.0;\n\telse if(ang > (size + tsmooth) || tsmooth == 0.0) is = 0.0;\n\telse is = 1.0 - ((ang - size)/tsmooth);\n}\n\nvoid shade_diffuse_minnaert(float nl, vec3 n, vec3 v, float darkness, out float is)\n{\n\tif(nl <= 0.0) {\n\t\tis = 0.0;\n\t}\n\telse {\n\t\tfloat nv = max(dot(n, v), 0.0);\n\n\t\tif(darkness <= 1.0)\n\t\t\tis = nl*pow(max(nv*nl, 0.1), darkness - 1.0);\n\t\telse\n\t\t\tis = nl*pow(1.0001 - nv, darkness - 1.0);\n\t}\n}\n\nfloat fresnel_fac(vec3 view, vec3 vn, float grad, float fac)\n{\n\tfloat t1, t2;\n\tfloat ffac;\n\n\tif(fac==0.0) {\n\t\tffac = 1.0;\n\t}\n\telse {\n\t\tt1= dot(view, vn);\n\t\tif(t1>0.0)  t2= 1.0+t1;\n\t\telse t2= 1.0-t1;\n\n\t\tt2= grad + (1.0-grad)*pow(t2, fac);\n\n\t\tif(t2<0.0) ffac = 0.0;\n\t\telse if(t2>1.0) ffac = 1.0;\n\t\telse ffac = t2;\n\t}\n\n\treturn ffac;\n}\n\nvoid shade_diffuse_fresnel(vec3 vn, vec3 lv, vec3 view, float fac_i, float fac, out float is)\n{\n\tis = fresnel_fac(lv, vn, fac_i, fac);\n}\n\nvoid shade_cubic(float is, out float outis)\n{\n\tif(is>0.0 && is<1.0)\n\t\toutis= smoothstep(0.0, 1.0, is);\n\telse\n\t\toutis= is;\n}\n\nvoid shade_visifac(float i, float visifac, float refl, out float outi)\n{\n\t/*if(i > 0.0)*/\n\t\touti = max(i*visifac*refl, 0.0);\n\t/*else\n\t\touti = i;*/\n}\n\nvoid shade_tangent_v_spec(vec3 tang, out vec3 vn)\n{\n\tvn = tang;\n}\n\nvoid shade_add_to_diffuse(float i, vec3 lampcol, vec3 col, out vec3 outcol)\n{\n\tif(i > 0.0)\n\t\toutcol = i*lampcol*col;\n\telse\n\t\toutcol = vec3(0.0, 0.0, 0.0);\n}\n\nvoid shade_hemi_spec(vec3 vn, vec3 lv, vec3 view, float spec, float hard, float visifac, out float t)\n{\n\tlv += view;\n\tlv = normalize(lv);\n\n\tt = dot(vn, lv);\n\tt = 0.5*t + 0.5;\n\n\tt = visifac*spec*pow(t, hard);\n}\n\nvoid shade_phong_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat rslt = max(dot(h, n), 0.0);\n\n\tspecfac = pow(rslt, hard);\n}\n\nvoid shade_cooktorr_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)\n{\n\tvec3 h = normalize(v + l);\n\tfloat nh = dot(n, h);\n\n\tif(nh < 0.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse {\n\t\tfloat nv = max(dot(n, v), 0.0);\n\t\tfloat i = pow(nh, hard);\n\n\t\ti = i/(0.1+nv);\n\t\tspecfac = i;\n\t}\n}\n\nvoid shade_blinn_spec(vec3 n, vec3 l, vec3 v, float refrac, float spec_power, out float specfac)\n{\n\tif(refrac < 1.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse if(spec_power == 0.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse {\n\t\tif(spec_power<100.0)\n\t\t\tspec_power= sqrt(1.0/spec_power);\n\t\telse\n\t\t\tspec_power= 10.0/spec_power;\n\n\t\tvec3 h = normalize(v + l);\n\t\tfloat nh = dot(n, h);\n\t\tif(nh < 0.0) {\n\t\t\tspecfac = 0.0;\n\t\t}\n\t\telse {\n\t\t\tfloat nv = max(dot(n, v), 0.01);\n\t\t\tfloat nl = dot(n, l);\n\t\t\tif(nl <= 0.01) {\n\t\t\t\tspecfac = 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfloat vh = max(dot(v, h), 0.01);\n\n\t\t\t\tfloat a = 1.0;\n\t\t\t\tfloat b = (2.0*nh*nv)/vh;\n\t\t\t\tfloat c = (2.0*nh*nl)/vh;\n\n\t\t\t\tfloat g = 0.0;\n\n\t\t\t\tif(a < b && a < c) g = a;\n\t\t\t\telse if(b < a && b < c) g = b;\n\t\t\t\telse if(c < a && c < b) g = c;\n\n\t\t\t\tfloat p = sqrt(((refrac * refrac)+(vh*vh)-1.0));\n\t\t\t\tfloat f = (((p-vh)*(p-vh))/((p+vh)*(p+vh)))*(1.0+((((vh*(p+vh))-1.0)*((vh*(p+vh))-1.0))/(((vh*(p-vh))+1.0)*((vh*(p-vh))+1.0))));\n\t\t\t\tfloat ang = acos(nh);\n\n\t\t\t\tspecfac = max(f*g*exp_blender((-(ang*ang)/(2.0*spec_power*spec_power))), 0.0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid shade_wardiso_spec(vec3 n, vec3 l, vec3 v, float rms, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat nh = max(dot(n, h), 0.001);\n\tfloat nv = max(dot(n, v), 0.001);\n\tfloat nl = max(dot(n, l), 0.001);\n\tfloat angle = tan(acos(nh));\n\tfloat alpha = max(rms, 0.001);\n\n\tspecfac= nl * (1.0/(4.0*M_PI*alpha*alpha))*(exp_blender(-(angle*angle)/(alpha*alpha))/(sqrt(nv*nl)));\n}\n\nvoid shade_toon_spec(vec3 n, vec3 l, vec3 v, float size, float tsmooth, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat rslt = dot(h, n);\n\tfloat ang = acos(rslt);\n\n\tif(ang < size) rslt = 1.0;\n\telse if(ang >= (size + tsmooth) || tsmooth == 0.0) rslt = 0.0;\n\telse rslt = 1.0 - ((ang - size)/tsmooth);\n\n\tspecfac = rslt;\n}\n\nvoid shade_spec_area_inp(float specfac, float inp, out float outspecfac)\n{\n\toutspecfac = specfac*inp;\n}\n\nvoid shade_spec_t(float shadfac, float spec, float visifac, float specfac, out float t)\n{\n\tt = shadfac*spec*visifac*specfac;\n}\n\nvoid shade_add_spec(float t, vec3 lampcol, vec3 speccol, out vec3 outcol)\n{\n\toutcol = t*lampcol*speccol;\n}\n\nvoid shade_add(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1 + col2;\n}\n\nvoid shade_madd(vec4 col, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col + col1*col2;\n}\n\nvoid shade_add_clamped(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1 + max(col2, vec4(0.0, 0.0, 0.0, 0.0));\n}\n\nvoid shade_madd_clamped(vec4 col, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col + max(col1*col2, vec4(0.0, 0.0, 0.0, 0.0));\n}\n\nvoid shade_maddf(vec4 col, float f, vec4 col1, out vec4 outcol)\n{\n\toutcol = col + f*col1;\n}\n\nvoid shade_mul(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1*col2;\n}\n\nvoid shade_mul_value(float fac, vec4 col, out vec4 outcol)\n{\n\toutcol = col*fac;\n}\n\nvoid shade_obcolor(vec4 col, vec4 obcol, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb*obcol.rgb, col.a);\n}\n\nvoid ramp_rgbtobw(vec3 color, out float outval)\n{\n\toutval = color.r*0.3 + color.g*0.58 + color.b*0.12;\n}\n\nvoid shade_only_shadow(float i, float shadfac, float energy, vec3 shadcol, out vec3 outshadrgb)\n{\n\toutshadrgb = i*energy*(1.0 - shadfac)*(vec3(1.0)-shadcol);\n}\n\nvoid shade_only_shadow_diffuse(vec3 shadrgb, vec3 rgb, vec4 diff, out vec4 outdiff)\n{\n\toutdiff = diff - vec4(rgb*shadrgb, 0.0);\n}\n\nvoid shade_only_shadow_specular(vec3 shadrgb, vec3 specrgb, vec4 spec, out vec4 outspec)\n{\n\toutspec = spec - vec4(specrgb*shadrgb, 0.0);\n}\n\nvoid shade_clamp_positive(vec4 col, out vec4 outcol)\n{\n\toutcol = max(col, vec4(0.0));\n}\n\nvoid test_shadowbuf(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float inp, out float result)\n{\n\tif(inp <= 0.0) {\n\t\tresult = 0.0;\n\t}\n\telse {\n\t\tvec4 co = shadowpersmat*vec4(rco, 1.0);\n\n\t\t//float bias = (1.5 - inp*inp)*shadowbias;\n\t\tco.z -= shadowbias*co.w;\n\t\t\n\t\tif (co.w > 0.0 && co.x > 0.0 && co.x/co.w < 1.0 && co.y > 0.0 && co.y/co.w < 1.0)\n\t\t\tresult = step(co.z,texture2D(shadowmap, co.xy).x);\n\t\telse\n\t\t\tresult = 1.0;\n\t}\n}\n\nvoid test_shadowbuf_vsm(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float bleedbias, float inp, out float result)\n{\n\tif(inp <= 0.0) {\n\t\tresult = 0.0;\n\t}\n\telse {\n\t\tvec4 co = shadowpersmat*vec4(rco, 1.0);\n\t\tif (co.w > 0.0 && co.x > 0.0 && co.x/co.w < 1.0 && co.y > 0.0 && co.y/co.w < 1.0) {\n\t\t\tvec2 moments = texture2DProj(shadowmap, co).rg;\n\t\t\tfloat dist = co.z/co.w;\n\t\t\tfloat p = 0.0;\n\t\t\t\n\t\t\tif(dist <= moments.x)\n\t\t\t\tp = 1.0;\n\n\t\t\tfloat variance = moments.y - (moments.x*moments.x);\n\t\t\tvariance = max(variance, shadowbias/10.0);\n\n\t\t\tfloat d = moments.x - dist;\n\t\t\tfloat p_max = variance / (variance + d*d);\n\n\t\t\t// Now reduce light-bleeding by removing the [0, x] tail and linearly rescaling (x, 1]\n\t\t\tp_max = clamp((p_max-bleedbias)/(1.0-bleedbias), 0.0, 1.0);\n\n\t\t\tresult = max(p, p_max);\n\t\t}\n\t\telse {\n\t\t\tresult = 1.0;\n\t\t}\n\t}\n}\n\nvoid shadows_only(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, vec3 shadowcolor, float inp, out vec3 result)\n{\n\tresult = vec3(1.0);\n\n\tif(inp > 0.0) {\n\t\tfloat shadfac;\n\n\t\ttest_shadowbuf(rco, shadowmap, shadowpersmat, shadowbias, inp, shadfac);\n\t\tresult -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);\n\t}\n}\n\nvoid shadows_only_vsm(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float bleedbias, vec3 shadowcolor, float inp, out vec3 result)\n{\n\tresult = vec3(1.0);\n\n\tif(inp > 0.0) {\n\t\tfloat shadfac;\n\n\t\ttest_shadowbuf_vsm(rco, shadowmap, shadowpersmat, shadowbias, bleedbias, inp, shadfac);\n\t\tresult -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);\n\t}\n}\n\nvoid shade_light_texture(vec3 rco, sampler2D cookie, mat4 shadowpersmat, out vec4 result)\n{\n\n\tvec4 co = shadowpersmat*vec4(rco, 1.0);\n\n\tresult = texture2DProj(cookie, co);\n}\n\nvoid shade_exposure_correct(vec3 col, float linfac, float logfac, out vec3 outcol)\n{\n\toutcol = linfac*(1.0 - exp(col*logfac));\n}\n\nvoid shade_mist_factor(vec3 co, float miststa, float mistdist, float misttype, float misi, out float outfac)\n{\n\tfloat fac, zcor;\n\n\tzcor = (0.0 == 0.0)? length(co): -co[2];\n\t\n\tfac = clamp((zcor-miststa)/mistdist, 0.0, 1.0);\n\tif(misttype == 0.0) fac *= fac;\n\telse if(misttype == 1.0);\n\telse fac = sqrt(fac);\n\n\toutfac = 1.0 - (1.0-fac)*(1.0-misi);\n}\n\nvoid shade_world_mix(vec3 hor, vec4 col, out vec4 outcol)\n{\n\tfloat fac = clamp(col.a, 0.0, 1.0);\n\toutcol = vec4(mix(hor, col.rgb, fac), col.a);\n}\n\nvoid shade_alpha_opaque(vec4 col, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, 1.0);\n}\n\nvoid shade_alpha_obcolor(vec4 col, vec4 obcol, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, col.a*obcol.a);\n}\n\n/*********** NEW SHADER UTILITIES **************/\n\nfloat fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta)\n{\n\t/* compute fresnel reflectance without explicitly computing\n\t * the refracted direction */\n\tfloat c = abs(dot(Incoming, Normal));\n\tfloat g = eta * eta - 1.0 + c * c;\n\tfloat result;\n\n\tif(g > 0.0) {\n\t\tg = sqrt(g);\n\t\tfloat A =(g - c)/(g + c);\n\t\tfloat B =(c *(g + c)- 1.0)/(c *(g - c)+ 1.0);\n\t\tresult = 0.5 * A * A *(1.0 + B * B);\n\t}\n\telse {\n\t\tresult = 1.0;  /* TIR (no refracted component) */\n\t}\n\n\treturn result;\n}\n\nfloat hypot(float x, float y)\n{\n\treturn sqrt(x*x + y*y);\n}\n\n/*********** NEW SHADER NODES ***************/\n\n#define NUM_LIGHTS 3\n\n/* bsdfs */\n\nvoid node_bsdf_diffuse(vec4 color, float roughness, vec3 N, out vec4 result)\n{\n\t/* ambient light */\n\tvec3 L = vec3(0.2);\n\n\t/* directional lights */\n\tfor(int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 light_position = vec3(0,0,0).xyz;\n\t\tvec3 light_diffuse = vec3(0,0,0).rgb;\n\n\t\tfloat bsdf = max(dot(N, light_position), 0.0);\n\t\tL += light_diffuse*bsdf;\n\t}\n\n\tresult = vec4(L*color.rgb, 1.0);\n}\n\nvoid node_bsdf_glossy(vec4 color, float roughness, vec3 N, out vec4 result)\n{\n\t/* ambient light */\n\tvec3 L = vec3(0.2);\n\n\t/* directional lights */\n\tfor(int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 light_position = vec3(0,0,0).xyz;\n\t\tvec3 H = vec3(0,0,0).xyz;\n\t\tvec3 light_diffuse = vec3(0,0,0).rgb;\n\t\tvec3 light_specular = vec3(0,0,0).rgb;\n\n\t\t/* we mix in some diffuse so low roughness still shows up */\n\t\tfloat bsdf = 0.5*pow(max(dot(N, H), 0.0), 1.0/roughness);\n\t\tbsdf += 0.5*max(dot(N, light_position), 0.0);\n\t\tL += light_specular*bsdf;\n\t}\n\n\tresult = vec4(L*color.rgb, 1.0);\n}\n\nvoid node_bsdf_anisotropic(vec4 color, float roughness, float anisotropy, float rotation, vec3 N, vec3 T, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_glass(vec4 color, float roughness, float ior, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_toon(vec4 color, float size, float tsmooth, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_translucent(vec4 color, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_transparent(vec4 color, out vec4 result)\n{\n\t/* this isn't right */\n\tresult.r = color.r;\n\tresult.g = color.g;\n\tresult.b = color.b;\n\tresult.a = 0.0;\n}\n\nvoid node_bsdf_velvet(vec4 color, float sigma, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_subsurface_scattering(vec4 color, float scale, vec3 radius, float sharpen, float texture_blur, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_hair(vec4 color, float offset, float roughnessu, float roughnessv, out vec4 result)\n{\n\tresult = color;\n}\n\n/* emission */\n\nvoid node_emission(vec4 color, float strength, vec3 N, out vec4 result)\n{\n\tresult = color*strength;\n}\n\n/* closures */\n\nvoid node_mix_shader(float fac, vec4 shader1, vec4 shader2, out vec4 shader)\n{\n\tshader = mix(shader1, shader2, fac);\n}\n\nvoid node_add_shader(vec4 shader1, vec4 shader2, out vec4 shader)\n{\n\tshader = shader1 + shader2;\n}\n\n/* fresnel */\n\nvoid node_fresnel(float ior, vec3 N, vec3 I, out float result)\n{\n\t/* handle perspective/orthographic */\n\tvec3 I_view = (0.0 == 0.0)? normalize(I): vec3(0.0, 0.0, -1.0);\n\n\tfloat eta = max(ior, 0.00001);\n\tresult = fresnel_dielectric(I_view, N, (gl_FrontFacing)? eta: 1.0/eta);\n}\n\n/* layer_weight */\n\nvoid node_layer_weight(float blend, vec3 N, vec3 I, out float fresnel, out float facing)\n{\n\t/* fresnel */\n\tfloat eta = max(1.0 - blend, 0.00001);\n\tfresnel = fresnel_dielectric(normalize(I), N, (gl_FrontFacing)? 1.0/eta : eta );\n\n\t/* facing */\n\tfacing = abs(dot(normalize(I), N));\n\tif(blend != 0.5) {\n\t\tblend = clamp(blend, 0.0, 0.99999);\n\t\tblend = (blend < 0.5)? 2.0*blend: 0.5/(1.0 - blend);\n\t\tfacing = pow(facing, blend);\n\t}\n\tfacing = 1.0 - facing;\n}\n\n/* gamma */\n\nvoid node_gamma(vec4 col, float gamma, out vec4 outcol)\n{\n\toutcol = col;\n\n\tif(col.r > 0.0)\n\t\toutcol.r = compatible_pow(col.r, gamma);\n\tif(col.g > 0.0)\n\t\toutcol.g = compatible_pow(col.g, gamma);\n\tif(col.b > 0.0)\n\t\toutcol.b = compatible_pow(col.b, gamma);\n}\n\n/* geometry */\n\nvoid node_attribute(vec3 attr_uv, out vec4 outcol, out vec3 outvec, out float outf)\n{\n\toutcol = vec4(attr_uv, 1.0);\n\toutvec = attr_uv;\n\toutf = (attr_uv.x + attr_uv.y + attr_uv.z)/3.0;\n}\n\nvoid node_geometry(vec3 I, vec3 N, mat4 toworld,\n\tout vec3 position, out vec3 normal, out vec3 tangent,\n\tout vec3 true_normal, out vec3 incoming, out vec3 parametric,\n\tout float backfacing)\n{\n\tposition = (toworld*vec4(I, 1.0)).xyz;\n\tnormal = (toworld*vec4(N, 0.0)).xyz;\n\ttangent = vec3(0.0);\n\ttrue_normal = normal;\n\n\t/* handle perspective/orthographic */\n\tvec3 I_view = (0.0 == 0.0)? normalize(I): vec3(0.0, 0.0, -1.0);\n\tincoming = -(toworld*vec4(I_view, 0.0)).xyz;\n\n\tparametric = vec3(0.0);\n\tbackfacing = (gl_FrontFacing)? 0.0: 1.0;\n}\n\nvoid node_tex_coord(vec3 I, vec3 N, mat4 viewinvmat, mat4 obinvmat,\n\tvec3 attr_orco, vec3 attr_uv,\n\tout vec3 generated, out vec3 normal, out vec3 uv, out vec3 object,\n\tout vec3 camera, out vec3 window, out vec3 reflection)\n{\n\tgenerated = attr_orco;\n\tnormal = normalize((obinvmat*(viewinvmat*vec4(N, 0.0))).xyz);\n\tuv = attr_uv;\n\tobject = (obinvmat*(viewinvmat*vec4(I, 1.0))).xyz;\n\tcamera = I;\n\twindow = gl_FragCoord.xyz;\n\treflection = reflect(N, I);\n\n}\n\n/* textures */\n\nvoid node_tex_gradient(vec3 co, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_checker(vec3 co, vec4 color1, vec4 color2, float scale, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_brick(vec3 co, vec4 color1, vec4 color2, vec4 mortar, float scale, float mortar_size, float bias, float brick_width, float row_height, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_clouds(vec3 co, float size, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_environment(vec3 co, sampler2D ima, out vec4 color)\n{\n\tfloat u = (atan(co.y, co.x) + M_PI)/(2.0*M_PI);\n\tfloat v = atan(co.z, hypot(co.x, co.y))/M_PI + 0.5;\n\n\tcolor = texture2D(ima, vec2(u, v));\n}\n\nvoid node_tex_environment_empty(vec3 co, out vec4 color)\n{\n\tcolor = vec4(0.0);\n}\n\nvoid node_tex_image(vec3 co, sampler2D ima, out vec4 color, out float alpha)\n{\n\tcolor = texture2D(ima, co.xy);\n\talpha = color.a;\n}\n\nvoid node_tex_image_empty(vec3 co, out vec4 color, out float alpha)\n{\n\tcolor = vec4(0.0);\n\talpha = 0.0;\n}\n\nvoid node_tex_magic(vec3 p, float scale, float distortion, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_musgrave(vec3 co, float scale, float detail, float dimension, float lacunarity, float offset, float gain, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_noise(vec3 co, float scale, float detail, float distortion, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_sky(vec3 co, out vec4 color)\n{\n\tcolor = vec4(1.0);\n}\n\nvoid node_tex_voronoi(vec3 co, float scale, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_wave(vec3 co, float scale, float distortion, float detail, float detail_scale, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\n/* light path */\n\nvoid node_light_path(\n\tout float is_camera_ray,\n\tout float is_shadow_ray,\n\tout float is_diffuse_ray,\n\tout float is_glossy_ray,\n\tout float is_singular_ray,\n\tout float is_reflection_ray,\n\tout float is_transmission_ray,\n\tout float ray_length,\n\tout float ray_depth,\n\tout float transparent_depth)\n{\n\tis_camera_ray = 1.0;\n\tis_shadow_ray = 0.0;\n\tis_diffuse_ray = 0.0;\n\tis_glossy_ray = 0.0;\n\tis_singular_ray = 0.0;\n\tis_reflection_ray = 0.0;\n\tis_transmission_ray = 0.0;\n\tray_length = 1.0;\n\tray_depth = 1.0;\n\ttransparent_depth = 1.0;\n}\n\nvoid node_light_falloff(float strength, float tsmooth, out float quadratic, out float linear, out float constant)\n{\n\tquadratic = strength;\n\tlinear = strength;\n\tconstant = strength;\n}\n\nvoid node_object_info(out vec3 location, out float object_index, out float material_index, out float random)\n{\n\tlocation = vec3(0.0);\n\tobject_index = 0.0;\n\tmaterial_index = 0.0;\n\trandom = 0.0;\n}\n\nvoid node_normal_map(float strength, vec4 color, vec3 N, out vec3 result)\n{\n\tresult = N;\n}\n\nvoid node_bump(float strength, float dist, float height, vec3 N, out vec3 result)\n{\n\tresult = N;\n}\n\n/* output */\n\nvoid node_output_material(vec4 surface, vec4 volume, float displacement, out vec4 result)\n{\n\tresult = surface;\n}\n\n/* ********************** matcap style render ******************** */\n\nvoid material_preview_matcap(vec4 color, sampler2D ima, vec4 N, vec4 mask, out vec4 result)\n{\n\tvec3 normal;\n\tvec2 tex;\n\t\n\t/* remap to 0.0 - 1.0 range. This is done because OpenGL 2.0 clamps colors \n\t * between shader stages and we want the full range of the normal */\n\tnormal = vec3(2.0, 2.0, 2.0) * vec3(N.x, N.y, N.z) - vec3(1.0, 1.0, 1.0);\n\tif (normal.z < 0.0) {\n\t\tnormal.z = 0.0;\n\t}\n\tnormal = normalize(normal);\n\n\ttex.x = 0.5 + 0.49 * normal.x;\n\ttex.y = 0.5 + 0.49 * normal.y;\n\tresult = texture2D(ima, tex) * mask;\n}"},{"use_mipmap":null,"formats":{"png":[{"file_size":286178,"height":1024,"width":1024,"file_name":"cuadricula.png"}],"astc":[{"file_size":467872,"height":1024,"format_enum":37844,"file_name":"cuadricula.astc","width":1024,"sRGB":true}]},"type":"TEXTURE","wrap":null,"name":"cuadricula","filter":null},{"attributes":[{"varname":"att0","datatype":3,"number":1,"name":0,"type":5}],"scene":"Scene","uniforms":[{"varname":"samp0","datatype":1,"size":0,"texnumber":0,"type":13,"wrap":"R","image":"cuadricula","filepath":"cuadricula.png","filter":true},{"varname":"unf26","datatype":4,"type":6,"lamp":"Lamp"},{"varname":"unf38","datatype":5,"type":11,"lamp":"Lamp"},{"varname":"unf63","datatype":4,"type":11,"lamp":"Lamp"}],"double_sided":false,"type":"MATERIAL","params":[],"fragment":"\n\r\nvarying vec3 varnormal;\nvarying vec3 varposition;\nvarying vec2 var0;\nuniform sampler2D samp0;\nconst vec3 cons17 = vec3(0.800000, 0.800000, 0.800000);\nconst float cons20 = float(1.000000);\nconst float cons22 = float(0.430000);\nuniform vec3 unf26;\nconst float cons35 = float(0.800000);\nuniform vec4 unf38;\nconst float cons40 = float(1.000000);\nconst vec4 cons44 = vec4(1.000000, 1.000000, 1.000000, 0.005000);\nconst float cons55 = float(12.000000);\nconst float cons58 = float(0.500000);\nuniform vec3 unf63;\nconst vec3 cons64 = vec3(1.000000, 1.000000, 1.000000);\nconst float cons77 = float(1.000000);\n\nvoid main(void)\n{\n\tvec3 facingnormal = (gl_FrontFacing)? varnormal: -varnormal;\n\tvec3 tmp2;\n\tvec3 tmp4;\n\tvec3 tmp6;\n\tfloat tmp9;\n\tvec4 tmp10;\n\tvec4 tmp12;\n\tfloat tmp14;\n\tvec4 tmp16;\n\tvec3 tmp21;\n\tvec4 tmp24;\n\tvec3 tmp25;\n\tvec3 tmp27;\n\tfloat tmp28;\n\tfloat tmp29;\n\tfloat tmp32;\n\tfloat tmp36;\n\tvec4 tmp39;\n\tfloat tmp41;\n\tvec4 tmp45;\n\tfloat tmp47;\n\tvec4 tmp51;\n\tfloat tmp56;\n\tfloat tmp61;\n\tvec3 tmp65;\n\tvec4 tmp68;\n\tvec4 tmp70;\n\tvec4 tmp72;\n\tvec4 tmp75;\n\tvec4 tmp78;\n\tvec4 tmp80;\n\tvec4 tmp82;\n\n\tshade_norm(facingnormal, tmp2);\n\tshade_view(varposition, tmp4);\n\ttexco_uv(var0, tmp6);\n\tmtex_image(tmp6, samp0, tmp9, tmp10);\n\tset_rgba(tmp10, tmp12);\n\tmtex_alpha_from_col(tmp10, tmp14);\n\tsrgb_to_linearrgb(tmp12, tmp16);\n\tmtex_rgb_blend(cons17, tmp16.rgb, tmp14, cons20, tmp21);\n\tshade_mul_value(cons22, vec4(tmp21, 1.0), tmp24);\n\tset_rgb_zero(tmp25);\n\tlamp_visibility_sun_hemi(unf26, tmp27, tmp28, tmp29);\n\tshade_inp(tmp2, tmp27, tmp32);\n\tshade_visifac(tmp32, tmp29, cons35, tmp36);\n\tshade_mul_value(tmp36, unf38, tmp39);\n\tmtex_value_invert(cons40, tmp41);\n\tmix_mult(tmp41, tmp39, cons44, tmp45);\n\tmtex_value_invert(tmp41, tmp47);\n\tshade_madd(tmp24, tmp45, vec4(tmp21, 1.0), tmp51);\n\tshade_cooktorr_spec(tmp2, tmp27, tmp4, cons55, tmp56);\n\tshade_spec_t(tmp47, cons58, tmp29, tmp56, tmp61);\n\tshade_add_spec(tmp61, unf63, cons64, tmp65);\n\tshade_add_clamped(vec4(tmp25, 1.0), vec4(tmp65, 1.0), tmp68);\n\tshade_clamp_positive(tmp68, tmp70);\n\tshade_clamp_positive(tmp51, tmp72);\n\tshade_add(tmp72, tmp70, tmp75);\n\tmtex_alpha_to_col(tmp75, cons77, tmp78);\n\tshade_alpha_opaque(tmp78, tmp80);\n\tlinearrgb_to_srgb(tmp80, tmp82);\n\n\tgl_FragColor = tmp82;\n}","name":"grid"}]