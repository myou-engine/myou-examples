[{"type": "SCENE", "ambient_color": [0.0, 0.0, 0.0], "background_color": [0.05087608844041824, 0.05087608844041824, 0.05087608844041824], "name": "Scene", "active_camera": "Camera", "frame_start": 1, "frame_end": 100, "stereo_eye_separation": 0.10000000149011612, "stereo": false, "fps": 24, "debug_physics": false, "gravity": [0, 0, -9.800000190734863]},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "wall_front", "color": [0.9849011898040771, 1.0, 0.969936192035675, 1.0], "scale": [9.966717720031738, 9.966717720031738, 9.966717720031738], "dimensions": [9.966717720031738, 9.966717720031738, 4.240382671356201], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "509f136f56662ef0cd2f31acb1800fcfd496487a", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.3084847529729207, "no_sleeping": false, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-0.6209187507629395, -11.19704818725586, 3.389460325241089], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 2, "angular_factor": [1, 1, 1], "offset_scale": [0.9999998807907104, 0.9999999403953552, 0.9999999403953552], "passes": [0], "lod_levels": [], "mesh_name": "wall", "materials": ["wood"], "phy_type": "STATIC", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 168, 36], "visible": true, "rot": [5.591469403043448e-07, 5.591475655819522e-07, 0.7071071863174438, 0.707106351852417], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "wall_right", "color": [0.9849011898040771, 1.0, 0.969936192035675, 1.0], "scale": [14.34070110321045, 9.966717720031738, 9.966717720031738], "dimensions": [14.34070110321045, 9.966717720031738, 4.240382671356201], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "509f136f56662ef0cd2f31acb1800fcfd496487a", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.3084847529729207, "no_sleeping": false, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [6.242065906524658, -2.387599229812622, 3.389460325241089], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 2, "angular_factor": [1, 1, 1], "offset_scale": [1.0, 0.9999999403953552, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "wall", "materials": ["wood"], "phy_type": "STATIC", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 168, 36], "visible": true, "rot": [0.49999961256980896, 0.5000001192092896, -0.5000003576278687, -0.49999988079071045], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "wall_left", "color": [0.9849011898040771, 1.0, 0.969936192035675, 1.0], "scale": [14.773139953613281, 9.966717720031738, 9.966717720031738], "dimensions": [14.773139953613281, 9.966717720031738, 4.240382671356201], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "509f136f56662ef0cd2f31acb1800fcfd496487a", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.3084847529729207, "no_sleeping": false, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-7.530557632446289, -2.361780881881714, 3.389460325241089], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 2, "angular_factor": [1, 1, 1], "offset_scale": [0.9999999403953552, 1.0, 0.9999999403953552], "passes": [0], "lod_levels": [], "mesh_name": "wall", "materials": ["wood"], "phy_type": "STATIC", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 168, 36], "visible": true, "rot": [0.4999994933605194, 0.5, 0.5000004768371582, 0.5], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "wall_back", "color": [0.9849011898040771, 1.0, 0.969936192035675, 1.0], "scale": [9.966717720031738, 9.966717720031738, 9.966717720031738], "dimensions": [9.966717720031738, 9.966717720031738, 4.240382671356201], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "509f136f56662ef0cd2f31acb1800fcfd496487a", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.3084847529729207, "no_sleeping": false, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-0.6264052391052246, 6.235019207000732, 3.389460325241089], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 2, "angular_factor": [1, 1, 1], "offset_scale": [1.0, 1.0000001192092896, 1.0000001192092896], "passes": [0], "lod_levels": [], "mesh_name": "wall", "materials": ["wood"], "phy_type": "STATIC", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 168, 36], "visible": true, "rot": [0.7071064710617065, 0.7071070671081543, 0.0, 0.0], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box", "color": [0.8410549163818359, 0.22786130011081696, 1.0, 1.0], "scale": [1.0925374031066895, 1.0925376415252686, 1.0925374031066895], "dimensions": [1.1936376094818115, 1.1936380863189697, 1.193637490272522], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [0.7551977634429932, -3.4460482597351074, 2.7053680419921875], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [1.0, 1.0, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.4187456965446472, 0.7814332842826843, -0.07919841259717941, 0.4557868540287018], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.001", "color": [1.0, 0.5506851673126221, 0.027008961886167526, 1.0], "scale": [1.0925374031066895, 1.0925372838974, 1.0925374031066895], "dimensions": [1.1936376094818115, 1.1936376094818115, 1.193637490272522], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-0.44278278946876526, -1.411510944366455, 2.628166675567627], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [1.0000001192092896, 1.0, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.9287685751914978, 0.058410871773958206, -0.359860360622406, 0.06691677123308182], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.020", "color": [1.0, 0.22026363015174866, 0.3961241841316223, 1.0], "scale": [1.0, 1.0, 1.0], "dimensions": [1.0925370454788208, 1.0925371646881104, 1.0925369262695312], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-1.7477669715881348, -4.21139669418335, 0.9462100267410278], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [1.0, 1.0, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.9310575127601624, 0.25906339287757874, -0.22958002984523773, 0.11537376791238785], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.019", "color": [0.18419227004051208, 1.0, 0.7569334506988525, 1.0], "scale": [1.0925371646881104, 1.0925371646881104, 1.0925371646881104], "dimensions": [1.1936373710632324, 1.193637490272522, 1.1936372518539429], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-3.2632479667663574, -3.228484869003296, 2.7502241134643555], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [0.9999998807907104, 1.0, 0.9999999403953552], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.9507845640182495, 0.021376052871346474, -0.3062562346458435, 0.04194121062755585], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.018", "color": [0.48077717423439026, 1.0, 0.5173617005348206, 1.0], "scale": [1.0925370454788208, 1.0925371646881104, 1.0925371646881104], "dimensions": [1.1936372518539429, 1.193637490272522, 1.1936372518539429], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [0.2931634783744812, -0.23521865904331207, 4.104060649871826], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [1.0, 1.0, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.7785245776176453, 0.21234937012195587, -0.5658875107765198, 0.1690518856048584], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.017", "color": [0.1906442642211914, 0.10852302610874176, 1.0, 1.0], "scale": [1.0925371646881104, 1.0925371646881104, 1.0925371646881104], "dimensions": [1.1936373710632324, 1.193637490272522, 1.1936372518539429], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [0.4402275085449219, -3.220968008041382, 4.639638423919678], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [0.9999998807907104, 1.0, 0.9999999403953552], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.9507845640182495, 0.021376052871346474, -0.3062562346458435, 0.04194121062755585], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.016", "color": [0.09534817934036255, 0.32486680150032043, 1.0, 1.0], "scale": [1.0925372838974, 1.0925368070602417, 1.0925369262695312], "dimensions": [1.193637490272522, 1.1936370134353638, 1.1936368942260742], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-2.4767165184020996, -1.6428799629211426, 5.402366638183594], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [1.0000001192092896, 1.0, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.9100008010864258, -0.07224526256322861, -0.38049644231796265, -0.1479928344488144], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.015", "color": [1.0, 0.04186555743217468, 0.05154984071850777, 1.0], "scale": [1.0925370454788208, 1.0925374031066895, 1.0925372838974], "dimensions": [1.1936372518539429, 1.193637728691101, 1.1936373710632324], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-3.8710360527038574, -1.7577853202819824, 4.395431041717529], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [0.9999999403953552, 0.9999999403953552, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.9705750942230225, 0.2255410999059677, -0.06760530918836594, -0.05044485628604889], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.014", "color": [1.0, 0.30575770139694214, 0.06035693734884262, 1.0], "scale": [1.092537522315979, 1.0925372838974, 1.0925374031066895], "dimensions": [1.193637728691101, 1.1936376094818115, 1.193637490272522], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-1.478100061416626, 0.924797534942627, 6.571749687194824], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [1.0, 0.9999999403953552, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.9004626870155334, -0.29679542779922485, -0.2963232100009918, 0.11520495265722275], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.013", "color": [0.20696669816970825, 0.5174269676208496, 1.0, 1.0], "scale": [1.0925371646881104, 1.0925371646881104, 1.092537522315979], "dimensions": [1.1936373710632324, 1.193637490272522, 1.1936376094818115], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [2.2064154148101807, -3.4319615364074707, 4.419121265411377], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [0.9999999403953552, 1.0, 0.9999999403953552], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.9453842043876648, -0.2785828113555908, 0.00894330907613039, 0.16899822652339935], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.012", "color": [1.0, 0.7878773212432861, 0.046919532120227814, 1.0], "scale": [1.0925371646881104, 1.0925374031066895, 1.0925371646881104], "dimensions": [1.1936373710632324, 1.193637728691101, 1.1936372518539429], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-3.850296974182129, 0.3489868640899658, 5.72845983505249], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [0.9999999403953552, 0.9999998807907104, 0.9999998807907104], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.9462177753448486, 0.1754094511270523, 0.22242876887321472, -0.156297504901886], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.010", "color": [0.0352468341588974, 0.027979951351881027, 1.0, 1.0], "scale": [1.0925371646881104, 1.0925368070602417, 1.0925372838974], "dimensions": [1.1936373710632324, 1.1936370134353638, 1.1936373710632324], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [0.19625836610794067, 0.09745451807975769, 5.50060510635376], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [1.0, 1.0000001192092896, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.973992645740509, -0.14942407608032227, -0.08321021497249603, -0.1486167460680008], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.009", "color": [1.0, 0.03686762601137161, 0.028975268825888634, 1.0], "scale": [1.0925371646881104, 1.0925374031066895, 1.0925371646881104], "dimensions": [1.1936372518539429, 1.193637728691101, 1.1936372518539429], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-2.0348405838012695, -1.9659907817840576, 3.257258176803589], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [1.0000001192092896, 0.9999999403953552, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.9251450896263123, 0.21329592168331146, -0.3049015998840332, 0.07514283061027527], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.007", "color": [1.0, 0.19228991866111755, 0.03390789031982422, 1.0], "scale": [1.0925371646881104, 1.0925371646881104, 1.0925371646881104], "dimensions": [1.1936373710632324, 1.193637490272522, 1.1936372518539429], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-2.547905683517456, -3.535053253173828, 6.94291353225708], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [1.0, 1.0, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [1.0, 0.0, 0.0, 0.0], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.008", "color": [0.11902099847793579, 0.45980578660964966, 1.0, 1.0], "scale": [1.0925368070602417, 1.0925368070602417, 1.0925369262695312], "dimensions": [1.1936368942260742, 1.1936370134353638, 1.1936368942260742], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-3.6899495124816895, 0.348987340927124, 2.2409114837646484], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [0.9999999403953552, 0.9999998807907104, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.9659219980239868, 0.2521161139011383, 0.05846183001995087, -0.0037863589823246002], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.006", "color": [0.13338840007781982, 1.0, 0.4168069064617157, 1.0], "scale": [1.0925374031066895, 1.0925372838974, 1.0925372838974], "dimensions": [1.1936376094818115, 1.1936376094818115, 1.1936373710632324], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-2.0864787101745605, 0.348987340927124, 2.2809979915618896], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [1.0, 1.0, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.9973232746124268, 0.041083432734012604, -0.05872785672545433, 0.01447344571352005], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "roorh", "tris_count": 7558.0, "color": [1.0, 1.0, 1.0, 1.0], "scale": [1.0, 1.0, 1.0], "dimensions": [1.1936510801315308, 0.9414867162704468, 2.5143043994903564], "mass": 1.0, "scene": "Scene", "all_f": false, "center": [0.0, -0.13620978593826294, 0.5648906230926514], "collision_mask": 255, "zindex": 1, "collision_bounds_type": "CONVEX_HULL", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "1c697ed340e3713fa7f6ba108d03254ce75d2f19", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.0011843284700809587, "no_sleeping": false, "elasticity": 0.0, "actions": ["simple_action"], "phy_mesh": {"stride": 16, "offsets": [0, 0, 752, 1137], "all_f": 0, "hash": "m983433630319878331", "mesh_name": "roorh.009", "elements": [], "tris_count": 379.0}, "friction": 0.5, "rot_mode": "Q", "pos": [-0.6303873062133789, -5.596325397491455, 0.0], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [1.0, 1.0, 1.0], "materials": ["skin", "cloth", "leather", "metal", "crystal"], "lod_levels": [{"offsets": [0, 0, 182, 78, 2737, 1137, 6181, 2349, 8435, 3264, 8820, 3345], "hash": "4772e0133397d41c6a0277cdefe0d5c808da8333", "factor": 0.1475258004763165, "shape_multiplier": 1.0, "uv_multiplier": 1.0, "avg_poly_area": 0.007357489231482776}, {"offsets": [0, 0, 504, 306, 6881, 3948, 14189, 7641, 20510, 11079, 21420, 11484], "hash": "ac113278c55a41ad4cec659c7adcd97451879743", "factor": 0.5064831966128606, "shape_multiplier": 1.0, "uv_multiplier": 1.0, "avg_poly_area": 0.0022991991262716017}], "mesh_name": "roorh", "rot": [1.0, 0.0, 0.0, 0.0], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 1274, 864, 11648, 7368, 24360, 14742, 35644, 21858, 37142, 22674], "visible": true, "passes": [0, 0, 0, 0, 0], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "box.011", "color": [1.0, 0.23812496662139893, 0.8593958020210266, 1.0], "scale": [1.0925372838974, 1.0925374031066895, 1.0925372838974], "dimensions": [1.193637490272522, 1.193637728691101, 1.1936373710632324], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "3aeb76f3a47fbb6e51813ebfc943793230dcc359", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.15204958071593533, "no_sleeping": true, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [1.9400330781936646, 0.0974549949169159, 2.033100128173828], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 1, "angular_factor": [1, 1, 1], "offset_scale": [1.0, 1.0000001192092896, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "box", "materials": ["wood"], "phy_type": "RIGID_BODY", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 672, 132], "visible": true, "rot": [0.45821407437324524, 0.870288610458374, 0.029911300167441368, 0.17816604673862457], "radius": 1.0, "anisotropic_friction": false},{"type": "MESH", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "linear_factor": [1, 1, 1], "parent_bone": "", "name": "floor", "color": [0.9849011898040771, 1.0, 0.969936192035675, 1.0], "scale": [9.966717720031738, 13.552196502685547, 9.966717720031738], "dimensions": [9.966717720031738, 13.552196502685547, 4.240382671356201], "mass": 1.0, "scene": "Scene", "all_f": false, "elasticity": 0.0, "collision_mask": 255, "zindex": 1, "collision_bounds_type": "BOX", "friction_coefficients": [1.0, 1.0, 1.0], "hash": "509f136f56662ef0cd2f31acb1800fcfd496487a", "shape_multiplier": 1.0, "elements": [["normal"], ["tangent"], ["uv", "UVMap"]], "avg_poly_area": 0.3084847529729207, "no_sleeping": false, "center": [0.0, 0.0, 0.0], "actions": [], "friction": 0.5, "rot_mode": "Q", "pos": [-0.6462366580963135, -2.4257349967956543, -2.8536577224731445], "is_ghost": false, "uv_multiplier": 1.0, "collision_group": 2, "angular_factor": [1, 1, 1], "offset_scale": [1.0, 1.0, 1.0], "passes": [0], "lod_levels": [], "mesh_name": "wall", "materials": ["wood"], "phy_type": "STATIC", "collision_margin": 0.03999999910593033, "stride": 28, "offsets": [0, 0, 168, 36], "visible": true, "rot": [1.0, 0.0, 0.0, 0.0], "radius": 1.0, "anisotropic_friction": false},{"type": "LAMP", "parent": null, "clip_start": 1.0007989406585693, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "actions": [], "linear_factor": [1, 1, 1], "friction": 0.5, "parent_bone": "", "name": "Lamp", "color": [2.0, 1.793802261352539, 1.5172812938690186], "scale": [1.0, 1.0, 1.0], "dimensions": [0.0, 0.0, 0.0], "pos": [6.275333881378174, -7.581808567047119, 13.175880432128906], "scene": "Scene", "visible": true, "is_ghost": false, "elasticity": 0, "collision_margin": 0.05999999865889549, "collision_group": 1, "angular_factor": [1, 1, 1], "lamp_type": "SUN", "collision_bounds_type": "BOX", "offset_scale": [1.0, 1.0, 1.0], "friction_coefficients": [1.0, 1.0, 1.0], "tex_size": 256, "frustum_size": 10.0, "rot": [0.800736129283905, 0.21104666590690613, 0.07989416271448135, 0.5548855066299438], "phy_type": "STATIC", "collision_mask": 255, "clip_end": 30.00200080871582, "falloff_distance": 29.999982833862305, "mass": 1.0, "no_sleeping": false, "energy": 1, "rot_mode": "Q", "shadow": true, "radius": 1.0, "anisotropic_friction": false},{"type": "CAMERA", "parent": null, "properties": {}, "collision_compound": false, "dupli_group": null, "form_factor": 0.4000000059604645, "actions": [], "linear_factor": [1, 1, 1], "sensor_fit": "AUTO", "friction": 0.5, "parent_bone": "", "name": "Camera", "color": [0.0, 0.0, 0.0, 0.0], "scale": [1.0, 1.0000001192092896, 1.0000001192092896], "dimensions": [0.0, 0.0, 0.0], "pos": [-0.5971494317054749, -8.964142799377441, 0.7048674821853638], "scene": "Scene", "visible": true, "is_ghost": false, "elasticity": 0, "collision_margin": 0.05999999865889549, "collision_group": 1, "angular_factor": [1, 1, 1], "clip_start": 0.10000000149011612, "collision_bounds_type": "BOX", "offset_scale": [1.0, 1.0000001192092896, 1.0000001192092896], "friction_coefficients": [1.0, 1.0, 1.0], "rot": [0.7071067094802856, 0.7071068286895752, 0.0, 0.0], "phy_type": "NO_COLLISION", "collision_mask": 255, "clip_end": 100.0, "mass": 1.0, "no_sleeping": false, "angle": 1.612257719039917, "rot_mode": "Q", "ortho_scale": 7.314285755157471, "cam_type": "PERSP", "radius": 1.0, "anisotropic_friction": false},{"type": "SHADER_LIB", "code": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\nprecision highp int;\n/* Converters */\n\nfloat convert_rgba_to_float(vec4 color)\n{\n#ifdef USE_NEW_SHADING\n\treturn color.r*0.2126 + color.g*0.7152 + color.b*0.0722;\n#else\n\treturn (color.r + color.g + color.b) / 3.0;\n#endif\n}\n\nfloat exp_blender(float f)\n{\n\treturn pow(2.71828182846, f);\n}\n\nfloat compatible_pow(float x, float y)\n{\n\tif(y == 0.0) /* x^0 -> 1, including 0^0 */\n\t\treturn 1.0;\n\n\t/* glsl pow doesn't accept negative x */\n\tif(x < 0.0) {\n\t\tif(mod(-y, 2.0) == 0.0)\n\t\t\treturn pow(-x, y);\n\t\telse\n\t\t\treturn -pow(-x, y);\n\t}\n\telse if(x == 0.0)\n\t\treturn 0.0;\n\n\treturn pow(x, y);\n}\n\nvoid rgb_to_hsv(vec4 rgb, out vec4 outcol)\n{\n\tfloat cmax, cmin, h, s, v, cdelta;\n\tvec3 c;\n\n\tcmax = max(rgb[0], max(rgb[1], rgb[2]));\n\tcmin = min(rgb[0], min(rgb[1], rgb[2]));\n\tcdelta = cmax-cmin;\n\n\tv = cmax;\n\tif (cmax!=0.0)\n\t\ts = cdelta/cmax;\n\telse {\n\t\ts = 0.0;\n\t\th = 0.0;\n\t}\n\n\tif (s == 0.0) {\n\t\th = 0.0;\n\t}\n\telse {\n\t\tc = (vec3(cmax, cmax, cmax) - rgb.xyz)/cdelta;\n\n\t\tif (rgb.x==cmax) h = c[2] - c[1];\n\t\telse if (rgb.y==cmax) h = 2.0 + c[0] -  c[2];\n\t\telse h = 4.0 + c[1] - c[0];\n\n\t\th /= 6.0;\n\n\t\tif (h<0.0)\n\t\t\th += 1.0;\n\t}\n\n\toutcol = vec4(h, s, v, rgb.w);\n}\n\nvoid hsv_to_rgb(vec4 hsv, out vec4 outcol)\n{\n\tfloat i, f, p, q, t, h, s, v;\n\tvec3 rgb;\n\n\th = hsv[0];\n\ts = hsv[1];\n\tv = hsv[2];\n\n\tif(s==0.0) {\n\t\trgb = vec3(v, v, v);\n\t}\n\telse {\n\t\tif(h==1.0)\n\t\t\th = 0.0;\n\t\t\n\t\th *= 6.0;\n\t\ti = floor(h);\n\t\tf = h - i;\n\t\trgb = vec3(f, f, f);\n\t\tp = v*(1.0-s);\n\t\tq = v*(1.0-(s*f));\n\t\tt = v*(1.0-(s*(1.0-f)));\n\t\t\n\t\tif (i == 0.0) rgb = vec3(v, t, p);\n\t\telse if (i == 1.0) rgb = vec3(q, v, p);\n\t\telse if (i == 2.0) rgb = vec3(p, v, t);\n\t\telse if (i == 3.0) rgb = vec3(p, q, v);\n\t\telse if (i == 4.0) rgb = vec3(t, p, v);\n\t\telse rgb = vec3(v, p, q);\n\t}\n\n\toutcol = vec4(rgb, hsv.w);\n}\n\nfloat srgb_to_linearrgb(float c)\n{\n\tif(c < 0.04045)\n\t\treturn (c < 0.0) ? 0.0: c * (1.0 / 12.92);\n\telse\n\t\treturn pow((c + 0.055)*(1.0/1.055), 2.4);\n}\n\nfloat linearrgb_to_srgb(float c)\n{\n\tif(c < 0.0031308)\n\t\treturn (c < 0.0) ? 0.0: c * 12.92;\n\telse\n\t\treturn 1.055 * pow(c, 1.0/2.4) - 0.055;\n}\n\nvoid srgb_to_linearrgb(vec4 col_from, out vec4 col_to)\n{\n\tcol_to.r = srgb_to_linearrgb(col_from.r);\n\tcol_to.g = srgb_to_linearrgb(col_from.g);\n\tcol_to.b = srgb_to_linearrgb(col_from.b);\n\tcol_to.a = col_from.a;\n}\n\nvoid linearrgb_to_srgb(vec4 col_from, out vec4 col_to)\n{\n\tcol_to.r = linearrgb_to_srgb(col_from.r);\n\tcol_to.g = linearrgb_to_srgb(col_from.g);\n\tcol_to.b = linearrgb_to_srgb(col_from.b);\n\tcol_to.a = col_from.a;\n}\n\n#define M_PI 3.14159265358979323846\n#define M_1_PI 0.31830988618379069\n\n/*********** SHADER NODES ***************/\n\nvoid vcol_attribute(vec4 attvcol, out vec4 vcol)\n{\n\tvcol = vec4(attvcol.x/255.0, attvcol.y/255.0, attvcol.z/255.0, 1.0);\n}\n\nvoid uv_attribute(vec2 attuv, out vec3 uv)\n{\n\tuv = vec3(attuv*2.0 - vec2(1.0, 1.0), 0.0);\n}\n\nvoid geom(vec3 co, vec3 nor, mat4 viewinvmat, vec3 attorco, vec2 attuv, vec4 attvcol, out vec3 global, out vec3 local, out vec3 view, out vec3 orco, out vec3 uv, out vec3 normal, out vec4 vcol, out float vcol_alpha, out float frontback)\n{\n\tlocal = co;\n\tview = (0.0 == 0.0)? normalize(local): vec3(0.0, 0.0, -1.0);\n\tglobal = (viewinvmat*vec4(local, 1.0)).xyz;\n\torco = attorco;\n\tuv_attribute(attuv, uv);\n\tnormal = -normalize(nor);\t/* blender render normal is negated */\n\tvcol_attribute(attvcol, vcol);\n\tsrgb_to_linearrgb(vcol, vcol);\n\tvcol_alpha = attvcol.a;\n\tfrontback = (gl_FrontFacing)? 1.0: 0.0;\n}\n\nvoid particle_info(vec4 sprops, vec3 loc, vec3 vel, vec3 avel, out float index, out float age, out float life_time, out vec3 location, out float size, out vec3 velocity, out vec3 angular_velocity)\n{\n    index = sprops.x;\n    age = sprops.y;\n    life_time = sprops.z;\n    size = sprops.w;\n\n    location = loc;\n    velocity = vel;\n    angular_velocity = avel;\n}\n\nvoid vect_normalize(vec3 vin, out vec3 vout)\n{\n\tvout = normalize(vin);\n}\n\nvoid direction_transform_m4v3(vec3 vin, mat4 mat, out vec3 vout)\n{\n\tvout = (mat*vec4(vin, 0.0)).xyz;\n}\n\nvoid point_transform_m4v3(vec3 vin, mat4 mat, out vec3 vout)\n{\n\tvout = (mat*vec4(vin, 1.0)).xyz;\n}\n\nvoid mapping(vec3 vec, mat4 mat, vec3 minvec, vec3 maxvec, float domin, float domax, out vec3 outvec)\n{\n\toutvec = (mat * vec4(vec, 1.0)).xyz;\n\tif(domin == 1.0)\n\t\toutvec = max(outvec, minvec);\n\tif(domax == 1.0)\n\t\toutvec = min(outvec, maxvec);\n}\n\nvoid camera(vec3 co, out vec3 outview, out float outdepth, out float outdist)\n{\n\toutdepth = abs(co.z);\n\toutdist = length(co);\n\toutview = normalize(co);\n}\n\nvoid lamp(vec4 col, float energy, vec3 lv, float dist, vec3 shadow, float visifac, out vec4 outcol, out vec3 outlv, out float outdist, out vec4 outshadow, out float outvisifac)\n{\n\toutcol = col * energy;\n\toutlv = lv;\n\toutdist = dist;\n\toutshadow = vec4(shadow, 1.0);\n\toutvisifac = visifac;\n}\n\nvoid math_add(float val1, float val2, out float outval)\n{\n\toutval = val1 + val2;\n}\n\nvoid math_subtract(float val1, float val2, out float outval)\n{\n\toutval = val1 - val2;\n}\n\nvoid math_multiply(float val1, float val2, out float outval)\n{\n\toutval = val1 * val2;\n}\n\nvoid math_divide(float val1, float val2, out float outval)\n{\n\tif (val2 == 0.0)\n\t\toutval = 0.0;\n\telse\n\t\toutval = val1 / val2;\n}\n\nvoid math_sine(float val, out float outval)\n{\n\toutval = sin(val);\n}\n\nvoid math_cosine(float val, out float outval)\n{\n\toutval = cos(val);\n}\n\nvoid math_tangent(float val, out float outval)\n{\n\toutval = tan(val);\n}\n\nvoid math_asin(float val, out float outval)\n{\n\tif (val <= 1.0 && val >= -1.0)\n\t\toutval = asin(val);\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_acos(float val, out float outval)\n{\n\tif (val <= 1.0 && val >= -1.0)\n\t\toutval = acos(val);\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_atan(float val, out float outval)\n{\n\toutval = atan(val);\n}\n\nvoid math_pow(float val1, float val2, out float outval)\n{\n\tif (val1 >= 0.0) {\n\t\toutval = compatible_pow(val1, val2);\n\t}\n\telse {\n\t\tfloat val2_mod_1 = mod(abs(val2), 1.0);\n\n\t\tif (val2_mod_1 > 0.999 || val2_mod_1 < 0.001)\n\t\t\toutval = compatible_pow(val1, floor(val2 + 0.5));\n\t\telse\n\t\t\toutval = 0.0;\n\t}\n}\n\nvoid math_log(float val1, float val2, out float outval)\n{\n\tif(val1 > 0.0  && val2 > 0.0)\n\t\toutval= log2(val1) / log2(val2);\n\telse\n\t\toutval= 0.0;\n}\n\nvoid math_max(float val1, float val2, out float outval)\n{\n\toutval = max(val1, val2);\n}\n\nvoid math_min(float val1, float val2, out float outval)\n{\n\toutval = min(val1, val2);\n}\n\nvoid math_round(float val, out float outval)\n{\n\toutval= floor(val + 0.5);\n}\n\nvoid math_less_than(float val1, float val2, out float outval)\n{\n\tif(val1 < val2)\n\t\toutval = 1.0;\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_greater_than(float val1, float val2, out float outval)\n{\n\tif(val1 > val2)\n\t\toutval = 1.0;\n\telse\n\t\toutval = 0.0;\n}\n\nvoid math_modulo(float val1, float val2, out float outval)\n{\n\tif (val2 == 0.0)\n\t\toutval = 0.0;\n\telse\n\t\toutval = mod(val1, val2);\n\n\t/* change sign to match C convention, mod in GLSL will take absolute for negative numbers,\n\t * see https://www.opengl.org/sdk/docs/man/html/mod.xhtml */\n\toutval = (val1 > 0.0) ? outval : -outval;\n}\n\nvoid math_abs(float val1, out float outval)\n{\n    outval = abs(val1);\n}\n\nvoid squeeze(float val, float width, float center, out float outval)\n{\n\toutval = 1.0/(1.0 + pow(2.71828183, -((val-center)*width)));\n}\n\nvoid vec_math_add(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 + v2;\n\toutval = (abs(outvec[0]) + abs(outvec[1]) + abs(outvec[2]))/3.0;\n}\n\nvoid vec_math_sub(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 - v2;\n\toutval = (abs(outvec[0]) + abs(outvec[1]) + abs(outvec[2]))/3.0;\n}\n\nvoid vec_math_average(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = v1 + v2;\n\toutval = length(outvec);\n\toutvec = normalize(outvec);\n}\n\nvoid vec_math_dot(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = vec3(0, 0, 0);\n\toutval = dot(v1, v2);\n}\n\nvoid vec_math_cross(vec3 v1, vec3 v2, out vec3 outvec, out float outval)\n{\n\toutvec = cross(v1, v2);\n\toutval = length(outvec);\n\toutvec /= outval;\n}\n\nvoid vec_math_normalize(vec3 v, out vec3 outvec, out float outval)\n{\n\toutval = length(v);\n\toutvec = normalize(v);\n}\n\nvoid vec_math_negate(vec3 v, out vec3 outv)\n{\n\toutv = -v;\n}\n\nvoid invert_z(vec3 v, out vec3 outv)\n{\n        v.z = -v.z;\n        outv = v;\n}\n\nvoid normal(vec3 dir, vec3 nor, out vec3 outnor, out float outdot)\n{\n\toutnor = nor;\n\toutdot = -dot(dir, nor);\n}\n\nvoid normal_new_shading(vec3 dir, vec3 nor, out vec3 outnor, out float outdot)\n{\n\toutnor = normalize(nor);\n\toutdot = dot(normalize(dir), nor);\n}\n\nvoid curves_vec(float fac, vec3 vec, sampler2D curvemap, out vec3 outvec)\n{\n\toutvec.x = texture2D(curvemap, vec2((vec.x + 1.0)*0.5, 0.0)).x;\n\toutvec.y = texture2D(curvemap, vec2((vec.y + 1.0)*0.5, 0.0)).y;\n\toutvec.z = texture2D(curvemap, vec2((vec.z + 1.0)*0.5, 0.0)).z;\n\n\tif (fac != 1.0)\n\t\toutvec = (outvec*fac) + (vec*(1.0-fac));\n\n}\n\nvoid curves_rgb(float fac, vec4 col, sampler2D curvemap, out vec4 outcol)\n{\n\toutcol.r = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.r, 0.0)).a, 0.0)).r;\n\toutcol.g = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.g, 0.0)).a, 0.0)).g;\n\toutcol.b = texture2D(curvemap, vec2(texture2D(curvemap, vec2(col.b, 0.0)).a, 0.0)).b;\n\n\tif (fac != 1.0)\n\t\toutcol = (outcol*fac) + (col*(1.0-fac));\n\n\toutcol.a = col.a;\n}\n\nvoid set_value(float val, out float outval)\n{\n\toutval = val;\n}\n\nvoid set_rgb(vec3 col, out vec3 outcol)\n{\n\toutcol = col;\n}\n\nvoid set_rgba(vec4 col, out vec4 outcol)\n{\n\toutcol = col;\n}\n\nvoid set_value_zero(out float outval)\n{\n\toutval = 0.0;\n}\n\nvoid set_value_one(out float outval)\n{\n\toutval = 1.0;\n}\n\nvoid set_rgb_zero(out vec3 outval)\n{\n\toutval = vec3(0.0);\n}\n\nvoid set_rgb_one(out vec3 outval)\n{\n\toutval = vec3(1.0);\n}\n\nvoid set_rgba_zero(out vec4 outval)\n{\n\toutval = vec4(0.0);\n}\n\nvoid set_rgba_one(out vec4 outval)\n{\n\toutval = vec4(1.0);\n}\n\nvoid brightness_contrast(vec4 col, float brightness, float contrast, out vec4 outcol)\n{\n\tfloat a = 1.0 + contrast;\n\tfloat b = brightness - contrast*0.5;\n\n\toutcol.r = max(a*col.r + b, 0.0);\n\toutcol.g = max(a*col.g + b, 0.0);\n\toutcol.b = max(a*col.b + b, 0.0);\n\toutcol.a = col.a;\n}\n\nvoid mix_blend(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_add(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 + col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_mult(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 * col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_screen(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = vec4(1.0) - (vec4(facm) + fac*(vec4(1.0) - col2))*(vec4(1.0) - col1);\n\toutcol.a = col1.a;\n}\n\nvoid mix_overlay(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tif(outcol.r < 0.5)\n\t\toutcol.r *= facm + 2.0*fac*col2.r;\n\telse\n\t\toutcol.r = 1.0 - (facm + 2.0*fac*(1.0 - col2.r))*(1.0 - outcol.r);\n\n\tif(outcol.g < 0.5)\n\t\toutcol.g *= facm + 2.0*fac*col2.g;\n\telse\n\t\toutcol.g = 1.0 - (facm + 2.0*fac*(1.0 - col2.g))*(1.0 - outcol.g);\n\n\tif(outcol.b < 0.5)\n\t\toutcol.b *= facm + 2.0*fac*col2.b;\n\telse\n\t\toutcol.b = 1.0 - (facm + 2.0*fac*(1.0 - col2.b))*(1.0 - outcol.b);\n}\n\nvoid mix_sub(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, col1 - col2, fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_div(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tif(col2.r != 0.0) outcol.r = facm*outcol.r + fac*outcol.r/col2.r;\n\tif(col2.g != 0.0) outcol.g = facm*outcol.g + fac*outcol.g/col2.g;\n\tif(col2.b != 0.0) outcol.b = facm*outcol.b + fac*outcol.b/col2.b;\n}\n\nvoid mix_diff(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = mix(col1, abs(col1 - col2), fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_dark(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol.rgb = min(col1.rgb, col2.rgb*fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_light(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol.rgb = max(col1.rgb, col2.rgb*fac);\n\toutcol.a = col1.a;\n}\n\nvoid mix_dodge(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\toutcol = col1;\n\n\tif(outcol.r != 0.0) {\n\t\tfloat tmp = 1.0 - fac*col2.r;\n\t\tif(tmp <= 0.0)\n\t\t\toutcol.r = 1.0;\n\t\telse if((tmp = outcol.r/tmp) > 1.0)\n\t\t\toutcol.r = 1.0;\n\t\telse\n\t\t\toutcol.r = tmp;\n\t}\n\tif(outcol.g != 0.0) {\n\t\tfloat tmp = 1.0 - fac*col2.g;\n\t\tif(tmp <= 0.0)\n\t\t\toutcol.g = 1.0;\n\t\telse if((tmp = outcol.g/tmp) > 1.0)\n\t\t\toutcol.g = 1.0;\n\t\telse\n\t\t\toutcol.g = tmp;\n\t}\n\tif(outcol.b != 0.0) {\n\t\tfloat tmp = 1.0 - fac*col2.b;\n\t\tif(tmp <= 0.0)\n\t\t\toutcol.b = 1.0;\n\t\telse if((tmp = outcol.b/tmp) > 1.0)\n\t\t\toutcol.b = 1.0;\n\t\telse\n\t\t\toutcol.b = tmp;\n\t}\n}\n\nvoid mix_burn(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat tmp, facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\ttmp = facm + fac*col2.r;\n\tif(tmp <= 0.0)\n\t\toutcol.r = 0.0;\n\telse if((tmp = (1.0 - (1.0 - outcol.r)/tmp)) < 0.0)\n\t\toutcol.r = 0.0;\n\telse if(tmp > 1.0)\n\t\toutcol.r = 1.0;\n\telse\n\t\toutcol.r = tmp;\n\n\ttmp = facm + fac*col2.g;\n\tif(tmp <= 0.0)\n\t\toutcol.g = 0.0;\n\telse if((tmp = (1.0 - (1.0 - outcol.g)/tmp)) < 0.0)\n\t\toutcol.g = 0.0;\n\telse if(tmp > 1.0)\n\t\toutcol.g = 1.0;\n\telse\n\t\toutcol.g = tmp;\n\n\ttmp = facm + fac*col2.b;\n\tif(tmp <= 0.0)\n\t\toutcol.b = 0.0;\n\telse if((tmp = (1.0 - (1.0 - outcol.b)/tmp)) < 0.0)\n\t\toutcol.b = 0.0;\n\telse if(tmp > 1.0)\n\t\toutcol.b = 1.0;\n\telse\n\t\toutcol.b = tmp;\n}\n\nvoid mix_hue(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2, tmp;\n\trgb_to_hsv(col2, hsv2);\n\n\tif(hsv2.y != 0.0) {\n\t\trgb_to_hsv(outcol, hsv);\n\t\thsv.x = hsv2.x;\n\t\thsv_to_rgb(hsv, tmp); \n\n\t\toutcol = mix(outcol, tmp, fac);\n\t\toutcol.a = col1.a;\n\t}\n}\n\nvoid mix_sat(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2;\n\trgb_to_hsv(outcol, hsv);\n\n\tif(hsv.y != 0.0) {\n\t\trgb_to_hsv(col2, hsv2);\n\n\t\thsv.y = facm*hsv.y + fac*hsv2.y;\n\t\thsv_to_rgb(hsv, outcol);\n\t}\n}\n\nvoid mix_val(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\tvec4 hsv, hsv2;\n\trgb_to_hsv(col1, hsv);\n\trgb_to_hsv(col2, hsv2);\n\n\thsv.z = facm*hsv.z + fac*hsv2.z;\n\thsv_to_rgb(hsv, outcol);\n}\n\nvoid mix_color(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\toutcol = col1;\n\n\tvec4 hsv, hsv2, tmp;\n\trgb_to_hsv(col2, hsv2);\n\n\tif(hsv2.y != 0.0) {\n\t\trgb_to_hsv(outcol, hsv);\n\t\thsv.x = hsv2.x;\n\t\thsv.y = hsv2.y;\n\t\thsv_to_rgb(hsv, tmp); \n\n\t\toutcol = mix(outcol, tmp, fac);\n\t\toutcol.a = col1.a;\n\t}\n}\n\nvoid mix_soft(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\tfloat facm = 1.0 - fac;\n\n\tvec4 one= vec4(1.0);\n\tvec4 scr= one - (one - col2)*(one - col1);\n\toutcol = facm*col1 + fac*((one - col1)*col2*col1 + col1*scr);\n}\n\nvoid mix_linear(float fac, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\tfac = clamp(fac, 0.0, 1.0);\n\n\toutcol = col1 + fac*(2.0*(col2 - vec4(0.5)));\n}\n\nvoid valtorgb(float fac, sampler2D colormap, out vec4 outcol, out float outalpha)\n{\n\toutcol = texture2D(colormap, vec2(fac, 0.0));\n\toutalpha = outcol.a;\n}\n\nvoid rgbtobw(vec4 color, out float outval)  \n{\n#ifdef USE_NEW_SHADING\n\toutval = color.r*0.2126 + color.g*0.7152 + color.b*0.0722;\n#else\n\toutval = color.r*0.35 + color.g*0.45 + color.b*0.2; /* keep these factors in sync with texture.h:RGBTOBW */\n#endif\n}\n\nvoid invert(float fac, vec4 col, out vec4 outcol)\n{\n\toutcol.xyz = mix(col.xyz, vec3(1.0, 1.0, 1.0) - col.xyz, fac);\n\toutcol.w = col.w;\n}\n\nvoid clamp_vec3(vec3 vec, vec3 min, vec3 max, out vec3 out_vec)\n{\n\tout_vec = clamp(vec, min, max);\n}\n\nvoid clamp_val(float value, float min, float max, out float out_value)\n{\n\tout_value = clamp(value, min, max);\n}\n\nvoid hue_sat(float hue, float sat, float value, float fac, vec4 col, out vec4 outcol)\n{\n\tvec4 hsv;\n\n\trgb_to_hsv(col, hsv);\n\n\thsv[0] += (hue - 0.5);\n\tif(hsv[0]>1.0) hsv[0]-=1.0; else if(hsv[0]<0.0) hsv[0]+= 1.0;\n\thsv[1] *= sat;\n\tif(hsv[1]>1.0) hsv[1]= 1.0; else if(hsv[1]<0.0) hsv[1]= 0.0;\n\thsv[2] *= value;\n\tif(hsv[2]>1.0) hsv[2]= 1.0; else if(hsv[2]<0.0) hsv[2]= 0.0;\n\n\thsv_to_rgb(hsv, outcol);\n\n\toutcol = mix(col, outcol, fac);\n}\n\nvoid separate_rgb(vec4 col, out float r, out float g, out float b)\n{\n\tr = col.r;\n\tg = col.g;\n\tb = col.b;\n}\n\nvoid combine_rgb(float r, float g, float b, out vec4 col)\n{\n\tcol = vec4(r, g, b, 1.0);\n}\n\nvoid separate_xyz(vec3 vec, out float x, out float y, out float z)\n{\n\tx = vec.r;\n\ty = vec.g;\n\tz = vec.b;\n}\n\nvoid combine_xyz(float x, float y, float z, out vec3 vec)\n{\n\tvec = vec3(x, y, z);\n}\n\nvoid separate_hsv(vec4 col, out float h, out float s, out float v)\n{\n\tvec4 hsv;\n\n\trgb_to_hsv(col, hsv);\n\th = hsv[0];\n\ts = hsv[1];\n\tv = hsv[2];\n}\n\nvoid combine_hsv(float h, float s, float v, out vec4 col)\n{\n\thsv_to_rgb(vec4(h, s, v, 1.0), col);\n}\n\nvoid output_node(vec4 rgb, float alpha, out vec4 outrgb)\n{\n\toutrgb = vec4(rgb.rgb, alpha);\n}\n\n/*********** TEXTURES ***************/\n\nvoid texture_flip_blend(vec3 vec, out vec3 outvec)\n{\n\toutvec = vec.yxz;\n}\n\nvoid texture_blend_lin(vec3 vec, out float outval)\n{\n\toutval = (1.0+vec.x)/2.0;\n}\n\nvoid texture_blend_quad(vec3 vec, out float outval)\n{\n\toutval = max((1.0+vec.x)/2.0, 0.0);\n\toutval *= outval;\n}\n\nvoid texture_wood_sin(vec3 vec, out float value, out vec4 color, out vec3 normal)\n{\n\tfloat a = sqrt(vec.x*vec.x + vec.y*vec.y + vec.z*vec.z)*20.0;\n\tfloat wi = 0.5 + 0.5*sin(a);\n\n\tvalue = wi;\n\tcolor = vec4(wi, wi, wi, 1.0);\n\tnormal = vec3(0.0, 0.0, 0.0);\n}\n\nvoid texture_image(vec3 vec, sampler2D ima, out float value, out vec4 color, out vec3 normal)\n{\n\tcolor = texture2D(ima, (vec.xy + vec2(1.0, 1.0))*0.5);\n\tvalue = color.a;\n\n\tnormal.x = 2.0*(color.r - 0.5);\n\tnormal.y = 2.0*(0.5 - color.g);\n\tnormal.z = 2.0*(color.b - 0.5);\n}\n\n/************* MTEX *****************/\n\nvoid texco_orco(vec3 attorco, out vec3 orco)\n{\n\torco = attorco;\n}\n\nvoid texco_uv(vec2 attuv, out vec3 uv)\n{\n\t/* disabled for now, works together with leaving out mtex_2d_mapping\n\t   uv = vec3(attuv*2.0 - vec2(1.0, 1.0), 0.0); */\n\tuv = vec3(attuv, 0.0);\n}\n\nvoid texco_norm(vec3 normal, out vec3 outnormal)\n{\n\t/* corresponds to shi->orn, which is negated so cancels\n\t   out blender normal negation */\n\toutnormal = normalize(normal);\n}\n\nvoid texco_tangent(vec4 tangent, out vec3 outtangent)\n{\n\touttangent = normalize(tangent.xyz);\n}\n\nvoid texco_global(mat4 viewinvmat, vec3 co, out vec3 global)\n{\n\tglobal = (viewinvmat*vec4(co, 1.0)).xyz;\n}\n\nvoid texco_object(mat4 viewinvmat, mat4 obinvmat, vec3 co, out vec3 object)\n{\n\tobject = (obinvmat*(viewinvmat*vec4(co, 1.0))).xyz;\n}\n\nvoid texco_refl(vec3 vn, vec3 view, out vec3 ref)\n{\n\tref = view - 2.0*dot(vn, view)*vn;\n}\n\nvoid shade_norm(vec3 normal, out vec3 outnormal)\n{\n\t/* blender render normal is negated */\n\toutnormal = -normalize(normal);\n}\n\nvoid mtex_rgb_blend(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol = fact*texcol + facm*outcol;\n}\n\nvoid mtex_rgb_mul(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol = (facm + fact*texcol)*outcol;\n}\n\nvoid mtex_rgb_screen(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol = vec3(1.0) - (vec3(facm) + fact*(vec3(1.0) - texcol))*(vec3(1.0) - outcol);\n}\n\nvoid mtex_rgb_overlay(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tif(outcol.r < 0.5)\n\t\tincol.r = outcol.r*(facm + 2.0*fact*texcol.r);\n\telse\n\t\tincol.r = 1.0 - (facm + 2.0*fact*(1.0 - texcol.r))*(1.0 - outcol.r);\n\n\tif(outcol.g < 0.5)\n\t\tincol.g = outcol.g*(facm + 2.0*fact*texcol.g);\n\telse\n\t\tincol.g = 1.0 - (facm + 2.0*fact*(1.0 - texcol.g))*(1.0 - outcol.g);\n\n\tif(outcol.b < 0.5)\n\t\tincol.b = outcol.b*(facm + 2.0*fact*texcol.b);\n\telse\n\t\tincol.b = 1.0 - (facm + 2.0*fact*(1.0 - texcol.b))*(1.0 - outcol.b);\n}\n\nvoid mtex_rgb_sub(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tincol = -fact*facg*texcol + outcol;\n}\n\nvoid mtex_rgb_add(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tincol = fact*facg*texcol + outcol;\n}\n\nvoid mtex_rgb_div(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tif(texcol.r != 0.0) incol.r = facm*outcol.r + fact*outcol.r/texcol.r;\n\tif(texcol.g != 0.0) incol.g = facm*outcol.g + fact*outcol.g/texcol.g;\n\tif(texcol.b != 0.0) incol.b = facm*outcol.b + fact*outcol.b/texcol.b;\n}\n\nvoid mtex_rgb_diff(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol = facm*outcol + fact*abs(texcol - outcol);\n}\n\nvoid mtex_rgb_dark(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm, col;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tincol.r = min(outcol.r, texcol.r) * fact + outcol.r * facm;\n\tincol.g = min(outcol.g, texcol.g) * fact + outcol.g * facm;\n\tincol.b = min(outcol.b, texcol.b) * fact + outcol.b * facm;\n}\n\nvoid mtex_rgb_light(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm, col;\n\n\tfact *= facg;\n\n\tcol = fact*texcol.r;\n\tif(col > outcol.r) incol.r = col; else incol.r = outcol.r;\n\tcol = fact*texcol.g;\n\tif(col > outcol.g) incol.g = col; else incol.g = outcol.g;\n\tcol = fact*texcol.b;\n\tif(col > outcol.b) incol.b = col; else incol.b = outcol.b;\n}\n\nvoid mtex_rgb_hue(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_hue(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_sat(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_sat(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_val(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_val(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_color(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tvec4 col;\n\n\tmix_color(fact*facg, vec4(outcol, 1.0), vec4(texcol, 1.0), col);\n\tincol.rgb = col.rgb;\n}\n\nvoid mtex_rgb_soft(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfloat facm;\n\n\tfact *= facg;\n\tfacm = 1.0-fact;\n\n\tvec3 one = vec3(1.0);\n\tvec3 scr = one - (one - texcol)*(one - outcol);\n\tincol = facm*outcol + fact*((one - texcol)*outcol*texcol + outcol*scr);\n}\n\nvoid mtex_rgb_linear(vec3 outcol, vec3 texcol, float fact, float facg, out vec3 incol)\n{\n\tfact *= facg;\n\n\tif(texcol.r > 0.5)\n\t\tincol.r = outcol.r + fact*(2.0*(texcol.r - 0.5));\n\telse\n\t\tincol.r = outcol.r + fact*(2.0*(texcol.r) - 1.0);\n\n\tif(texcol.g > 0.5)\n\t\tincol.g = outcol.g + fact*(2.0*(texcol.g - 0.5));\n\telse\n\t\tincol.g = outcol.g + fact*(2.0*(texcol.g) - 1.0);\n\n\tif(texcol.b > 0.5)\n\t\tincol.b = outcol.b + fact*(2.0*(texcol.b - 0.5));\n\telse\n\t\tincol.b = outcol.b + fact*(2.0*(texcol.b) - 1.0);\n}\n\nvoid mtex_value_vars(inout float fact, float facg, out float facm)\n{\n\tfact *= abs(facg);\n\tfacm = 1.0-fact;\n\n\tif(facg < 0.0) {\n\t\tfloat tmp = fact;\n\t\tfact = facm;\n\t\tfacm = tmp;\n\t}\n}\n\nvoid mtex_value_blend(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = fact*texcol + facm*outcol;\n}\n\nvoid mtex_value_mul(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfacm = 1.0 - facg;\n\tincol = (facm + fact*texcol)*outcol;\n}\n\nvoid mtex_value_screen(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfacm = 1.0 - facg;\n\tincol = 1.0 - (facm + fact*(1.0 - texcol))*(1.0 - outcol);\n}\n\nvoid mtex_value_sub(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfact = -fact;\n\tincol = fact*texcol + outcol;\n}\n\nvoid mtex_value_add(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfact = fact;\n\tincol = fact*texcol + outcol;\n}\n\nvoid mtex_value_div(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tif(texcol != 0.0)\n\t\tincol = facm*outcol + fact*outcol/texcol;\n\telse\n\t\tincol = 0.0;\n}\n\nvoid mtex_value_diff(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = facm*outcol + fact*abs(texcol - outcol);\n}\n\nvoid mtex_value_dark(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tincol = facm*outcol + fact*min(outcol, texcol);\n}\n\nvoid mtex_value_light(float outcol, float texcol, float fact, float facg, out float incol)\n{\n\tfloat facm;\n\tmtex_value_vars(fact, facg, facm);\n\n\tfloat col = fact*texcol;\n\tif(col > outcol) incol = col; else incol = outcol;\n}\n\nvoid mtex_value_clamp_positive(float fac, out float outfac)\n{\n\toutfac = max(fac, 0.0);\n}\n\nvoid mtex_value_clamp(float fac, out float outfac)\n{\n\toutfac = clamp(fac, 0.0, 1.0);\n}\n\nvoid mtex_har_divide(float har, out float outhar)\n{\n\touthar = har/128.0;\n}\n\nvoid mtex_har_multiply_clamp(float har, out float outhar)\n{\n\thar *= 128.0;\n\n\tif(har < 1.0) outhar = 1.0;\n\telse if(har > 511.0) outhar = 511.0;\n\telse outhar = har;\n}\n\nvoid mtex_alpha_from_col(vec4 col, out float alpha)\n{\n\talpha = col.a;\n}\n\nvoid mtex_alpha_to_col(vec4 col, float alpha, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, alpha);\n}\n\nvoid mtex_alpha_multiply_value(vec4 col, float value, out vec4 outcol)\n{\n    outcol = vec4(col.rgb, col.a * value);\n}\n\nvoid mtex_rgbtoint(vec4 rgb, out float intensity)\n{\n\tintensity = dot(vec3(0.35, 0.45, 0.2), rgb.rgb);\n}\n\nvoid mtex_value_invert(float invalue, out float outvalue)\n{\n\toutvalue = 1.0 - invalue;\n}\n\nvoid mtex_rgb_invert(vec4 inrgb, out vec4 outrgb)\n{\n\toutrgb = vec4(vec3(1.0) - inrgb.rgb, inrgb.a);\n}\n\nvoid mtex_value_stencil(float stencil, float intensity, out float outstencil, out float outintensity)\n{\n\tfloat fact = intensity;\n\toutintensity = intensity*stencil;\n\toutstencil = stencil*fact;\n}\n\nvoid mtex_rgb_stencil(float stencil, vec4 rgb, out float outstencil, out vec4 outrgb)\n{\n\tfloat fact = rgb.a;\n\toutrgb = vec4(rgb.rgb, rgb.a*stencil);\n\toutstencil = stencil*fact;\n}\n\nvoid mtex_mapping_ofs(vec3 texco, vec3 ofs, out vec3 outtexco)\n{\n\touttexco = texco + ofs;\n}\n\nvoid mtex_mapping_size(vec3 texco, vec3 size, out vec3 outtexco)\n{\n\touttexco = size*texco;\n}\n\nvoid mtex_2d_mapping(vec3 vec, out vec3 outvec)\n{\n\toutvec = vec3(vec.xy*0.5 + vec2(0.5), vec.z);\n}\n\nvec3 mtex_2d_mapping(vec3 vec)\n{\n\treturn vec3(vec.xy*0.5 + vec2(0.5), vec.z);\n}\n\nvoid mtex_cube_map(vec3 co, samplerCube ima, out float value, out vec4 color)\n{\n\tcolor = textureCube(ima, co);\n\tvalue = 1.0;\n}\n\nvoid mtex_cube_map_refl(samplerCube ima, vec3 vp, vec3 vn, mat4 viewmatrixinverse, mat4 viewmatrix, out float value, out vec4 color)\n{\n\tvec3 viewdirection = vec3(viewmatrixinverse * vec4(vp, 0.0));\n\tvec3 normaldirection = normalize(vec3(vec4(vn, 0.0) * viewmatrix));\n\tvec3 reflecteddirection = reflect(viewdirection, normaldirection);\n\tcolor = textureCube(ima, reflecteddirection);\n\tvalue = 1.0;\n}\n\nvoid mtex_image(vec3 texco, sampler2D ima, out float value, out vec4 color)\n{\n\tcolor = texture2D(ima, texco.xy);\n\tvalue = 1.0;\n}\n\nvoid mtex_normal(vec3 texco, sampler2D ima, out vec3 normal)\n{\n\t// The invert of the red channel is to make\n\t// the normal map compliant with the outside world.\n\t// It needs to be done because in Blender\n\t// the normal used points inward.\n\t// Should this ever change this negate must be removed.\n\tvec4 color = texture2D(ima, texco.xy);\n\tnormal = 2.0*(vec3(-color.r, color.g, color.b) - vec3(-0.5, 0.5, 0.5));\n}\n\nvoid mtex_bump_normals_init( vec3 vN, out vec3 vNorg, out vec3 vNacc, out float fPrevMagnitude )\n{\n\tvNorg = vN;\n\tvNacc = vN;\n\tfPrevMagnitude = 1.0;\n}\n\n/** helper method to extract the upper left 3x3 matrix from a 4x4 matrix */\nmat3 to_mat3(mat4 m4)\n{\n\tmat3 m3;\n\tm3[0] = m4[0].xyz;\n\tm3[1] = m4[1].xyz;\n\tm3[2] = m4[2].xyz;\n\treturn m3;\n}\n\nvoid mtex_bump_init_objspace( vec3 surf_pos, vec3 surf_norm,\n\t\t\t\t\t\t\t  mat4 mView, mat4 mViewInv, mat4 mObj, mat4 mObjInv, \n\t\t\t\t\t\t\t  float fPrevMagnitude_in, vec3 vNacc_in,\n\t\t\t\t\t\t\t  out float fPrevMagnitude_out, out vec3 vNacc_out, \n\t\t\t\t\t\t\t  out vec3 vR1, out vec3 vR2, out float fDet ) \n{\n\tmat3 obj2view = to_mat3(mat4(1));\n\tmat3 view2obj = to_mat3(mat4(1));\n\t\n\tvec3 vSigmaS = view2obj * dFdx( surf_pos );\n\tvec3 vSigmaT = view2obj * dFdy( surf_pos );\n\tvec3 vN = normalize( surf_norm * obj2view );\n\n\tvR1 = cross( vSigmaT, vN );\n\tvR2 = cross( vN, vSigmaS ) ;\n\tfDet = dot ( vSigmaS, vR1 );\n\t\n\t/* pretransform vNacc (in mtex_bump_apply) using the inverse transposed */\n\tvR1 = vR1 * view2obj;\n\tvR2 = vR2 * view2obj;\n\tvN = vN * view2obj;\n\t\n\tfloat fMagnitude = abs(fDet) * length(vN);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_init_texturespace( vec3 surf_pos, vec3 surf_norm, \n\t\t\t\t\t\t\t\t  float fPrevMagnitude_in, vec3 vNacc_in,\n\t\t\t\t\t\t\t\t  out float fPrevMagnitude_out, out vec3 vNacc_out, \n\t\t\t\t\t\t\t\t  out vec3 vR1, out vec3 vR2, out float fDet ) \n{\n\tvec3 vSigmaS = dFdx( surf_pos );\n\tvec3 vSigmaT = dFdy( surf_pos );\n\tvec3 vN = surf_norm; /* normalized interpolated vertex normal */\n\t\n\tvR1 = normalize( cross( vSigmaT, vN ) );\n\tvR2 = normalize( cross( vN, vSigmaS ) );\n\tfDet = sign( dot(vSigmaS, vR1) );\n\t\n\tfloat fMagnitude = abs(fDet);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_init_viewspace( vec3 surf_pos, vec3 surf_norm, \n\t\t\t\t\t\t\t   float fPrevMagnitude_in, vec3 vNacc_in,\n\t\t\t\t\t\t\t   out float fPrevMagnitude_out, out vec3 vNacc_out, \n\t\t\t\t\t\t\t   out vec3 vR1, out vec3 vR2, out float fDet ) \n{\n\tvec3 vSigmaS = dFdx( surf_pos );\n\tvec3 vSigmaT = dFdy( surf_pos );\n\tvec3 vN = surf_norm; /* normalized interpolated vertex normal */\n\t\n\tvR1 = cross( vSigmaT, vN );\n\tvR2 = cross( vN, vSigmaS ) ;\n\tfDet = dot ( vSigmaS, vR1 );\n\t\n\tfloat fMagnitude = abs(fDet);\n\tvNacc_out = vNacc_in * (fMagnitude / fPrevMagnitude_in);\n\tfPrevMagnitude_out = fMagnitude;\n}\n\nvoid mtex_bump_tap3( vec3 texco, sampler2D ima, float hScale, \n                     out float dBs, out float dBt )\n{\n\tvec2 STll = texco.xy;\n\tvec2 STlr = texco.xy + dFdx(texco.xy) ;\n\tvec2 STul = texco.xy + dFdy(texco.xy) ;\n\t\n\tfloat Hll,Hlr,Hul;\n\trgbtobw( texture2D(ima, STll), Hll );\n\trgbtobw( texture2D(ima, STlr), Hlr );\n\trgbtobw( texture2D(ima, STul), Hul );\n\t\n\tdBs = hScale * (Hlr - Hll);\n\tdBt = hScale * (Hul - Hll);\n}\n\n#ifdef BUMP_BICUBIC\n\nvoid mtex_bump_bicubic( vec3 texco, sampler2D ima, float hScale, \n                     out float dBs, out float dBt ) \n{\n\tfloat Hl;\n\tfloat Hr;\n\tfloat Hd;\n\tfloat Hu;\n\t\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n \n\tvec2 STl = texco.xy - 0.5 * TexDx ;\n\tvec2 STr = texco.xy + 0.5 * TexDx ;\n\tvec2 STd = texco.xy - 0.5 * TexDy ;\n\tvec2 STu = texco.xy + 0.5 * TexDy ;\n\t\n\trgbtobw(texture2D(ima, STl), Hl);\n\trgbtobw(texture2D(ima, STr), Hr);\n\trgbtobw(texture2D(ima, STd), Hd);\n\trgbtobw(texture2D(ima, STu), Hu);\n\t\n\tvec2 dHdxy = vec2(Hr - Hl, Hu - Hd);\n\tfloat fBlend = clamp(1.0-textureQueryLOD(ima, texco.xy).x, 0.0, 1.0);\n\tif(fBlend!=0.0)\n\t{\n\t\t// the derivative of the bicubic sampling of level 0\n\t\tivec2 vDim;\n\t\tvDim = textureSize(ima, 0);\n\n\t\t// taking the fract part of the texture coordinate is a hardcoded wrap mode.\n\t\t// this is acceptable as textures use wrap mode exclusively in 3D view elsewhere in blender. \n\t\t// this is done so that we can still get a valid texel with uvs outside the 0,1 range\n\t\t// by texelFetch below, as coordinates are clamped when using this function.\n\t\tvec2 fTexLoc = vDim*fract(texco.xy) - vec2(0.5, 0.5);\n\t\tivec2 iTexLoc = ivec2(floor(fTexLoc));\n\t\tvec2 t = clamp(fTexLoc - iTexLoc, 0.0, 1.0);\t\t// sat just to be pedantic\n\n/*******************************************************************************************\n * This block will replace the one below when one channel textures are properly supported. *\n *******************************************************************************************\n\t\tvec4 vSamplesUL = textureGather(ima, (iTexLoc+ivec2(-1,-1) + vec2(0.5,0.5))/vDim );\n\t\tvec4 vSamplesUR = textureGather(ima, (iTexLoc+ivec2(1,-1) + vec2(0.5,0.5))/vDim );\n\t\tvec4 vSamplesLL = textureGather(ima, (iTexLoc+ivec2(-1,1) + vec2(0.5,0.5))/vDim );\n\t\tvec4 vSamplesLR = textureGather(ima, (iTexLoc+ivec2(1,1) + vec2(0.5,0.5))/vDim );\n\n\t\tmat4 H = mat4(vSamplesUL.w, vSamplesUL.x, vSamplesLL.w, vSamplesLL.x,\n\t\t\t\t\tvSamplesUL.z, vSamplesUL.y, vSamplesLL.z, vSamplesLL.y,\n\t\t\t\t\tvSamplesUR.w, vSamplesUR.x, vSamplesLR.w, vSamplesLR.x,\n\t\t\t\t\tvSamplesUR.z, vSamplesUR.y, vSamplesLR.z, vSamplesLR.y);\n*/\t\n\t\tivec2 iTexLocMod = iTexLoc + ivec2(-1, -1);\n\n\t\tmat4 H;\n\t\t\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tfor(int j = 0; j < 4; j++) {\n\t\t\t\tivec2 iTexTmp = iTexLocMod + ivec2(i,j);\n\t\t\t\t\n\t\t\t\t// wrap texture coordinates manually for texelFetch to work on uvs oitside the 0,1 range.\n\t\t\t\t// this is guaranteed to work since we take the fractional part of the uv above.\n\t\t\t\tiTexTmp.x = (iTexTmp.x < 0)? iTexTmp.x + vDim.x : ((iTexTmp.x >= vDim.x)? iTexTmp.x - vDim.x : iTexTmp.x);\n\t\t\t\tiTexTmp.y = (iTexTmp.y < 0)? iTexTmp.y + vDim.y : ((iTexTmp.y >= vDim.y)? iTexTmp.y - vDim.y : iTexTmp.y);\n\n\t\t\t\trgbtobw(texelFetch(ima, iTexTmp, 0), H[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfloat x = t.x, y = t.y;\n\t\tfloat x2 = x * x, x3 = x2 * x, y2 = y * y, y3 = y2 * y;\n\n\t\tvec4 X = vec4(-0.5*(x3+x)+x2,\t\t1.5*x3-2.5*x2+1,\t-1.5*x3+2*x2+0.5*x,\t\t0.5*(x3-x2));\n\t\tvec4 Y = vec4(-0.5*(y3+y)+y2,\t\t1.5*y3-2.5*y2+1,\t-1.5*y3+2*y2+0.5*y,\t\t0.5*(y3-y2));\n\t\tvec4 dX = vec4(-1.5*x2+2*x-0.5,\t\t4.5*x2-5*x,\t\t\t-4.5*x2+4*x+0.5,\t\t1.5*x2-x);\n\t\tvec4 dY = vec4(-1.5*y2+2*y-0.5,\t\t4.5*y2-5*y,\t\t\t-4.5*y2+4*y+0.5,\t\t1.5*y2-y);\n\t\n\t\t// complete derivative in normalized coordinates (mul by vDim)\n\t\tvec2 dHdST = vDim * vec2(dot(Y, H * dX), dot(dY, H * X));\n\n\t\t// transform derivative to screen-space\n\t\tvec2 dHdxy_bicubic = vec2( dHdST.x * TexDx.x + dHdST.y * TexDx.y,\n\t\t\t\t\t\t\t\t   dHdST.x * TexDy.x + dHdST.y * TexDy.y );\n\n\t\t// blend between the two\n\t\tdHdxy = dHdxy*(1-fBlend) + dHdxy_bicubic*fBlend;\n\t}\n\n\tdBs = hScale * dHdxy.x;\n\tdBt = hScale * dHdxy.y;\n}\n\n#endif\n\nvoid mtex_bump_tap5( vec3 texco, sampler2D ima, float hScale, \n                     out float dBs, out float dBt ) \n{\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\tvec2 STc = texco.xy;\n\tvec2 STl = texco.xy - 0.5 * TexDx ;\n\tvec2 STr = texco.xy + 0.5 * TexDx ;\n\tvec2 STd = texco.xy - 0.5 * TexDy ;\n\tvec2 STu = texco.xy + 0.5 * TexDy ;\n\t\n\tfloat Hc,Hl,Hr,Hd,Hu;\n\trgbtobw( texture2D(ima, STc), Hc );\n\trgbtobw( texture2D(ima, STl), Hl );\n\trgbtobw( texture2D(ima, STr), Hr );\n\trgbtobw( texture2D(ima, STd), Hd );\n\trgbtobw( texture2D(ima, STu), Hu );\n\t\n\tdBs = hScale * (Hr - Hl);\n\tdBt = hScale * (Hu - Hd);\n}\n\nvoid mtex_bump_deriv( vec3 texco, sampler2D ima, float ima_x, float ima_y, float hScale, \n                     out float dBs, out float dBt ) \n{\n\tfloat s = 1.0;\t\t// negate this if flipped texture coordinate\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\t\n\t// this variant using a derivative map is described here\n\t// http://mmikkelsen3d.blogspot.com/2011/07/derivative-maps.html\n\tvec2 dim = vec2(ima_x, ima_y);\n\tvec2 dBduv = hScale*dim*(2.0*texture2D(ima, texco.xy).xy-1.0);\n\t\n\tdBs = dBduv.x*TexDx.x + s*dBduv.y*TexDx.y;\n\tdBt = dBduv.x*TexDy.x + s*dBduv.y*TexDy.y;\n}\n\nvoid mtex_bump_apply( float fDet, float dBs, float dBt, vec3 vR1, vec3 vR2, vec3 vNacc_in,\n\t\t\t\t\t  out vec3 vNacc_out, out vec3 perturbed_norm ) \n{\n\tvec3 vSurfGrad = sign(fDet) * ( dBs * vR1 + dBt * vR2 );\n\t\n\tvNacc_out = vNacc_in - vSurfGrad;\n\tperturbed_norm = normalize( vNacc_out );\n}\n\nvoid mtex_bump_apply_texspace( float fDet, float dBs, float dBt, vec3 vR1, vec3 vR2,\n                               sampler2D ima, vec3 texco, float ima_x, float ima_y, vec3 vNacc_in,\n\t\t\t\t\t\t\t   out vec3 vNacc_out, out vec3 perturbed_norm ) \n{\n\tvec2 TexDx = dFdx(texco.xy);\n\tvec2 TexDy = dFdy(texco.xy);\n\n\tvec3 vSurfGrad = sign(fDet) * ( \n\t            dBs / length( vec2(ima_x*TexDx.x, ima_y*TexDx.y) ) * vR1 + \n\t            dBt / length( vec2(ima_x*TexDy.x, ima_y*TexDy.y) ) * vR2 );\n\t\t\t\t\n\tvNacc_out = vNacc_in - vSurfGrad;\n\tperturbed_norm = normalize( vNacc_out );\n}\n\nvoid mtex_negate_texnormal(vec3 normal, out vec3 outnormal)\n{\n\toutnormal = vec3(-normal.x, -normal.y, normal.z);\n}\n\nvoid mtex_nspace_tangent(vec4 tangent, vec3 normal, vec3 texnormal, out vec3 outnormal)\n{\n\tvec3 B = tangent.w * cross(normal, tangent.xyz);\n\n\toutnormal = texnormal.x*tangent.xyz + texnormal.y*B + texnormal.z*normal;\n\toutnormal = normalize(outnormal);\n}\n\nvoid mtex_nspace_world(mat4 viewmat, vec3 texnormal, out vec3 outnormal)\n{\n\toutnormal = normalize((viewmat*vec4(texnormal, 0.0)).xyz);\n}\n\nvoid mtex_nspace_object(vec3 texnormal, out vec3 outnormal)\n{\n\toutnormal = normalize(mat3(1) * texnormal);\n}\n\nvoid mtex_blend_normal(float norfac, vec3 normal, vec3 newnormal, out vec3 outnormal)\n{\n\toutnormal = (1.0 - norfac)*normal + norfac*newnormal;\n\toutnormal = normalize(outnormal);\n}\n\n/******* MATERIAL *********/\n\nvoid lamp_visibility_sun_hemi(vec3 lampvec, out vec3 lv, out float dist, out float visifac)\n{\n\tlv = lampvec;\n\tdist = 1.0;\n\tvisifac = 1.0;\n}\n\nvoid lamp_visibility_other(vec3 co, vec3 lampco, out vec3 lv, out float dist, out float visifac)\n{\n\tlv = co - lampco;\n\tdist = length(lv);\n\tlv = normalize(lv);\n\tvisifac = 1.0;\n}\n\nvoid lamp_falloff_invlinear(float lampdist, float dist, out float visifac)\n{\n\tvisifac = lampdist/(lampdist + dist);\n}\n\nvoid lamp_falloff_invsquare(float lampdist, float dist, out float visifac)\n{\n\tvisifac = lampdist/(lampdist + dist*dist);\n}\n\nvoid lamp_falloff_sliders(float lampdist, float ld1, float ld2, float dist, out float visifac)\n{\n\tfloat lampdistkw = lampdist*lampdist;\n\n\tvisifac = lampdist/(lampdist + ld1*dist);\n\tvisifac *= lampdistkw/(lampdistkw + ld2*dist*dist);\n}\n\nvoid lamp_falloff_curve(float lampdist, sampler2D curvemap, float dist, out float visifac)\n{\n\tvisifac = texture2D(curvemap, vec2(dist/lampdist, 0.0)).x;\n}\n\nvoid lamp_visibility_sphere(float lampdist, float dist, float visifac, out float outvisifac)\n{\n\tfloat t= lampdist - dist;\n\n\toutvisifac= visifac*max(t, 0.0)/lampdist;\n}\n\nvoid lamp_visibility_spot_square(vec3 lampvec, mat4 lampimat, vec2 scale, vec3 lv, out float inpr)\n{\n\tif(dot(lv, lampvec) > 0.0) {\n\t\tvec3 lvrot = (lampimat*vec4(lv, 0.0)).xyz;\n\t\t/* without clever non-uniform scale, we could do: */\n\t\t// float x = max(abs(lvrot.x / lvrot.z), abs(lvrot.y / lvrot.z));\n\t\tfloat x = max(abs((lvrot.x / scale.x) / lvrot.z), abs((lvrot.y / scale.y) / lvrot.z));\n\n\t\tinpr = 1.0/sqrt(1.0 + x*x);\n\t}\n\telse\n\t\tinpr = 0.0;\n}\n\nvoid lamp_visibility_spot_circle(vec3 lampvec, mat4 lampimat, vec2 scale, vec3 lv, out float inpr)\n{\n\t/* without clever non-uniform scale, we could do: */\n\t// inpr = dot(lv, lampvec);\n\tif (dot(lv, lampvec) > 0.0) {\n\t\tvec3 lvrot = (lampimat * vec4(lv, 0.0)).xyz;\n\t\tfloat x = abs(lvrot.x / lvrot.z);\n\t\tfloat y = abs(lvrot.y / lvrot.z);\n\n\t\tfloat ellipse = abs((x * x) / (scale.x * scale.x) + (y * y) / (scale.y * scale.y));\n\n\t\tinpr = 1.0 / sqrt(1.0 + ellipse);\n\t}\n\telse\n\t\tinpr = 0.0;\n}\n\nvoid lamp_visibility_spot(float spotsi, float spotbl, float inpr, float visifac, out float outvisifac)\n{\n\tfloat t = spotsi;\n\n\tif(inpr <= t) {\n\t\toutvisifac = 0.0;\n\t}\n\telse {\n\t\tt = inpr - t;\n\n\t\t/* soft area */\n\t\tif(spotbl != 0.0)\n\t\t\tinpr *= smoothstep(0.0, 1.0, t/spotbl);\n\n\t\toutvisifac = visifac*inpr;\n\t}\n}\n\nvoid lamp_visibility_clamp(float visifac, out float outvisifac)\n{\n\toutvisifac = (visifac < 0.001)? 0.0: visifac;\n}\n\nvoid world_paper_view(vec3 vec, out vec3 outvec)\n{\n\tvec3 nvec = normalize(vec);\n\toutvec = (0.0 == 0.0) ? vec3(nvec.x, 0.0, nvec.y) : vec3(0.0, 0.0, -1.0);\n}\n\nvoid world_zen_mapping(vec3 view, float zenup, float zendown, out float zenfac)\n{\n\tif (view.z >= 0.0)\n\t\tzenfac = zenup;\n\telse\n\t\tzenfac = zendown;\n}\n\nvoid world_blend_paper_real(vec3 vec, out float blend)\n{\n\tblend = abs(vec.y);\n}\n\nvoid world_blend_paper(vec3 vec, out float blend)\n{\n\tblend = (vec.y + 1.0) * 0.5;\n}\n\nvoid world_blend_real(vec3 vec, out float blend)\n{\n\tblend = abs(normalize(vec).z);\n}\n\nvoid world_blend(vec3 vec, out float blend)\n{\n\tblend = (normalize(vec).z + 1.0) * 0.5;\n}\n\nvoid shade_view(vec3 co, out vec3 view)\n{\n\t/* handle perspective/orthographic */\n\tview = (0.0 == 0.0)? normalize(co): vec3(0.0, 0.0, -1.0);\n}\n\nvoid shade_tangent_v(vec3 lv, vec3 tang, out vec3 vn)\n{\n\tvec3 c = cross(lv, tang);\n\tvec3 vnor = cross(c, tang);\n\n\tvn = -normalize(vnor);\n}\n\nvoid shade_inp(vec3 vn, vec3 lv, out float inp)\n{\n\tinp = dot(vn, lv);\n}\n\nvoid shade_is_no_diffuse(out float is)\n{\n\tis = 0.0;\n}\n\nvoid shade_is_hemi(float inp, out float is)\n{\n\tis = 0.5*inp + 0.5;\n}\n\nfloat area_lamp_energy(mat4 area, vec3 co, vec3 vn)\n{\n\tvec3 vec[4], c[4];\n\tfloat rad[4];float fac;\n\t\n\tvec[0] = normalize(co - area[0].xyz);\n\tvec[1] = normalize(co - area[1].xyz);\n\tvec[2] = normalize(co - area[2].xyz);\n\tvec[3] = normalize(co - area[3].xyz);\n\n\tc[0] = normalize(cross(vec[0], vec[1]));\n\tc[1] = normalize(cross(vec[1], vec[2]));\n\tc[2] = normalize(cross(vec[2], vec[3]));\n\tc[3] = normalize(cross(vec[3], vec[0]));\n\n\trad[0] = acos(dot(vec[0], vec[1]));\n\trad[1] = acos(dot(vec[1], vec[2]));\n\trad[2] = acos(dot(vec[2], vec[3]));\n\trad[3] = acos(dot(vec[3], vec[0]));\n\n\tfac=  rad[0]*dot(vn, c[0]);\n\tfac+= rad[1]*dot(vn, c[1]);\n\tfac+= rad[2]*dot(vn, c[2]);\n\tfac+= rad[3]*dot(vn, c[3]);\n\n\treturn max(fac, 0.0);\n}\n\nvoid shade_inp_area(vec3 position, vec3 lampco, vec3 lampvec, vec3 vn, mat4 area, float areasize, float k, out float inp)\n{\n\tvec3 co = position;\n\tvec3 vec = co - lampco;\n\n\tif(dot(vec, lampvec) < 0.0) {\n\t\tinp = 0.0;\n\t}\n\telse {\n\t\tfloat intens = area_lamp_energy(area, co, vn);\n\n\t\tinp = pow(intens*areasize, k);\n\t}\n}\n\nvoid shade_diffuse_oren_nayer(float nl, vec3 n, vec3 l, vec3 v, float rough, out float is)\n{\n\tvec3 h = normalize(v + l);\n\tfloat nh = max(dot(n, h), 0.0);\n\tfloat nv = max(dot(n, v), 0.0);\n\tfloat realnl = dot(n, l);\n\n\tif(realnl < 0.0) {\n\t\tis = 0.0;\n\t}\n\telse if(nl < 0.0) {\n\t\tis = 0.0;\n\t}\n\telse {\n\t\tfloat vh = max(dot(v, h), 0.0);\n\t\tfloat Lit_A = acos(realnl);\n\t\tfloat View_A = acos(nv);\n\n\t\tvec3 Lit_B = normalize(l - realnl*n);\n\t\tvec3 View_B = normalize(v - nv*n);\n\n\t\tfloat t = max(dot(Lit_B, View_B), 0.0);\n\n\t\tfloat a, b;\n\n\t\tif(Lit_A > View_A) {\n\t\t\ta = Lit_A;\n\t\t\tb = View_A;\n\t\t}\n\t\telse {\n\t\t\ta = View_A;\n\t\t\tb = Lit_A;\n\t\t}\n\n\t\tfloat A = 1.0 - (0.5*((rough*rough)/((rough*rough) + 0.33)));\n\t\tfloat B = 0.45*((rough*rough)/((rough*rough) + 0.09));\n\n\t\tb *= 0.95;\n\t\tis = nl*(A + (B * t * sin(a) * tan(b)));\n\t}\n}\n\nvoid shade_diffuse_toon(vec3 n, vec3 l, vec3 v, float size, float tsmooth, out float is)\n{\n\tfloat rslt = dot(n, l);\n\tfloat ang = acos(rslt);\n\n\tif(ang < size) is = 1.0;\n\telse if(ang > (size + tsmooth) || tsmooth == 0.0) is = 0.0;\n\telse is = 1.0 - ((ang - size)/tsmooth);\n}\n\nvoid shade_diffuse_minnaert(float nl, vec3 n, vec3 v, float darkness, out float is)\n{\n\tif(nl <= 0.0) {\n\t\tis = 0.0;\n\t}\n\telse {\n\t\tfloat nv = max(dot(n, v), 0.0);\n\n\t\tif(darkness <= 1.0)\n\t\t\tis = nl*pow(max(nv*nl, 0.1), darkness - 1.0);\n\t\telse\n\t\t\tis = nl*pow(1.0001 - nv, darkness - 1.0);\n\t}\n}\n\nfloat fresnel_fac(vec3 view, vec3 vn, float grad, float fac)\n{\n\tfloat t1, t2;\n\tfloat ffac;\n\n\tif(fac==0.0) {\n\t\tffac = 1.0;\n\t}\n\telse {\n\t\tt1= dot(view, vn);\n\t\tif(t1>0.0)  t2= 1.0+t1;\n\t\telse t2= 1.0-t1;\n\n\t\tt2= grad + (1.0-grad)*pow(t2, fac);\n\n\t\tif(t2<0.0) ffac = 0.0;\n\t\telse if(t2>1.0) ffac = 1.0;\n\t\telse ffac = t2;\n\t}\n\n\treturn ffac;\n}\n\nvoid shade_diffuse_fresnel(vec3 vn, vec3 lv, vec3 view, float fac_i, float fac, out float is)\n{\n\tis = fresnel_fac(lv, vn, fac_i, fac);\n}\n\nvoid shade_cubic(float is, out float outis)\n{\n\tif(is>0.0 && is<1.0)\n\t\toutis= smoothstep(0.0, 1.0, is);\n\telse\n\t\toutis= is;\n}\n\nvoid shade_visifac(float i, float visifac, float refl, out float outi)\n{\n\t/*if(i > 0.0)*/\n\t\touti = max(i*visifac*refl, 0.0);\n\t/*else\n\t\touti = i;*/\n}\n\nvoid shade_tangent_v_spec(vec3 tang, out vec3 vn)\n{\n\tvn = tang;\n}\n\nvoid shade_add_to_diffuse(float i, vec3 lampcol, vec3 col, out vec3 outcol)\n{\n\tif(i > 0.0)\n\t\toutcol = i*lampcol*col;\n\telse\n\t\toutcol = vec3(0.0, 0.0, 0.0);\n}\n\nvoid shade_hemi_spec(vec3 vn, vec3 lv, vec3 view, float spec, float hard, float visifac, out float t)\n{\n\tlv += view;\n\tlv = normalize(lv);\n\n\tt = dot(vn, lv);\n\tt = 0.5*t + 0.5;\n\n\tt = visifac*spec*pow(t, hard);\n}\n\nvoid shade_phong_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat rslt = max(dot(h, n), 0.0);\n\n\tspecfac = pow(rslt, hard);\n}\n\nvoid shade_cooktorr_spec(vec3 n, vec3 l, vec3 v, float hard, out float specfac)\n{\n\tvec3 h = normalize(v + l);\n\tfloat nh = dot(n, h);\n\n\tif(nh < 0.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse {\n\t\tfloat nv = max(dot(n, v), 0.0);\n\t\tfloat i = pow(nh, hard);\n\n\t\ti = i/(0.1+nv);\n\t\tspecfac = i;\n\t}\n}\n\nvoid shade_blinn_spec(vec3 n, vec3 l, vec3 v, float refrac, float spec_power, out float specfac)\n{\n\tif(refrac < 1.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse if(spec_power == 0.0) {\n\t\tspecfac = 0.0;\n\t}\n\telse {\n\t\tif(spec_power<100.0)\n\t\t\tspec_power= sqrt(1.0/spec_power);\n\t\telse\n\t\t\tspec_power= 10.0/spec_power;\n\n\t\tvec3 h = normalize(v + l);\n\t\tfloat nh = dot(n, h);\n\t\tif(nh < 0.0) {\n\t\t\tspecfac = 0.0;\n\t\t}\n\t\telse {\n\t\t\tfloat nv = max(dot(n, v), 0.01);\n\t\t\tfloat nl = dot(n, l);\n\t\t\tif(nl <= 0.01) {\n\t\t\t\tspecfac = 0.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfloat vh = max(dot(v, h), 0.01);\n\n\t\t\t\tfloat a = 1.0;\n\t\t\t\tfloat b = (2.0*nh*nv)/vh;\n\t\t\t\tfloat c = (2.0*nh*nl)/vh;\n\n\t\t\t\tfloat g = 0.0;\n\n\t\t\t\tif(a < b && a < c) g = a;\n\t\t\t\telse if(b < a && b < c) g = b;\n\t\t\t\telse if(c < a && c < b) g = c;\n\n\t\t\t\tfloat p = sqrt(((refrac * refrac)+(vh*vh)-1.0));\n\t\t\t\tfloat f = (((p-vh)*(p-vh))/((p+vh)*(p+vh)))*(1.0+((((vh*(p+vh))-1.0)*((vh*(p+vh))-1.0))/(((vh*(p-vh))+1.0)*((vh*(p-vh))+1.0))));\n\t\t\t\tfloat ang = acos(nh);\n\n\t\t\t\tspecfac = max(f*g*exp_blender((-(ang*ang)/(2.0*spec_power*spec_power))), 0.0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid shade_wardiso_spec(vec3 n, vec3 l, vec3 v, float rms, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat nh = max(dot(n, h), 0.001);\n\tfloat nv = max(dot(n, v), 0.001);\n\tfloat nl = max(dot(n, l), 0.001);\n\tfloat angle = tan(acos(nh));\n\tfloat alpha = max(rms, 0.001);\n\n\tspecfac= nl * (1.0/(4.0*M_PI*alpha*alpha))*(exp_blender(-(angle*angle)/(alpha*alpha))/(sqrt(nv*nl)));\n}\n\nvoid shade_toon_spec(vec3 n, vec3 l, vec3 v, float size, float tsmooth, out float specfac)\n{\n\tvec3 h = normalize(l + v);\n\tfloat rslt = dot(h, n);\n\tfloat ang = acos(rslt);\n\n\tif(ang < size) rslt = 1.0;\n\telse if(ang >= (size + tsmooth) || tsmooth == 0.0) rslt = 0.0;\n\telse rslt = 1.0 - ((ang - size)/tsmooth);\n\n\tspecfac = rslt;\n}\n\nvoid shade_spec_area_inp(float specfac, float inp, out float outspecfac)\n{\n\toutspecfac = specfac*inp;\n}\n\nvoid shade_spec_t(float shadfac, float spec, float visifac, float specfac, out float t)\n{\n\tt = shadfac*spec*visifac*specfac;\n}\n\nvoid shade_add_spec(float t, vec3 lampcol, vec3 speccol, out vec3 outcol)\n{\n\toutcol = t*lampcol*speccol;\n}\n\nvoid alpha_spec_correction(vec3 spec, float spectra, float alpha, out float outalpha)\n{\n\tif (spectra > 0.0) {\n\t\tfloat t = clamp(max(max(spec.r, spec.g), spec.b) * spectra, 0.0, 1.0);\n\t\toutalpha = (1.0 - t) * alpha + t;\n\t}\n\telse {\n\t\toutalpha = alpha;\n\t}\n}\n\nvoid shade_add(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1 + col2;\n}\n\nvoid shade_madd(vec4 col, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col + col1*col2;\n}\n\nvoid shade_add_clamped(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1 + max(col2, vec4(0.0, 0.0, 0.0, 0.0));\n}\n\nvoid shade_madd_clamped(vec4 col, vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col + max(col1*col2, vec4(0.0, 0.0, 0.0, 0.0));\n}\n\nvoid shade_maddf(vec4 col, float f, vec4 col1, out vec4 outcol)\n{\n\toutcol = col + f*col1;\n}\n\nvoid shade_mul(vec4 col1, vec4 col2, out vec4 outcol)\n{\n\toutcol = col1*col2;\n}\n\nvoid shade_mul_value(float fac, vec4 col, out vec4 outcol)\n{\n\toutcol = col*fac;\n}\n\nvoid shade_mul_value_v3(float fac, vec3 col, out vec3 outcol)\n{\n\toutcol = col*fac;\n}\n\nvoid shade_obcolor(vec4 col, vec4 obcol, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb*obcol.rgb, col.a);\n}\n\nvoid ramp_rgbtobw(vec3 color, out float outval)\n{\n\toutval = color.r*0.3 + color.g*0.58 + color.b*0.12;\n}\n\nvoid shade_only_shadow(float i, float shadfac, float energy, vec3 shadcol, out vec3 outshadrgb)\n{\n\toutshadrgb = i*energy*(1.0 - shadfac)*(vec3(1.0)-shadcol);\n}\n\nvoid shade_only_shadow_diffuse(vec3 shadrgb, vec3 rgb, vec4 diff, out vec4 outdiff)\n{\n\toutdiff = diff - vec4(rgb*shadrgb, 0.0);\n}\n\nvoid shade_only_shadow_specular(vec3 shadrgb, vec3 specrgb, vec4 spec, out vec4 outspec)\n{\n\toutspec = spec - vec4(specrgb*shadrgb, 0.0);\n}\n\nvoid shade_clamp_positive(vec4 col, out vec4 outcol)\n{\n\toutcol = max(col, vec4(0.0));\n}\n\nvoid test_shadowbuf(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float inp, out float result)\n{\n\tif(inp <= 0.0) {\n\t\tresult = 0.0;\n\t}\n\telse {\n\t\tvec4 co = shadowpersmat*vec4(rco, 1.0);\n\n\t\t//float bias = (1.5 - inp*inp)*shadowbias;\n\t\tco.z -= shadowbias*co.w;\n\t\t\n\t\tif (co.w > 0.0 && co.x > 0.0 && co.x/co.w < 1.0 && co.y > 0.0 && co.y/co.w < 1.0)\n\t\t\tresult = step(co.z,texture2D(shadowmap, co.xy).x);\n\t\telse\n\t\t\tresult = 1.0;\n\t}\n}\n\nvoid test_shadowbuf_vsm(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float bleedbias, float inp, out float result)\n{\n\tif(inp <= 0.0) {\n\t\tresult = 0.0;\n\t}\n\telse {\n\t\tvec4 co = shadowpersmat*vec4(rco, 1.0);\n\t\tif (co.w > 0.0 && co.x > 0.0 && co.x/co.w < 1.0 && co.y > 0.0 && co.y/co.w < 1.0) {\n\t\t\tvec2 moments = texture2DProj(shadowmap, co).rg;\n\t\t\tfloat dist = co.z/co.w;\n\t\t\tfloat p = 0.0;\n\t\t\t\n\t\t\tif(dist <= moments.x)\n\t\t\t\tp = 1.0;\n\n\t\t\tfloat variance = moments.y - (moments.x*moments.x);\n\t\t\tvariance = max(variance, shadowbias/10.0);\n\n\t\t\tfloat d = moments.x - dist;\n\t\t\tfloat p_max = variance / (variance + d*d);\n\n\t\t\t// Now reduce light-bleeding by removing the [0, x] tail and linearly rescaling (x, 1]\n\t\t\tp_max = clamp((p_max-bleedbias)/(1.0-bleedbias), 0.0, 1.0);\n\n\t\t\tresult = max(p, p_max);\n\t\t}\n\t\telse {\n\t\t\tresult = 1.0;\n\t\t}\n\t}\n}\n\nvoid shadows_only(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, vec3 shadowcolor, float inp, out vec3 result)\n{\n\tresult = vec3(1.0);\n\n\tif(inp > 0.0) {\n\t\tfloat shadfac;\n\n\t\ttest_shadowbuf(rco, shadowmap, shadowpersmat, shadowbias, inp, shadfac);\n\t\tresult -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);\n\t}\n}\n\nvoid shadows_only_vsm(vec3 rco, sampler2D shadowmap, mat4 shadowpersmat, float shadowbias, float bleedbias, vec3 shadowcolor, float inp, out vec3 result)\n{\n\tresult = vec3(1.0);\n\n\tif(inp > 0.0) {\n\t\tfloat shadfac;\n\n\t\ttest_shadowbuf_vsm(rco, shadowmap, shadowpersmat, shadowbias, bleedbias, inp, shadfac);\n\t\tresult -= (1.0 - shadfac) * (vec3(1.0) - shadowcolor);\n\t}\n}\n\nvoid shade_light_texture(vec3 rco, sampler2D cookie, mat4 shadowpersmat, out vec4 result)\n{\n\n\tvec4 co = shadowpersmat*vec4(rco, 1.0);\n\n\tresult = texture2DProj(cookie, co);\n}\n\nvoid shade_exposure_correct(vec3 col, float linfac, float logfac, out vec3 outcol)\n{\n\toutcol = linfac*(1.0 - exp(col*logfac));\n}\n\nvoid shade_mist_factor(vec3 co, float enable, float miststa, float mistdist, float misttype, float misi, out float outfac)\n{\n\tif(enable == 1.0) {\n\t\tfloat fac, zcor;\n\n\t\tzcor = (0.0 == 0.0)? length(co): -co[2];\n\t\t\n\t\tfac = clamp((zcor - miststa) / mistdist, 0.0, 1.0);\n\t\tif(misttype == 0.0) fac *= fac;\n\t\telse if(misttype == 1.0);\n\t\telse fac = sqrt(fac);\n\n\t\toutfac = 1.0 - (1.0 - fac) * (1.0 - misi);\n\t}\n\telse {\n\t\toutfac = 0.0;\n\t}\n}\n\nvoid shade_world_mix(vec3 hor, vec4 col, out vec4 outcol)\n{\n\tfloat fac = clamp(col.a, 0.0, 1.0);\n\toutcol = vec4(mix(hor, col.rgb, fac), col.a);\n}\n\nvoid shade_alpha_opaque(vec4 col, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, 1.0);\n}\n\nvoid shade_alpha_obcolor(vec4 col, vec4 obcol, out vec4 outcol)\n{\n\toutcol = vec4(col.rgb, col.a*obcol.a);\n}\n\n/*********** NEW SHADER UTILITIES **************/\n\nfloat fresnel_dielectric(vec3 Incoming, vec3 Normal, float eta)\n{\n\t/* compute fresnel reflectance without explicitly computing\n\t * the refracted direction */\n\tfloat c = abs(dot(Incoming, Normal));\n\tfloat g = eta * eta - 1.0 + c * c;\n\tfloat result;\n\n\tif(g > 0.0) {\n\t\tg = sqrt(g);\n\t\tfloat A =(g - c)/(g + c);\n\t\tfloat B =(c *(g + c)- 1.0)/(c *(g - c)+ 1.0);\n\t\tresult = 0.5 * A * A *(1.0 + B * B);\n\t}\n\telse {\n\t\tresult = 1.0;  /* TIR (no refracted component) */\n\t}\n\n\treturn result;\n}\n\nfloat hypot(float x, float y)\n{\n\treturn sqrt(x*x + y*y);\n}\n\n/*********** NEW SHADER NODES ***************/\n\n#define NUM_LIGHTS 3\n\n/* bsdfs */\n\nvoid node_bsdf_diffuse(vec4 color, float roughness, vec3 N, out vec4 result)\n{\n\t/* ambient light */\n\tvec3 L = vec3(0.2);\n\n\t/* directional lights */\n\tfor(int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 light_position = vec3(0,0,0).xyz;\n\t\tvec3 light_diffuse = vec3(0,0,0).rgb;\n\n\t\tfloat bsdf = max(dot(N, light_position), 0.0);\n\t\tL += light_diffuse*bsdf;\n\t}\n\n\tresult = vec4(L*color.rgb, 1.0);\n}\n\nvoid node_bsdf_glossy(vec4 color, float roughness, vec3 N, out vec4 result)\n{\n\t/* ambient light */\n\tvec3 L = vec3(0.2);\n\n\t/* directional lights */\n\tfor(int i = 0; i < NUM_LIGHTS; i++) {\n\t\tvec3 light_position = vec3(0,0,0).xyz;\n\t\tvec3 H = vec3(0,0,0).xyz;\n\t\tvec3 light_diffuse = vec3(0,0,0).rgb;\n\t\tvec3 light_specular = vec3(0,0,0).rgb;\n\n\t\t/* we mix in some diffuse so low roughness still shows up */\n\t\tfloat bsdf = 0.5*pow(max(dot(N, H), 0.0), 1.0/roughness);\n\t\tbsdf += 0.5*max(dot(N, light_position), 0.0);\n\t\tL += light_specular*bsdf;\n\t}\n\n\tresult = vec4(L*color.rgb, 1.0);\n}\n\nvoid node_bsdf_anisotropic(vec4 color, float roughness, float anisotropy, float rotation, vec3 N, vec3 T, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_glass(vec4 color, float roughness, float ior, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_toon(vec4 color, float size, float tsmooth, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_translucent(vec4 color, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_transparent(vec4 color, out vec4 result)\n{\n\t/* this isn't right */\n\tresult.r = color.r;\n\tresult.g = color.g;\n\tresult.b = color.b;\n\tresult.a = 0.0;\n}\n\nvoid node_bsdf_velvet(vec4 color, float sigma, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_subsurface_scattering(vec4 color, float scale, vec3 radius, float sharpen, float texture_blur, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_bsdf_hair(vec4 color, float offset, float roughnessu, float roughnessv, out vec4 result)\n{\n\tresult = color;\n}\n\nvoid node_bsdf_refraction(vec4 color, float roughness, float ior, vec3 N, out vec4 result)\n{\n\tnode_bsdf_diffuse(color, 0.0, N, result);\n}\n\nvoid node_ambient_occlusion(vec4 color, out vec4 result)\n{\n\tresult = color;\n}\n\n/* emission */\n\nvoid node_emission(vec4 color, float strength, vec3 N, out vec4 result)\n{\n\tresult = color*strength;\n}\n\n/* background */\n\nvoid background_transform_to_world(vec3 viewvec, out vec3 worldvec)\n{\n\tvec4 v = (0.0 == 0.0) ? vec4(viewvec, 1.0) : vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 co_homogenous = (mat4(1) * v);\n\n\tvec4 co = vec4(co_homogenous.xyz / co_homogenous.w, 0.0);\n\tworldvec = (mat4(1) * co).xyz;\n}\n\nvoid node_background(vec4 color, float strength, vec3 N, out vec4 result)\n{\n\tresult = color*strength;\n}\n\n/* closures */\n\nvoid node_mix_shader(float fac, vec4 shader1, vec4 shader2, out vec4 shader)\n{\n\tshader = mix(shader1, shader2, fac);\n}\n\nvoid node_add_shader(vec4 shader1, vec4 shader2, out vec4 shader)\n{\n\tshader = shader1 + shader2;\n}\n\n/* fresnel */\n\nvoid node_fresnel(float ior, vec3 N, vec3 I, out float result)\n{\n\t/* handle perspective/orthographic */\n\tvec3 I_view = (0.0 == 0.0)? normalize(I): vec3(0.0, 0.0, -1.0);\n\n\tfloat eta = max(ior, 0.00001);\n\tresult = fresnel_dielectric(I_view, N, (gl_FrontFacing)? eta: 1.0/eta);\n}\n\n/* layer_weight */\n\nvoid node_layer_weight(float blend, vec3 N, vec3 I, out float fresnel, out float facing)\n{\n\t/* fresnel */\n\tfloat eta = max(1.0 - blend, 0.00001);\n\tvec3 I_view = (0.0 == 0.0)? normalize(I): vec3(0.0, 0.0, -1.0);\n\n\tfresnel = fresnel_dielectric(I_view, N, (gl_FrontFacing)? 1.0/eta : eta );\n\n\t/* facing */\n\tfacing = abs(dot(I_view, N));\n\tif(blend != 0.5) {\n\t\tblend = clamp(blend, 0.0, 0.99999);\n\t\tblend = (blend < 0.5)? 2.0*blend: 0.5/(1.0 - blend);\n\t\tfacing = pow(facing, blend);\n\t}\n\tfacing = 1.0 - facing;\n}\n\n/* gamma */\n\nvoid node_gamma(vec4 col, float gamma, out vec4 outcol)\n{\n\toutcol = col;\n\n\tif(col.r > 0.0)\n\t\toutcol.r = compatible_pow(col.r, gamma);\n\tif(col.g > 0.0)\n\t\toutcol.g = compatible_pow(col.g, gamma);\n\tif(col.b > 0.0)\n\t\toutcol.b = compatible_pow(col.b, gamma);\n}\n\n/* geometry */\n\nvoid node_attribute(vec3 attr_uv, out vec4 outcol, out vec3 outvec, out float outf)\n{\n\toutcol = vec4(attr_uv, 1.0);\n\toutvec = attr_uv;\n\toutf = (attr_uv.x + attr_uv.y + attr_uv.z)/3.0;\n}\n\nvoid node_uvmap(vec3 attr_uv, out vec3 outvec)\n{\n\toutvec = attr_uv;\n}\n\nvoid node_geometry(vec3 I, vec3 N, mat4 toworld,\n\tout vec3 position, out vec3 normal, out vec3 tangent,\n\tout vec3 true_normal, out vec3 incoming, out vec3 parametric,\n\tout float backfacing, out float pointiness)\n{\n\tposition = (toworld*vec4(I, 1.0)).xyz;\n\tnormal = (toworld*vec4(N, 0.0)).xyz;\n\ttangent = vec3(0.0);\n\ttrue_normal = normal;\n\n\t/* handle perspective/orthographic */\n\tvec3 I_view = (0.0 == 0.0)? normalize(I): vec3(0.0, 0.0, -1.0);\n\tincoming = -(toworld*vec4(I_view, 0.0)).xyz;\n\n\tparametric = vec3(0.0);\n\tbackfacing = (gl_FrontFacing)? 0.0: 1.0;\n\tpointiness = 0.0;\n}\n\nvoid node_tex_coord(vec3 I, vec3 N, mat4 viewinvmat, mat4 obinvmat, vec4 camerafac,\n\tvec3 attr_orco, vec3 attr_uv,\n\tout vec3 generated, out vec3 normal, out vec3 uv, out vec3 object,\n\tout vec3 camera, out vec3 window, out vec3 reflection)\n{\n\tgenerated = attr_orco * 0.5 + vec3(0.5);\n\tnormal = normalize((obinvmat*(viewinvmat*vec4(N, 0.0))).xyz);\n\tuv = attr_uv;\n\tobject = (obinvmat*(viewinvmat*vec4(I, 1.0))).xyz;\n\tcamera = vec3(I.xy, -I.z);\n\tvec4 projvec = mat4(1) * vec4(I, 1.0);\n\twindow = vec3(mtex_2d_mapping(projvec.xyz/projvec.w).xy * camerafac.xy + camerafac.zw, 0.0);\n\n\tvec3 shade_I;\n\tshade_view(I, shade_I);\n\tvec3 view_reflection = reflect(shade_I, normalize(N));\n\treflection = (viewinvmat*vec4(view_reflection, 0.0)).xyz;\n}\n\nvoid node_tex_coord_background(vec3 I, vec3 N, mat4 viewinvmat, mat4 obinvmat, vec4 camerafac,\n\tvec3 attr_orco, vec3 attr_uv,\n\tout vec3 generated, out vec3 normal, out vec3 uv, out vec3 object,\n\tout vec3 camera, out vec3 window, out vec3 reflection)\n{\n\tvec4 v = (0.0 == 0.0) ? vec4(I, 1.0) : vec4(0.0, 0.0, 1.0, 1.0);\n\tvec4 co_homogenous = (mat4(1) * v);\n\n\tvec4 co = vec4(co_homogenous.xyz / co_homogenous.w, 0.0);\n\n\tco = normalize(co);\n\tvec3 coords = (mat4(1) * co).xyz;\n\n\tgenerated = coords;\n\tnormal = -coords;\n\tuv = vec3(attr_uv.xy, 0.0);\n\tobject = coords;\n\n\tcamera = vec3(co.xy, -co.z);\n\twindow = (0.0 == 0.0) ? \n\t              vec3(mtex_2d_mapping(I).xy * camerafac.xy + camerafac.zw, 0.0) : \n\t              vec3(vec2(0.5) * camerafac.xy + camerafac.zw, 0.0);\n\n\treflection = -coords;\n}\n\n/* textures */\n\nvoid node_tex_gradient(vec3 co, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_checker(vec3 co, vec4 color1, vec4 color2, float scale, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_brick(vec3 co, vec4 color1, vec4 color2, vec4 mortar, float scale, float mortar_size, float bias, float brick_width, float row_height, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_clouds(vec3 co, float size, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_environment_equirectangular(vec3 co, sampler2D ima, out vec4 color)\n{\n\tvec3 nco = normalize(co);\n\tfloat u = -atan(nco.y, nco.x)/(2.0*M_PI) + 0.5;\n\tfloat v = atan(nco.z, hypot(nco.x, nco.y))/M_PI + 0.5;\n\n\tcolor = texture2D(ima, vec2(u, v));\n}\n\nvoid node_tex_environment_mirror_ball(vec3 co, sampler2D ima, out vec4 color)\n{\n\tvec3 nco = normalize(co);\n\n\tnco.y -= 1.0;\n\n\tfloat div = 2.0*sqrt(max(-0.5*nco.y, 0.0));\n\tif(div > 0.0)\n\t\tnco /= div;\n\n\tfloat u = 0.5*(nco.x + 1.0);\n\tfloat v = 0.5*(nco.z + 1.0);\n\n\tcolor = texture2D(ima, vec2(u, v));\n}\n\nvoid node_tex_environment_empty(vec3 co, out vec4 color)\n{\n\tcolor = vec4(1.0, 0.0, 1.0, 1.0);\n}\n\nvoid node_tex_image(vec3 co, sampler2D ima, out vec4 color, out float alpha)\n{\n\tcolor = texture2D(ima, co.xy);\n\talpha = color.a;\n}\n\nvoid node_tex_image_empty(vec3 co, out vec4 color, out float alpha)\n{\n\tcolor = vec4(0.0);\n\talpha = 0.0;\n}\n\nvoid node_tex_magic(vec3 p, float scale, float distortion, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_musgrave(vec3 co, float scale, float detail, float dimension, float lacunarity, float offset, float gain, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_noise(vec3 co, float scale, float detail, float distortion, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_sky(vec3 co, out vec4 color)\n{\n\tcolor = vec4(1.0);\n}\n\nvoid node_tex_voronoi(vec3 co, float scale, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\nvoid node_tex_wave(vec3 co, float scale, float distortion, float detail, float detail_scale, out vec4 color, out float fac)\n{\n\tcolor = vec4(1.0);\n\tfac = 1.0;\n}\n\n/* light path */\n\nvoid node_light_path(\n\tout float is_camera_ray,\n\tout float is_shadow_ray,\n\tout float is_diffuse_ray,\n\tout float is_glossy_ray,\n\tout float is_singular_ray,\n\tout float is_reflection_ray,\n\tout float is_transmission_ray,\n\tout float ray_length,\n\tout float ray_depth,\n\tout float transparent_depth,\n\tout float transmission_depth)\n{\n\tis_camera_ray = 1.0;\n\tis_shadow_ray = 0.0;\n\tis_diffuse_ray = 0.0;\n\tis_glossy_ray = 0.0;\n\tis_singular_ray = 0.0;\n\tis_reflection_ray = 0.0;\n\tis_transmission_ray = 0.0;\n\tray_length = 1.0;\n\tray_depth = 1.0;\n\ttransparent_depth = 1.0;\n\ttransmission_depth = 1.0;\n}\n\nvoid node_light_falloff(float strength, float tsmooth, out float quadratic, out float linear, out float constant)\n{\n\tquadratic = strength;\n\tlinear = strength;\n\tconstant = strength;\n}\n\nvoid node_object_info(out vec3 location, out float object_index, out float material_index, out float random)\n{\n\tlocation = vec3(0.0);\n\tobject_index = 0.0;\n\tmaterial_index = 0.0;\n\trandom = 0.0;\n}\n\nvoid node_normal_map(float strength, vec4 color, vec3 N, out vec3 result)\n{\n\tresult = N;\n}\n\nvoid node_bump(float strength, float dist, float height, vec3 N, out vec3 result)\n{\n\tresult = N;\n}\n\n/* output */\n\nvoid node_output_material(vec4 surface, vec4 volume, float displacement, out vec4 result)\n{\n\tresult = surface;\n}\n\nvoid node_output_world(vec4 surface, vec4 volume, out vec4 result)\n{\n\tresult = surface;\n}\n\n/* ********************** matcap style render ******************** */\n\nvoid material_preview_matcap(vec4 color, sampler2D ima, vec4 N, vec4 mask, out vec4 result)\n{\n\tvec3 normal;\n\tvec2 tex;\n\t\n#ifndef USE_OPENSUBDIV\n\t/* remap to 0.0 - 1.0 range. This is done because OpenGL 2.0 clamps colors \n\t * between shader stages and we want the full range of the normal */\n\tnormal = vec3(2.0, 2.0, 2.0) * vec3(N.x, N.y, N.z) - vec3(1.0, 1.0, 1.0);\n\tif (normal.z < 0.0) {\n\t\tnormal.z = 0.0;\n\t}\n\tnormal = normalize(normal);\n#else\n\tnormal = inpt.v.normal;\n\tmask = vec4(1.0, 1.0, 1.0, 1.0);\n#endif\n\n\ttex.x = 0.5 + 0.49 * normal.x;\n\ttex.y = 0.5 + 0.49 * normal.y;\n\tresult = texture2D(ima, tex) * mask;\n}"},{"type": "TEXTURE", "use_mipmap": null, "wrap": null, "formats": {"jpeg": [{"height": 64, "file_size": 2132, "width": 64, "file_name": "wood-64x64.jpg"}, {"height": 1024, "file_size": 138473, "width": 1024, "file_name": "wood.jpg"}]}, "filter": null, "name": "wood"},{"type": "TEXTURE", "use_mipmap": null, "wrap": null, "formats": {"jpeg": [{"height": 32, "file_size": 1207, "width": 32, "file_name": "noise.jpg"}]}, "filter": null, "name": "noise"},{"type": "TEXTURE", "use_mipmap": null, "wrap": null, "formats": {"jpeg": [{"height": 64, "file_size": 3476, "width": 64, "file_name": "roorh-64x64.jpg"}, {"height": 512, "file_size": 65840, "width": 512, "file_name": "roorh.jpg"}]}, "filter": null, "name": "roorh"},{"type": "TEXTURE", "use_mipmap": null, "wrap": null, "formats": {"jpeg": [{"height": 8, "file_size": 3440, "width": 8, "file_name": "cloth.jpg"}]}, "filter": null, "name": "cloth"},{"type": "TEXTURE", "use_mipmap": null, "wrap": null, "formats": {"jpeg": [{"height": 64, "file_size": 4131, "width": 64, "file_name": "environ.jpg"}]}, "filter": null, "name": "environ"},{"type": "MATERIAL", "fragment": "\n\r\nvarying vec3 varnormal;\nvarying vec3 varposition;\nvarying vec2 var0;\nuniform sampler2D samp0;\nuniform vec3 unf17;\nconst float cons20 = float(1.000000);\nuniform vec3 unf22;\nconst float cons25 = float(1.000000);\nconst vec3 cons30 = vec3(20.000000, 20.000000, 1.000000);\nconst vec3 cons33 = vec3(-9.500000, -9.500000, 0.000000);\nuniform sampler2D samp1;\nconst float cons44 = float(0.241379);\nconst float cons45 = float(1.000000);\nconst float cons55 = float(1.000000);\nconst float cons57 = float(0.130000);\nuniform vec3 unf61;\nuniform float unf70;\nuniform float unf72;\nuniform vec3 unf73;\nuniform sampler2D samp2;\nuniform mat4 unf77;\nconst float cons78 = float(0.000005);\nconst float cons79 = float(0.100000);\nconst vec4 cons89 = vec4(0.013496, 0.075797, 0.201898, 0.000005);\nconst float cons100 = float(0.100000);\nuniform float unf103;\nconst float cons119 = float(1.000000);\nuniform vec4 unf120;\nconst float cons126 = float(1.000000);\nuniform vec4 unfobcolor;\nuniform float unf132;\nuniform float unf133;\nuniform float unf134;\nuniform float unf135;\nuniform float unf136;\nuniform vec4 unf140;\nconst float cons148 = float(1.000000);\nconst float cons150 = float(1.000000);\nconst vec4 cons152 = vec4(1.000000, 1.000000, 1.000000, 1.000000);\nconst float cons155 = float(1.000000);\n\nvoid main()\n{\n\tvec3 facingnormal = gl_FrontFacing? varnormal: -varnormal;\n\tvec3 tmp2;\n\tvec3 tmp4;\n\tvec3 tmp6;\n\tfloat tmp9;\n\tvec4 tmp10;\n\tvec4 tmp12;\n\tfloat tmp14;\n\tvec4 tmp16;\n\tvec3 tmp21;\n\tvec3 tmp26;\n\tvec3 tmp28;\n\tvec3 tmp31;\n\tvec3 tmp34;\n\tfloat tmp37;\n\tvec4 tmp38;\n\tvec4 tmp40;\n\tfloat tmp41;\n\tvec4 tmp43;\n\tfloat tmp46;\n\tvec3 tmp51;\n\tvec3 tmp56;\n\tvec4 tmp59;\n\tvec3 tmp60;\n\tvec3 tmp62;\n\tfloat tmp63;\n\tfloat tmp64;\n\tfloat tmp67;\n\tfloat tmp71;\n\tvec3 tmp74;\n\tfloat tmp81;\n\tvec4 tmp84;\n\tfloat tmp86;\n\tvec4 tmp90;\n\tfloat tmp92;\n\tvec4 tmp96;\n\tfloat tmp101;\n\tfloat tmp106;\n\tvec3 tmp110;\n\tvec4 tmp113;\n\tvec4 tmp115;\n\tvec4 tmp117;\n\tvec4 tmp121;\n\tvec4 tmp124;\n\tvec4 tmp127;\n\tvec4 tmp130;\n\tfloat tmp137;\n\tvec4 tmp141;\n\tvec4 tmp143;\n\tvec4 tmp146;\n\tvec4 tmp149;\n\tvec4 tmp153;\n\tvec4 tmp156;\n\tvec4 tmp158;\n\n\tshade_norm(facingnormal, tmp2);\n\tshade_view(varposition, tmp4);\n\ttexco_uv(var0, tmp6);\n\tmtex_image(tmp6, samp0, tmp9, tmp10);\n\tset_rgba(tmp10, tmp12);\n\tmtex_alpha_from_col(tmp10, tmp14);\n\tsrgb_to_linearrgb(tmp12, tmp16);\n\tmtex_rgb_blend(unf17, tmp16.rgb, tmp14, cons20, tmp21);\n\tmtex_rgb_blend(unf22, tmp16.rgb, tmp14, cons25, tmp26);\n\ttexco_uv(var0, tmp28);\n\tmtex_mapping_size(tmp28, cons30, tmp31);\n\tmtex_mapping_ofs(tmp31, cons33, tmp34);\n\tmtex_image(tmp34, samp1, tmp37, tmp38);\n\tset_rgba(tmp38, tmp40);\n\tset_value_one(tmp41);\n\tsrgb_to_linearrgb(tmp40, tmp43);\n\tmath_multiply(cons44, cons45, tmp46);\n\tmtex_rgb_mul(tmp21, tmp43.rgb, tmp41, tmp46, tmp51);\n\tmtex_rgb_mul(tmp26, tmp43.rgb, tmp41, cons55, tmp56);\n\tshade_mul_value(cons57, vec4(tmp51, 1.0), tmp59);\n\tset_rgb_zero(tmp60);\n\tlamp_visibility_sun_hemi(unf61, tmp62, tmp63, tmp64);\n\tshade_inp(tmp2, tmp62, tmp67);\n\tshade_visifac(tmp67, tmp64, unf70, tmp71);\n\tshade_mul_value_v3(unf72, unf73, tmp74);\n\ttest_shadowbuf_vsm(varposition, samp2, unf77, cons78, cons79, tmp67, tmp81);\n\tshade_mul_value(tmp71, vec4(tmp74, 1.0), tmp84);\n\tmtex_value_invert(tmp81, tmp86);\n\tmix_mult(tmp86, tmp84, cons89, tmp90);\n\tmtex_value_invert(tmp86, tmp92);\n\tshade_madd(tmp59, tmp90, vec4(tmp51, 1.0), tmp96);\n\tshade_wardiso_spec(tmp2, tmp62, tmp4, cons100, tmp101);\n\tshade_spec_t(tmp92, unf103, tmp64, tmp101, tmp106);\n\tshade_add_spec(tmp106, tmp74, tmp56, tmp110);\n\tshade_add_clamped(vec4(tmp60, 1.0), vec4(tmp110, 1.0), tmp113);\n\tshade_clamp_positive(tmp113, tmp115);\n\tshade_clamp_positive(tmp96, tmp117);\n\tshade_maddf(tmp117, cons119, unf120, tmp121);\n\tshade_add(tmp121, tmp115, tmp124);\n\tmtex_alpha_to_col(tmp124, cons126, tmp127);\n\tshade_obcolor(tmp127, unfobcolor, tmp130);\n\tshade_mist_factor(varposition, unf132, unf133, unf134, unf135, unf136, tmp137);\n\tmix_blend(tmp137, tmp130, unf140, tmp141);\n\tshade_alpha_opaque(tmp141, tmp143);\n\tshade_alpha_obcolor(tmp143, unfobcolor, tmp146);\n\tmtex_alpha_to_col(tmp146, cons148, tmp149);\n\tmix_mult(cons150, tmp149, cons152, tmp153);\n\toutput_node(tmp153, cons155, tmp156);\n\tlinearrgb_to_srgb(tmp156, tmp158);\n\n\tgl_FragColor = tmp158;\n}", "scene": "Scene", "double_sided": false, "params": [{"specular_hardness": 511, "emit": 0.11999999731779099, "diffuse_color": [1.0, 1.0, 1.0], "specular_color": [1.0, 1.0, 1.0], "specular_intensity": 0.4663677215576172, "diffuse_intensity": 0.6565022468566895, "alpha": 1.0}], "uniforms": [{"varname": "samp0", "type": 262146, "size": 138473, "wrap": "R", "texnumber": 0, "filepath": "wood.jpg", "filter": true, "image": "wood", "datatype": 1}, {"varname": "unf17", "type": 458753, "datatype": 4}, {"varname": "unf22", "type": 458755, "datatype": 4}, {"varname": "samp1", "type": 262146, "size": 3257, "wrap": "R", "texnumber": 1, "filepath": "noise.jpg", "filter": true, "image": "noise", "datatype": 1}, {"varname": "unf61", "type": 131073, "lamp": "Lamp", "datatype": 4}, {"varname": "unf70", "type": 458754, "datatype": 2}, {"varname": "unf72", "type": 131077, "lamp": "Lamp", "datatype": 2}, {"varname": "unf73", "type": 131078, "lamp": "Lamp", "datatype": 4}, {"varname": "samp2", "type": 262147, "lamp": "Lamp", "texnumber": 2, "texsize": 65536, "datatype": 1}, {"varname": "unf77", "type": 131076, "lamp": "Lamp", "datatype": 7}, {"varname": "unf103", "type": 458756, "datatype": 2}, {"varname": "unf120", "type": 393218, "datatype": 5}, {"varname": "unf132", "type": 327681, "datatype": 2}, {"varname": "unf133", "type": 327682, "datatype": 2}, {"varname": "unf134", "type": 327683, "datatype": 2}, {"varname": "unf135", "type": 327685, "datatype": 2}, {"varname": "unf136", "type": 327684, "datatype": 2}, {"varname": "unf140", "type": 327686, "datatype": 5}, {"varname": "unfobcolor", "type": 196613, "datatype": 5}], "name": "wood", "attributes": [{"varname": "att0", "type": 5, "name": 0, "datatype": 3, "number": 1}]},{"type": "MATERIAL", "fragment": "\n\r\nvarying vec3 varnormal;\nvarying vec2 var0;\nuniform sampler2D samp0;\nuniform vec3 unf14;\nconst float cons17 = float(1.000000);\nconst float cons19 = float(0.130000);\nuniform vec3 unf22;\nuniform float unf31;\nuniform float unf33;\nuniform vec3 unf34;\nvarying vec3 varposition;\nuniform sampler2D samp1;\nuniform mat4 unf38;\nconst float cons39 = float(0.000005);\nconst float cons40 = float(0.100000);\nconst vec4 cons50 = vec4(0.013496, 0.075797, 0.201898, 0.000005);\nconst float cons59 = float(1.000000);\nuniform float unf62;\nuniform float unf63;\nuniform float unf64;\nuniform float unf65;\nuniform float unf66;\nuniform vec4 unf70;\nconst float cons75 = float(1.000000);\nconst float cons77 = float(1.000000);\nconst vec4 cons79 = vec4(1.000000, 1.000000, 1.000000, 1.000000);\nconst float cons82 = float(1.000000);\n\nvoid main()\n{\n\tvec3 facingnormal = gl_FrontFacing? varnormal: -varnormal;\n\tvec3 tmp2;\n\tvec3 tmp4;\n\tfloat tmp7;\n\tvec4 tmp8;\n\tvec4 tmp10;\n\tfloat tmp11;\n\tvec4 tmp13;\n\tvec3 tmp18;\n\tvec4 tmp21;\n\tvec3 tmp23;\n\tfloat tmp24;\n\tfloat tmp25;\n\tfloat tmp28;\n\tfloat tmp32;\n\tvec3 tmp35;\n\tfloat tmp42;\n\tvec4 tmp45;\n\tfloat tmp47;\n\tvec4 tmp51;\n\tvec4 tmp55;\n\tvec4 tmp57;\n\tvec4 tmp60;\n\tfloat tmp67;\n\tvec4 tmp71;\n\tvec4 tmp73;\n\tvec4 tmp76;\n\tvec4 tmp80;\n\tvec4 tmp83;\n\tvec4 tmp85;\n\n\tshade_norm(facingnormal, tmp2);\n\ttexco_uv(var0, tmp4);\n\tmtex_image(tmp4, samp0, tmp7, tmp8);\n\tset_rgba(tmp8, tmp10);\n\tset_value_one(tmp11);\n\tsrgb_to_linearrgb(tmp10, tmp13);\n\tmtex_rgb_blend(unf14, tmp13.rgb, tmp11, cons17, tmp18);\n\tshade_mul_value(cons19, vec4(tmp18, 1.0), tmp21);\n\tlamp_visibility_sun_hemi(unf22, tmp23, tmp24, tmp25);\n\tshade_inp(tmp2, tmp23, tmp28);\n\tshade_visifac(tmp28, tmp25, unf31, tmp32);\n\tshade_mul_value_v3(unf33, unf34, tmp35);\n\ttest_shadowbuf_vsm(varposition, samp1, unf38, cons39, cons40, tmp28, tmp42);\n\tshade_mul_value(tmp32, vec4(tmp35, 1.0), tmp45);\n\tmtex_value_invert(tmp42, tmp47);\n\tmix_mult(tmp47, tmp45, cons50, tmp51);\n\tshade_madd(tmp21, tmp51, vec4(tmp18, 1.0), tmp55);\n\tshade_clamp_positive(tmp55, tmp57);\n\tmtex_alpha_to_col(tmp57, cons59, tmp60);\n\tshade_mist_factor(varposition, unf62, unf63, unf64, unf65, unf66, tmp67);\n\tmix_blend(tmp67, tmp60, unf70, tmp71);\n\tshade_alpha_opaque(tmp71, tmp73);\n\tmtex_alpha_to_col(tmp73, cons75, tmp76);\n\tmix_mult(cons77, tmp76, cons79, tmp80);\n\toutput_node(tmp80, cons82, tmp83);\n\tlinearrgb_to_srgb(tmp83, tmp85);\n\n\tgl_FragColor = tmp85;\n}", "scene": "Scene", "double_sided": false, "params": [{"specular_hardness": 2, "emit": 0.009999999776482582, "diffuse_color": [0.647055447101593, 0.37091171741485596, 0.19159050285816193], "specular_color": [1.0, 1.0, 1.0], "specular_intensity": 0.0, "diffuse_intensity": 0.6370967626571655, "alpha": 1.0}], "uniforms": [{"varname": "samp0", "type": 262146, "size": 255043, "wrap": "R", "texnumber": 0, "filepath": "roorh.jpg", "filter": true, "image": "roorh", "datatype": 1}, {"varname": "unf14", "type": 458753, "datatype": 4}, {"varname": "unf22", "type": 131073, "lamp": "Lamp", "datatype": 4}, {"varname": "unf31", "type": 458754, "datatype": 2}, {"varname": "unf33", "type": 131077, "lamp": "Lamp", "datatype": 2}, {"varname": "unf34", "type": 131078, "lamp": "Lamp", "datatype": 4}, {"varname": "samp1", "type": 262147, "lamp": "Lamp", "texnumber": 1, "texsize": 65536, "datatype": 1}, {"varname": "unf38", "type": 131076, "lamp": "Lamp", "datatype": 7}, {"varname": "unf62", "type": 327681, "datatype": 2}, {"varname": "unf63", "type": 327682, "datatype": 2}, {"varname": "unf64", "type": 327683, "datatype": 2}, {"varname": "unf65", "type": 327685, "datatype": 2}, {"varname": "unf66", "type": 327684, "datatype": 2}, {"varname": "unf70", "type": 327686, "datatype": 5}], "name": "skin", "attributes": [{"varname": "att0", "type": 5, "name": 0, "datatype": 3, "number": 1}]},{"type": "MATERIAL", "fragment": "\n\r\nvarying vec3 varposition;\nvarying vec3 varnormal;\nuniform mat4 unfinvviewmat;\nconst vec3 var0 = vec3(0.0);\nvarying vec2 var1;\nvarying vec4 var2;\nconst mat4 cons17 = mat4(100.000000, 0.000000, 0.000000, 0.000000, 0.000000, 100.000000, 0.000000, 0.000000, 0.000000, 0.000000, 100.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000);\nconst vec3 cons18 = vec3(0.000000, 0.000000, 0.000000);\nconst vec3 cons19 = vec3(1.000000, 1.000000, 1.000000);\nconst float cons20 = float(0.000000);\nconst float cons21 = float(0.000000);\nuniform sampler2D samp0;\nuniform sampler2D samp1;\nconst float cons37 = float(0.609091);\nconst float cons41 = float(1.000000);\nconst vec4 cons43 = vec4(1.000000, 1.000000, 1.000000, 1.000000);\nuniform vec3 unf45;\nconst float cons52 = float(0.130000);\nuniform vec3 unf56;\nuniform float unf65;\nuniform float unf67;\nuniform vec3 unf68;\nuniform sampler2D samp2;\nuniform mat4 unf72;\nconst float cons73 = float(0.000005);\nconst float cons74 = float(0.100000);\nconst vec4 cons84 = vec4(0.013496, 0.075797, 0.201898, 0.000005);\nuniform float unf95;\nuniform float unf98;\nconst float cons113 = float(0.345455);\nconst float cons117 = float(1.000000);\nconst float cons121 = float(1.000000);\nconst float cons125 = float(0.580000);\nconst float cons129 = float(0.580000);\nconst float cons133 = float(0.580000);\nconst float cons137 = float(0.580000);\nconst float cons141 = float(0.580000);\nconst float cons145 = float(0.580000);\nconst vec3 cons150 = vec3(0.000000, 0.000000, 1.000000);\nconst float cons154 = float(4.559999);\nconst float cons155 = float(0.120000);\nconst float cons161 = float(1.000000);\nconst vec4 cons163 = vec4(1.000000, 1.000000, 1.000000, 1.000000);\nconst float cons166 = float(1.000000);\n\nvoid main()\n{\n\tvec3 facingnormal = gl_FrontFacing? varnormal: -varnormal;\n\tvec3 tmp7;\n\tvec3 tmp8;\n\tvec3 tmp9;\n\tvec3 tmp10;\n\tvec3 tmp11;\n\tvec3 tmp12;\n\tvec4 tmp13;\n\tfloat tmp14;\n\tfloat tmp15;\n\tvec3 tmp22;\n\tfloat tmp25;\n\tvec4 tmp26;\n\tvec3 tmp27;\n\tvec4 tmp29;\n\tfloat tmp32;\n\tvec4 tmp33;\n\tvec3 tmp34;\n\tvec4 tmp36;\n\tvec4 tmp40;\n\tvec4 tmp44;\n\tvec3 tmp46;\n\tvec3 tmp48;\n\tvec3 tmp50;\n\tfloat tmp51;\n\tvec4 tmp54;\n\tvec3 tmp55;\n\tvec3 tmp57;\n\tfloat tmp58;\n\tfloat tmp59;\n\tfloat tmp62;\n\tfloat tmp66;\n\tvec3 tmp69;\n\tfloat tmp76;\n\tvec4 tmp79;\n\tfloat tmp81;\n\tvec4 tmp85;\n\tfloat tmp87;\n\tvec4 tmp91;\n\tfloat tmp96;\n\tfloat tmp101;\n\tvec3 tmp105;\n\tvec4 tmp108;\n\tvec4 tmp110;\n\tvec4 tmp112;\n\tvec4 tmp116;\n\tvec4 tmp120;\n\tvec4 tmp124;\n\tvec4 tmp128;\n\tvec4 tmp132;\n\tvec4 tmp136;\n\tvec4 tmp140;\n\tvec4 tmp144;\n\tvec4 tmp148;\n\tvec3 tmp151;\n\tfloat tmp152;\n\tfloat tmp156;\n\tvec4 tmp160;\n\tvec4 tmp164;\n\tvec4 tmp167;\n\tvec4 tmp169;\n\n\tgeom(varposition, facingnormal, unfinvviewmat, var0, var1, var2, tmp7, tmp8, tmp9, tmp10, tmp11, tmp12, tmp13, tmp14, tmp15);\n\tmapping(tmp11, cons17, cons18, cons19, cons20, cons21, tmp22);\n\ttexture_image(tmp22, samp0, tmp25, tmp26, tmp27);\n\tsrgb_to_linearrgb(tmp26, tmp29);\n\ttexture_image(tmp11, samp1, tmp32, tmp33, tmp34);\n\tsrgb_to_linearrgb(tmp33, tmp36);\n\tmix_mult(cons37, tmp36, tmp29, tmp40);\n\tmix_overlay(cons41, tmp29, cons43, tmp44);\n\tset_rgb(unf45, tmp46);\n\tshade_view(varposition, tmp48);\n\tvec_math_normalize(tmp12, tmp50, tmp51);\n\tshade_mul_value(cons52, vec4(tmp46, 1.0), tmp54);\n\tset_rgb_zero(tmp55);\n\tlamp_visibility_sun_hemi(unf56, tmp57, tmp58, tmp59);\n\tshade_inp(tmp50, tmp57, tmp62);\n\tshade_visifac(tmp62, tmp59, unf65, tmp66);\n\tshade_mul_value_v3(unf67, unf68, tmp69);\n\ttest_shadowbuf_vsm(varposition, samp2, unf72, cons73, cons74, tmp62, tmp76);\n\tshade_mul_value(tmp66, vec4(tmp69, 1.0), tmp79);\n\tmtex_value_invert(tmp76, tmp81);\n\tmix_mult(tmp81, tmp79, cons84, tmp85);\n\tmtex_value_invert(tmp81, tmp87);\n\tshade_madd(tmp54, tmp85, vec4(tmp46, 1.0), tmp91);\n\tshade_cooktorr_spec(tmp50, tmp57, tmp48, unf95, tmp96);\n\tshade_spec_t(tmp87, unf98, tmp59, tmp96, tmp101);\n\tshade_add_spec(tmp101, tmp69, tmp36.rgb, tmp105);\n\tshade_add_clamped(vec4(tmp55, 1.0), vec4(tmp105, 1.0), tmp108);\n\tshade_clamp_positive(tmp108, tmp110);\n\tshade_clamp_positive(tmp91, tmp112);\n\tmix_mult(cons113, tmp110, tmp44, tmp116);\n\tmix_mult(cons117, tmp40, tmp112, tmp120);\n\tmix_add(cons121, tmp120, tmp116, tmp124);\n\tmix_screen(cons125, tmp40, tmp40, tmp128);\n\tmix_screen(cons129, tmp128, tmp128, tmp132);\n\tmix_screen(cons133, tmp132, tmp132, tmp136);\n\tmix_screen(cons137, tmp136, tmp136, tmp140);\n\tmix_screen(cons141, tmp140, tmp140, tmp144);\n\tmix_add(cons145, tmp144, tmp116, tmp148);\n\tnormal(tmp12, cons150, tmp151, tmp152);\n\tsqueeze(tmp152, cons154, cons155, tmp156);\n\tmix_blend(tmp156, tmp148, tmp124, tmp160);\n\tmix_mult(cons161, tmp160, cons163, tmp164);\n\toutput_node(tmp164, cons166, tmp167);\n\tlinearrgb_to_srgb(tmp167, tmp169);\n\n\tgl_FragColor = tmp169;\n}", "scene": "Scene", "double_sided": false, "params": [{"specular_hardness": 2, "emit": 1.9900000095367432, "diffuse_color": [1.0, 1.0, 1.0], "specular_color": [1.0, 1.0, 1.0], "specular_intensity": 1.0, "diffuse_intensity": 1.0, "alpha": 1.0}], "uniforms": [{"varname": "samp0", "type": 262146, "size": 3440, "wrap": "R", "texnumber": 0, "filepath": "cloth.jpg", "filter": true, "image": "cloth", "datatype": 1}, {"varname": "samp1", "type": 262146, "size": 255043, "wrap": "R", "texnumber": 1, "filepath": "roorh.jpg", "filter": true, "image": "roorh", "datatype": 1}, {"varname": "unf45", "type": 458753, "datatype": 4}, {"varname": "unf56", "type": 131073, "lamp": "Lamp", "datatype": 4}, {"varname": "unf65", "type": 458754, "datatype": 2}, {"varname": "unf67", "type": 131077, "lamp": "Lamp", "datatype": 2}, {"varname": "unf68", "type": 131078, "lamp": "Lamp", "datatype": 4}, {"varname": "samp2", "type": 262147, "lamp": "Lamp", "texnumber": 2, "texsize": 65536, "datatype": 1}, {"varname": "unf72", "type": 131076, "lamp": "Lamp", "datatype": 7}, {"varname": "unf95", "type": 458757, "datatype": 2}, {"varname": "unf98", "type": 458756, "datatype": 2}, {"varname": "unfinvviewmat", "type": 196611, "datatype": 7}], "name": "cloth", "attributes": [{"varname": "att1", "type": 5, "name": "UVMap", "datatype": 3, "number": 3}, {"varname": "att2", "type": 6, "name": 0, "datatype": 8, "number": 4}]},{"type": "MATERIAL", "fragment": "\n\r\nvarying vec3 varposition;\nvarying vec3 varnormal;\nuniform mat4 unfinvviewmat;\nconst vec3 var0 = vec3(0.0);\nvarying vec2 var1;\nvarying vec4 var2;\nconst mat4 cons17 = mat4(20.000000, 0.000000, 0.000000, 0.000000, 0.000000, 20.000000, 0.000000, 0.000000, 0.000000, 0.000000, 20.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000);\nconst vec3 cons18 = vec3(0.000000, 0.000000, 0.000000);\nconst vec3 cons19 = vec3(1.000000, 1.000000, 1.000000);\nconst float cons20 = float(0.000000);\nconst float cons21 = float(0.000000);\nuniform sampler2D samp0;\nuniform sampler2D samp1;\nconst float cons37 = float(0.609091);\nconst float cons41 = float(1.000000);\nconst vec4 cons43 = vec4(1.000000, 1.000000, 1.000000, 1.000000);\nuniform vec3 unf45;\nconst float cons52 = float(0.130000);\nuniform vec3 unf56;\nuniform float unf65;\nuniform float unf67;\nuniform vec3 unf68;\nuniform sampler2D samp2;\nuniform mat4 unf72;\nconst float cons73 = float(0.000005);\nconst float cons74 = float(0.100000);\nconst vec4 cons84 = vec4(0.013496, 0.075797, 0.201898, 0.000005);\nuniform float unf95;\nuniform float unf98;\nconst float cons113 = float(0.345455);\nconst float cons117 = float(1.000000);\nconst float cons121 = float(1.000000);\nconst float cons125 = float(0.580000);\nconst float cons129 = float(0.580000);\nconst float cons133 = float(0.580000);\nconst float cons137 = float(0.580000);\nconst float cons141 = float(0.580000);\nconst float cons145 = float(0.580000);\nconst vec3 cons150 = vec3(0.000000, 0.000000, 1.000000);\nconst float cons154 = float(4.559999);\nconst float cons155 = float(0.120000);\nconst float cons161 = float(1.000000);\nconst vec4 cons163 = vec4(1.000000, 1.000000, 1.000000, 1.000000);\nconst float cons166 = float(1.000000);\n\nvoid main()\n{\n\tvec3 facingnormal = gl_FrontFacing? varnormal: -varnormal;\n\tvec3 tmp7;\n\tvec3 tmp8;\n\tvec3 tmp9;\n\tvec3 tmp10;\n\tvec3 tmp11;\n\tvec3 tmp12;\n\tvec4 tmp13;\n\tfloat tmp14;\n\tfloat tmp15;\n\tvec3 tmp22;\n\tfloat tmp25;\n\tvec4 tmp26;\n\tvec3 tmp27;\n\tvec4 tmp29;\n\tfloat tmp32;\n\tvec4 tmp33;\n\tvec3 tmp34;\n\tvec4 tmp36;\n\tvec4 tmp40;\n\tvec4 tmp44;\n\tvec3 tmp46;\n\tvec3 tmp48;\n\tvec3 tmp50;\n\tfloat tmp51;\n\tvec4 tmp54;\n\tvec3 tmp55;\n\tvec3 tmp57;\n\tfloat tmp58;\n\tfloat tmp59;\n\tfloat tmp62;\n\tfloat tmp66;\n\tvec3 tmp69;\n\tfloat tmp76;\n\tvec4 tmp79;\n\tfloat tmp81;\n\tvec4 tmp85;\n\tfloat tmp87;\n\tvec4 tmp91;\n\tfloat tmp96;\n\tfloat tmp101;\n\tvec3 tmp105;\n\tvec4 tmp108;\n\tvec4 tmp110;\n\tvec4 tmp112;\n\tvec4 tmp116;\n\tvec4 tmp120;\n\tvec4 tmp124;\n\tvec4 tmp128;\n\tvec4 tmp132;\n\tvec4 tmp136;\n\tvec4 tmp140;\n\tvec4 tmp144;\n\tvec4 tmp148;\n\tvec3 tmp151;\n\tfloat tmp152;\n\tfloat tmp156;\n\tvec4 tmp160;\n\tvec4 tmp164;\n\tvec4 tmp167;\n\tvec4 tmp169;\n\n\tgeom(varposition, facingnormal, unfinvviewmat, var0, var1, var2, tmp7, tmp8, tmp9, tmp10, tmp11, tmp12, tmp13, tmp14, tmp15);\n\tmapping(tmp11, cons17, cons18, cons19, cons20, cons21, tmp22);\n\ttexture_image(tmp22, samp0, tmp25, tmp26, tmp27);\n\tsrgb_to_linearrgb(tmp26, tmp29);\n\ttexture_image(tmp11, samp1, tmp32, tmp33, tmp34);\n\tsrgb_to_linearrgb(tmp33, tmp36);\n\tmix_mult(cons37, tmp36, tmp29, tmp40);\n\tmix_overlay(cons41, tmp29, cons43, tmp44);\n\tset_rgb(unf45, tmp46);\n\tshade_view(varposition, tmp48);\n\tvec_math_normalize(tmp12, tmp50, tmp51);\n\tshade_mul_value(cons52, vec4(tmp46, 1.0), tmp54);\n\tset_rgb_zero(tmp55);\n\tlamp_visibility_sun_hemi(unf56, tmp57, tmp58, tmp59);\n\tshade_inp(tmp50, tmp57, tmp62);\n\tshade_visifac(tmp62, tmp59, unf65, tmp66);\n\tshade_mul_value_v3(unf67, unf68, tmp69);\n\ttest_shadowbuf_vsm(varposition, samp2, unf72, cons73, cons74, tmp62, tmp76);\n\tshade_mul_value(tmp66, vec4(tmp69, 1.0), tmp79);\n\tmtex_value_invert(tmp76, tmp81);\n\tmix_mult(tmp81, tmp79, cons84, tmp85);\n\tmtex_value_invert(tmp81, tmp87);\n\tshade_madd(tmp54, tmp85, vec4(tmp46, 1.0), tmp91);\n\tshade_cooktorr_spec(tmp50, tmp57, tmp48, unf95, tmp96);\n\tshade_spec_t(tmp87, unf98, tmp59, tmp96, tmp101);\n\tshade_add_spec(tmp101, tmp69, tmp36.rgb, tmp105);\n\tshade_add_clamped(vec4(tmp55, 1.0), vec4(tmp105, 1.0), tmp108);\n\tshade_clamp_positive(tmp108, tmp110);\n\tshade_clamp_positive(tmp91, tmp112);\n\tmix_mult(cons113, tmp110, tmp44, tmp116);\n\tmix_mult(cons117, tmp40, tmp112, tmp120);\n\tmix_add(cons121, tmp120, tmp116, tmp124);\n\tmix_screen(cons125, tmp40, tmp40, tmp128);\n\tmix_screen(cons129, tmp128, tmp128, tmp132);\n\tmix_screen(cons133, tmp132, tmp132, tmp136);\n\tmix_screen(cons137, tmp136, tmp136, tmp140);\n\tmix_screen(cons141, tmp140, tmp140, tmp144);\n\tmix_add(cons145, tmp144, tmp116, tmp148);\n\tnormal(tmp12, cons150, tmp151, tmp152);\n\tsqueeze(tmp152, cons154, cons155, tmp156);\n\tmix_blend(tmp156, tmp148, tmp124, tmp160);\n\tmix_mult(cons161, tmp160, cons163, tmp164);\n\toutput_node(tmp164, cons166, tmp167);\n\tlinearrgb_to_srgb(tmp167, tmp169);\n\n\tgl_FragColor = tmp169;\n}", "scene": "Scene", "double_sided": false, "params": [{"specular_hardness": 9, "emit": 0.0, "diffuse_color": [0.14412850141525269, 0.05126946419477463, 0.02732088789343834], "specular_color": [0.999976634979248, 0.40649691224098206, 0.1967352330684662], "specular_intensity": 0.0, "diffuse_intensity": 0.5155372023582458, "alpha": 1.0}], "uniforms": [{"varname": "samp0", "type": 262146, "size": 3257, "wrap": "R", "texnumber": 0, "filepath": "noise.jpg", "filter": true, "image": "noise", "datatype": 1}, {"varname": "samp1", "type": 262146, "size": 255043, "wrap": "R", "texnumber": 1, "filepath": "roorh.jpg", "filter": true, "image": "roorh", "datatype": 1}, {"varname": "unf45", "type": 458753, "datatype": 4}, {"varname": "unf56", "type": 131073, "lamp": "Lamp", "datatype": 4}, {"varname": "unf65", "type": 458754, "datatype": 2}, {"varname": "unf67", "type": 131077, "lamp": "Lamp", "datatype": 2}, {"varname": "unf68", "type": 131078, "lamp": "Lamp", "datatype": 4}, {"varname": "samp2", "type": 262147, "lamp": "Lamp", "texnumber": 2, "texsize": 65536, "datatype": 1}, {"varname": "unf72", "type": 131076, "lamp": "Lamp", "datatype": 7}, {"varname": "unf95", "type": 458757, "datatype": 2}, {"varname": "unf98", "type": 458756, "datatype": 2}, {"varname": "unfinvviewmat", "type": 196611, "datatype": 7}], "name": "leather", "attributes": [{"varname": "att1", "type": 5, "name": "UVMap", "datatype": 3, "number": 3}, {"varname": "att2", "type": 6, "name": 0, "datatype": 8, "number": 4}]},{"type": "MATERIAL", "fragment": "\n\r\nvarying vec3 varnormal;\nvarying vec3 varposition;\nvarying vec2 var0;\nuniform sampler2D samp0;\nuniform vec3 unf16;\nconst float cons19 = float(1.000000);\nconst vec3 cons24 = vec3(20.000000, 20.000000, 1.000000);\nconst vec3 cons27 = vec3(-9.500000, -9.500000, 0.000000);\nuniform sampler2D samp1;\nconst float cons35 = float(0.139827);\nconst float cons36 = float(1.000000);\nuniform float unf38;\nconst float cons41 = float(1.000000);\nuniform sampler2D samp2;\nconst float cons62 = float(0.713178);\nconst float cons63 = float(1.000000);\nconst float cons70 = float(0.130000);\nuniform vec3 unf74;\nuniform float unf83;\nuniform float unf85;\nuniform vec3 unf86;\nuniform sampler2D samp3;\nuniform mat4 unf90;\nconst float cons91 = float(0.000005);\nconst float cons92 = float(0.100000);\nconst vec4 cons102 = vec4(0.013496, 0.075797, 0.201898, 0.000005);\nuniform float unf116;\nuniform vec3 unf122;\nconst float cons135 = float(1.000000);\nuniform float unf138;\nuniform float unf139;\nuniform float unf140;\nuniform float unf141;\nuniform float unf142;\nuniform vec4 unf146;\nconst float cons151 = float(1.000000);\nconst vec3 cons154 = vec3(0.000000, 0.000000, 1.000000);\nconst float cons158 = float(7.420000);\nconst float cons159 = float(0.880000);\nconst vec4 cons162 = vec4(0.000000, 0.000000, 0.000000, 1.000000);\nconst vec3 cons166 = vec3(0.000000, 0.000000, 1.000000);\nconst float cons170 = float(12.710003);\nconst float cons171 = float(0.460000);\nconst float cons177 = float(1.000000);\nconst vec4 cons179 = vec4(1.000000, 1.000000, 1.000000, 1.000000);\nconst float cons182 = float(1.000000);\n\nvoid main()\n{\n\tvec3 facingnormal = gl_FrontFacing? varnormal: -varnormal;\n\tvec3 tmp2;\n\tvec3 tmp4;\n\tvec3 tmp6;\n\tfloat tmp9;\n\tvec4 tmp10;\n\tvec4 tmp12;\n\tfloat tmp13;\n\tvec4 tmp15;\n\tvec3 tmp20;\n\tvec3 tmp22;\n\tvec3 tmp25;\n\tvec3 tmp28;\n\tfloat tmp31;\n\tvec4 tmp32;\n\tfloat tmp34;\n\tfloat tmp37;\n\tfloat tmp39;\n\tfloat tmp44;\n\tfloat tmp46;\n\tvec3 tmp49;\n\tvec3 tmp51;\n\tfloat tmp54;\n\tvec4 tmp55;\n\tvec4 tmp57;\n\tfloat tmp59;\n\tvec4 tmp61;\n\tfloat tmp64;\n\tvec3 tmp69;\n\tvec4 tmp72;\n\tvec3 tmp73;\n\tvec3 tmp75;\n\tfloat tmp76;\n\tfloat tmp77;\n\tfloat tmp80;\n\tfloat tmp84;\n\tvec3 tmp87;\n\tfloat tmp94;\n\tvec4 tmp97;\n\tfloat tmp99;\n\tvec4 tmp103;\n\tfloat tmp105;\n\tvec4 tmp109;\n\tfloat tmp114;\n\tfloat tmp119;\n\tvec3 tmp123;\n\tvec4 tmp126;\n\tvec4 tmp128;\n\tvec4 tmp130;\n\tvec4 tmp133;\n\tvec4 tmp136;\n\tfloat tmp143;\n\tvec4 tmp147;\n\tvec4 tmp149;\n\tvec4 tmp152;\n\tvec3 tmp155;\n\tfloat tmp156;\n\tfloat tmp160;\n\tvec4 tmp164;\n\tvec3 tmp167;\n\tfloat tmp168;\n\tfloat tmp172;\n\tvec4 tmp176;\n\tvec4 tmp180;\n\tvec4 tmp183;\n\tvec4 tmp185;\n\n\tshade_norm(facingnormal, tmp2);\n\tshade_view(varposition, tmp4);\n\ttexco_uv(var0, tmp6);\n\tmtex_image(tmp6, samp0, tmp9, tmp10);\n\tset_rgba(tmp10, tmp12);\n\tset_value_one(tmp13);\n\tsrgb_to_linearrgb(tmp12, tmp15);\n\tmtex_rgb_mul(unf16, tmp15.rgb, tmp13, cons19, tmp20);\n\ttexco_uv(var0, tmp22);\n\tmtex_mapping_size(tmp22, cons24, tmp25);\n\tmtex_mapping_ofs(tmp25, cons27, tmp28);\n\tmtex_image(tmp28, samp1, tmp31, tmp32);\n\tmtex_rgbtoint(tmp32, tmp34);\n\tmath_multiply(cons35, cons36, tmp37);\n\tmtex_har_divide(unf38, tmp39);\n\tmtex_value_blend(tmp39, cons41, tmp34, tmp37, tmp44);\n\tmtex_har_multiply_clamp(tmp44, tmp46);\n\ttexco_refl(tmp2, tmp4, tmp49);\n\tmtex_2d_mapping(tmp49, tmp51);\n\tmtex_image(tmp51, samp2, tmp54, tmp55);\n\tset_rgba(tmp55, tmp57);\n\tmtex_alpha_from_col(tmp55, tmp59);\n\tsrgb_to_linearrgb(tmp57, tmp61);\n\tmath_multiply(cons62, cons63, tmp64);\n\tmtex_rgb_mul(tmp20, tmp61.rgb, tmp59, tmp64, tmp69);\n\tshade_mul_value(cons70, vec4(tmp69, 1.0), tmp72);\n\tset_rgb_zero(tmp73);\n\tlamp_visibility_sun_hemi(unf74, tmp75, tmp76, tmp77);\n\tshade_inp(tmp2, tmp75, tmp80);\n\tshade_visifac(tmp80, tmp77, unf83, tmp84);\n\tshade_mul_value_v3(unf85, unf86, tmp87);\n\ttest_shadowbuf_vsm(varposition, samp3, unf90, cons91, cons92, tmp80, tmp94);\n\tshade_mul_value(tmp84, vec4(tmp87, 1.0), tmp97);\n\tmtex_value_invert(tmp94, tmp99);\n\tmix_mult(tmp99, tmp97, cons102, tmp103);\n\tmtex_value_invert(tmp99, tmp105);\n\tshade_madd(tmp72, tmp103, vec4(tmp69, 1.0), tmp109);\n\tshade_cooktorr_spec(tmp2, tmp75, tmp4, tmp46, tmp114);\n\tshade_spec_t(tmp105, unf116, tmp77, tmp114, tmp119);\n\tshade_add_spec(tmp119, tmp87, unf122, tmp123);\n\tshade_add_clamped(vec4(tmp73, 1.0), vec4(tmp123, 1.0), tmp126);\n\tshade_clamp_positive(tmp126, tmp128);\n\tshade_clamp_positive(tmp109, tmp130);\n\tshade_add(tmp130, tmp128, tmp133);\n\tmtex_alpha_to_col(tmp133, cons135, tmp136);\n\tshade_mist_factor(varposition, unf138, unf139, unf140, unf141, unf142, tmp143);\n\tmix_blend(tmp143, tmp136, unf146, tmp147);\n\tshade_alpha_opaque(tmp147, tmp149);\n\tmtex_alpha_to_col(tmp149, cons151, tmp152);\n\tnormal(tmp2, cons154, tmp155, tmp156);\n\tsqueeze(tmp156, cons158, cons159, tmp160);\n\tmix_blend(tmp160, cons162, tmp152, tmp164);\n\tnormal(tmp2, cons166, tmp167, tmp168);\n\tsqueeze(tmp168, cons170, cons171, tmp172);\n\tmix_blend(tmp172, tmp152, tmp164, tmp176);\n\tmix_mult(cons177, tmp176, cons179, tmp180);\n\toutput_node(tmp180, cons182, tmp183);\n\tlinearrgb_to_srgb(tmp183, tmp185);\n\n\tgl_FragColor = tmp185;\n}", "scene": "Scene", "double_sided": false, "params": [{"specular_hardness": 1, "emit": 0.009999999776482582, "diffuse_color": [0.7949158549308777, 1.0, 0.8575833439826965], "specular_color": [1.0, 0.8535348176956177, 0.9847338795661926], "specular_intensity": 1.0, "diffuse_intensity": 1.0, "alpha": 1.0}], "uniforms": [{"varname": "samp0", "type": 262146, "size": 255043, "wrap": "R", "texnumber": 0, "filepath": "roorh.jpg", "filter": true, "image": "roorh", "datatype": 1}, {"varname": "unf16", "type": 458753, "datatype": 4}, {"varname": "samp1", "type": 262146, "size": 3257, "wrap": "R", "texnumber": 1, "filepath": "noise.jpg", "filter": true, "image": "noise", "datatype": 1}, {"varname": "unf38", "type": 458757, "datatype": 2}, {"varname": "samp2", "type": 262146, "size": 4131, "wrap": "R", "texnumber": 2, "filepath": "environ.jpg", "filter": true, "image": "environ", "datatype": 1}, {"varname": "unf74", "type": 131073, "lamp": "Lamp", "datatype": 4}, {"varname": "unf83", "type": 458754, "datatype": 2}, {"varname": "unf85", "type": 131077, "lamp": "Lamp", "datatype": 2}, {"varname": "unf86", "type": 131078, "lamp": "Lamp", "datatype": 4}, {"varname": "samp3", "type": 262147, "lamp": "Lamp", "texnumber": 3, "texsize": 65536, "datatype": 1}, {"varname": "unf90", "type": 131076, "lamp": "Lamp", "datatype": 7}, {"varname": "unf116", "type": 458756, "datatype": 2}, {"varname": "unf122", "type": 458755, "datatype": 4}, {"varname": "unf138", "type": 327681, "datatype": 2}, {"varname": "unf139", "type": 327682, "datatype": 2}, {"varname": "unf140", "type": 327683, "datatype": 2}, {"varname": "unf141", "type": 327685, "datatype": 2}, {"varname": "unf142", "type": 327684, "datatype": 2}, {"varname": "unf146", "type": 327686, "datatype": 5}], "name": "metal", "attributes": [{"varname": "att0", "type": 5, "name": 0, "datatype": 3, "number": 1}]},{"type": "MATERIAL", "fragment": "\n\r\nconst float cons1 = float(1.000000);\nconst float cons2 = float(0.130000);\nconst float cons4 = float(1.000000);\nconst float cons5 = float(0.700000);\nconst float cons10 = float(1.000000);\nvarying vec3 varnormal;\nvarying vec3 varposition;\nvarying vec2 var0;\nuniform sampler2D samp0;\nuniform vec3 unf28;\nconst float cons31 = float(1.000000);\nuniform vec3 unf37;\nuniform float unf44;\nuniform vec3 unf45;\nuniform sampler2D samp1;\nuniform mat4 unf49;\nconst float cons50 = float(0.000005);\nconst float cons51 = float(0.100000);\nconst float cons57 = float(0.300000);\nconst float cons58 = float(0.046362);\nuniform float unf61;\nuniform vec3 unf67;\nconst float cons80 = float(1.000000);\nuniform float unf83;\nuniform float unf84;\nuniform float unf85;\nuniform float unf86;\nuniform float unf87;\nuniform vec4 unf91;\nconst float cons96 = float(1.000000);\nconst float cons98 = float(1.000000);\nconst vec4 cons100 = vec4(1.000000, 1.000000, 1.000000, 1.000000);\nconst float cons103 = float(1.000000);\n\nvoid main()\n{\n\tvec3 facingnormal = gl_FrontFacing? varnormal: -varnormal;\n\tfloat tmp3;\n\tfloat tmp6;\n\tfloat tmp9;\n\tfloat tmp12;\n\tvec3 tmp14;\n\tvec3 tmp16;\n\tvec3 tmp18;\n\tfloat tmp21;\n\tvec4 tmp22;\n\tvec4 tmp24;\n\tfloat tmp25;\n\tvec4 tmp27;\n\tvec3 tmp32;\n\tvec4 tmp35;\n\tvec3 tmp36;\n\tvec3 tmp38;\n\tfloat tmp39;\n\tfloat tmp40;\n\tfloat tmp43;\n\tvec3 tmp46;\n\tfloat tmp53;\n\tfloat tmp59;\n\tfloat tmp64;\n\tvec3 tmp68;\n\tvec4 tmp71;\n\tvec4 tmp73;\n\tvec4 tmp75;\n\tvec4 tmp78;\n\tvec4 tmp81;\n\tfloat tmp88;\n\tvec4 tmp92;\n\tvec4 tmp94;\n\tvec4 tmp97;\n\tvec4 tmp101;\n\tvec4 tmp104;\n\tvec4 tmp106;\n\n\tmath_subtract(cons1, cons2, tmp3);\n\tmath_subtract(cons4, cons5, tmp6);\n\tmath_multiply(tmp3, tmp6, tmp9);\n\tmath_subtract(cons10, tmp9, tmp12);\n\tshade_norm(facingnormal, tmp14);\n\tshade_view(varposition, tmp16);\n\ttexco_uv(var0, tmp18);\n\tmtex_image(tmp18, samp0, tmp21, tmp22);\n\tset_rgba(tmp22, tmp24);\n\tset_value_one(tmp25);\n\tsrgb_to_linearrgb(tmp24, tmp27);\n\tmtex_rgb_blend(unf28, tmp27.rgb, tmp25, cons31, tmp32);\n\tshade_mul_value(tmp12, vec4(tmp32, 1.0), tmp35);\n\tset_rgb_zero(tmp36);\n\tlamp_visibility_sun_hemi(unf37, tmp38, tmp39, tmp40);\n\tshade_inp(tmp14, tmp38, tmp43);\n\tshade_mul_value_v3(unf44, unf45, tmp46);\n\ttest_shadowbuf_vsm(varposition, samp1, unf49, cons50, cons51, tmp43, tmp53);\n\tshade_toon_spec(tmp14, tmp38, tmp16, cons57, cons58, tmp59);\n\tshade_spec_t(tmp53, unf61, tmp40, tmp59, tmp64);\n\tshade_add_spec(tmp64, tmp46, unf67, tmp68);\n\tshade_add_clamped(vec4(tmp36, 1.0), vec4(tmp68, 1.0), tmp71);\n\tshade_clamp_positive(tmp71, tmp73);\n\tshade_clamp_positive(tmp35, tmp75);\n\tshade_add(tmp75, tmp73, tmp78);\n\tmtex_alpha_to_col(tmp78, cons80, tmp81);\n\tshade_mist_factor(varposition, unf83, unf84, unf85, unf86, unf87, tmp88);\n\tmix_blend(tmp88, tmp81, unf91, tmp92);\n\tshade_alpha_opaque(tmp92, tmp94);\n\tmtex_alpha_to_col(tmp94, cons96, tmp97);\n\tmix_mult(cons98, tmp97, cons100, tmp101);\n\toutput_node(tmp101, cons103, tmp104);\n\tlinearrgb_to_srgb(tmp104, tmp106);\n\n\tgl_FragColor = tmp106;\n}", "scene": "Scene", "double_sided": false, "params": [{"specular_hardness": 153, "emit": 0.0, "diffuse_color": [1.0, 0.19136667251586914, 0.0], "specular_color": [1.0, 0.42093127965927124, 0.24409735202789307], "specular_intensity": 1.0, "diffuse_intensity": 0.0, "alpha": 1.0}], "uniforms": [{"varname": "samp0", "type": 262146, "size": 255043, "wrap": "R", "texnumber": 0, "filepath": "roorh.jpg", "filter": true, "image": "roorh", "datatype": 1}, {"varname": "unf28", "type": 458753, "datatype": 4}, {"varname": "unf37", "type": 131073, "lamp": "Lamp", "datatype": 4}, {"varname": "unf44", "type": 131077, "lamp": "Lamp", "datatype": 2}, {"varname": "unf45", "type": 131078, "lamp": "Lamp", "datatype": 4}, {"varname": "samp1", "type": 262147, "lamp": "Lamp", "texnumber": 1, "texsize": 65536, "datatype": 1}, {"varname": "unf49", "type": 131076, "lamp": "Lamp", "datatype": 7}, {"varname": "unf61", "type": 458756, "datatype": 2}, {"varname": "unf67", "type": 458755, "datatype": 4}, {"varname": "unf83", "type": 327681, "datatype": 2}, {"varname": "unf84", "type": 327682, "datatype": 2}, {"varname": "unf85", "type": 327683, "datatype": 2}, {"varname": "unf86", "type": 327685, "datatype": 2}, {"varname": "unf87", "type": 327684, "datatype": 2}, {"varname": "unf91", "type": 327686, "datatype": 5}], "name": "crystal", "attributes": [{"varname": "att0", "type": 5, "name": 0, "datatype": 3, "number": 1}]},{"type": "ACTION", "markers": {}, "channels": [], "name": "simple_action"}]